<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>10 FPS游戏开发基础</title>
    <link href="/2025/04/29/UE_TOC/10-FPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/04/29/UE_TOC/10-FPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="1-FPS游戏简介"><a href="#1-FPS游戏简介" class="headerlink" title="1. FPS游戏简介"></a>1. FPS游戏简介</h1><p>FPS：First-person Shooter<br><pre><code class=" mermaid">graph LR德军总部3D --&gt; 毁灭战士毁灭战士 --&gt; 半条命半条命 --&gt; 反恐精英</code></pre></p><h1 id="2-FPS游戏基础框架"><a href="#2-FPS游戏基础框架" class="headerlink" title="2. FPS游戏基础框架"></a>2. FPS游戏基础框架</h1><table>  <tr align="center">  <td colspan=2,>Weapon</td>  <td colspan=2>3C</td>  <td colspan=2,>GamePlay</td>  </tr>  <tr align="center">  <td colspan=6,>GamePlay</td>  </tr>  <tr align="center">  <td colspan=3,>Game Core</td>  <td colspan=3>Third Party Library</td>  </tr>  <tr align="center">  <td colspan=6,>Game Engine </td>  </tr>  <tr align="center">  <td colspan=6,>Operating System </td>  </tr>  </table><h1 id="3-Weapon-System"><a href="#3-Weapon-System" class="headerlink" title="3. Weapon System"></a>3. Weapon System</h1><h2 id="FPS中常见的武器类型"><a href="#FPS中常见的武器类型" class="headerlink" title="FPS中常见的武器类型"></a>FPS中常见的武器类型</h2><ul><li>按种类分：<br>步枪、狙击枪、手枪、手雷等</li><li>按装备位分<br>主武器、副武器、近战武器、投掷武器</li><li>按程序逻辑分<br>lnstantHit、Projectile等</li></ul><h2 id="关键基础组件"><a href="#关键基础组件" class="headerlink" title="关键基础组件"></a>关键基础组件</h2><h3 id="物理引擎"><a href="#物理引擎" class="headerlink" title="物理引擎"></a>物理引擎</h3><h4 id="PhysX"><a href="#PhysX" class="headerlink" title="PhysX"></a>PhysX</h4><ul><li>属于NVIDA，现已开源，是UE4和Unitl的主要内置物理引擎，使用它的游戏非常多<h4 id="Havok"><a href="#Havok" class="headerlink" title="Havok"></a>Havok</h4></li><li>老牌的商业引擎，代表作品包括：刺客信条，Doom Eternal，Monster Hunter World等<h4 id="Bullet"><a href="#Bullet" class="headerlink" title="Bullet"></a>Bullet</h4></li><li>广泛应用于游戏开发和电影制作中。Bullet也是AMD开放物理计划成员之一<h3 id="弹道模型"><a href="#弹道模型" class="headerlink" title="弹道模型"></a>弹道模型</h3><h4 id="影响弹道的因素"><a href="#影响弹道的因素" class="headerlink" title="影响弹道的因素"></a>影响弹道的因素</h4></li><li>主视角角度</li><li>后坐力</li><li>连发数</li><li>精准度</li><li>散发度<h4 id="后坐力与连发的关系"><a href="#后坐力与连发的关系" class="headerlink" title="后坐力与连发的关系"></a>后坐力与连发的关系</h4></li><li>主弹道子弹射出方向=主视角角度+后坐力+精准度+散发度</li><li>后坐力、精准度、散发度与具体武器相关，通过配置参数与公式计算得出</li><li>举例一种散发度的公式：散发方向=随机数x散发x水平/垂直方向</li></ul><h1 id="4-3C-System"><a href="#4-3C-System" class="headerlink" title="4. 3C System"></a>4. 3C System</h1><h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><p>角色，具有一定的能力或行为，玩家可以进行扮演或观察</p><p>技术要点：</p><ul><li>表现方面</li><li>逻辑方面</li><li>角色状态的设计与转换</li><li>细节问题</li></ul><h2 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h2><p>相机，玩家通过它观察游戏世界，获得体验感和沉浸感</p><p>技术要点</p><ul><li>渲染顺序</li><li>FOV</li><li><p>碰撞盒位置的控制</p><h2 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h2><p>为玩家提供了不同的方式和不同的体验</p><ul><li>设备与手感</li><li>手游适配问题<ul><li>同样代码，iOS与Android灵敏度不同</li><li>不同Android手机，灵敏度不同</li><li>部分Android手机灵敏度偏低</li></ul></li></ul></li><li>辅助瞄准</li><li>硬件功能</li></ul><h1 id="5-其他技术点"><a href="#5-其他技术点" class="headerlink" title="5. 其他技术点"></a>5. 其他技术点</h1><h2 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h2><ul><li>帧同步与状态同步</li><li>Peeker’s Advantage<h2 id="反外挂"><a href="#反外挂" class="headerlink" title="反外挂"></a>反外挂</h2></li><li>外挂分类</li><li>外挂原理</li><li>方法：<ul><li>服务器校验</li><li>服务器数据下发</li><li>客户端数据加密</li><li>客户端动态检测</li></ul></li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h3><ul><li>物理性能优化</li><li>动画优化</li><li>流程逻辑优化</li><li>Pool的使用<h3 id="渲染性能优化"><a href="#渲染性能优化" class="headerlink" title="渲染性能优化"></a>渲染性能优化</h3></li><li>UI/场景优化</li><li>指定制作规范<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3></li><li>合理合图</li><li>资源压缩</li><li>资源分包<h3 id="流量优化"><a href="#流量优化" class="headerlink" title="流量优化"></a>流量优化</h3></li><li>减少网络总类</li><li>合并网络包</li></ul>]]></content>
    
    
    <categories>
      
      <category>Unreal</category>
      
      <category>腾讯公开课</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09 AI技术</title>
    <link href="/2025/04/29/UE_TOC/09-AI%E6%8A%80%E6%9C%AF/"/>
    <url>/2025/04/29/UE_TOC/09-AI%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="游戏AI技术概述"><a href="#游戏AI技术概述" class="headerlink" title="游戏AI技术概述"></a>游戏AI技术概述</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>学术AI</strong>：AI指一个可以观察周遭环境并作出行动以达致成功的系统<br><strong>游戏AI</strong>： 满足玩家在游戏中的体验感</p><h2 id="基础术语"><a href="#基础术语" class="headerlink" title="基础术语"></a>基础术语</h2><ul><li>玩家角色（Player Character）</li><li>电脑假冒的玩家角色（Bot）</li><li>敌人、对话村民（NPC ）</li></ul><h2 id="游戏AI的目的"><a href="#游戏AI的目的" class="headerlink" title="游戏AI的目的"></a>游戏AI的目的</h2><ol><li>提升玩家的游戏代入感以及各种情感</li><li>有趣，强度适中，满足玩家心流的挑战</li><li>行为合理,没有明显破绽</li><li>可能需要“真实”</li></ol><h2 id="游戏AI四大主题"><a href="#游戏AI四大主题" class="headerlink" title="游戏AI四大主题"></a>游戏AI四大主题</h2><h3 id="环境感应"><a href="#环境感应" class="headerlink" title="环境感应"></a>环境感应</h3><ul><li>视野管理(通过物理系统)</li><li>听觉管理(NavMesh)</li><li>将复杂环境数据转化为便于Al系统理解的简单中间数据</li></ul><h3 id="知识管理"><a href="#知识管理" class="headerlink" title="知识管理"></a>知识管理</h3><p>通过黑板(Blackboard)来作为数据共享，</p><ul><li>Agent黑板</li><li>squad黑板</li></ul><p>存储</p><ul><li>消耗大的感应结果</li><li>寻路结果</li><li>分帧Plan的部分Plan结果</li></ul><h3 id="行为模型"><a href="#行为模型" class="headerlink" title="行为模型"></a>行为模型</h3><ul><li>没有万金油的行为模型能解决一切AlI问题</li><li>了解这些方法的核心思路，有助于选型、组合解决实际Al问题</li></ul><h4 id="1-朴素脚本代码"><a href="#1-朴素脚本代码" class="headerlink" title="1.朴素脚本代码"></a>1.朴素脚本代码</h4><ul><li>如魔兽世界早期的boss，使用switch case 实现各种情况</li></ul><h4 id="2-有限状态机（Finite-State-Machine，FSM）"><a href="#2-有限状态机（Finite-State-Machine，FSM）" class="headerlink" title="2.有限状态机（Finite State Machine，FSM）"></a>2.有限状态机（Finite State Machine，FSM）</h4><ul><li>本质是图</li><li>原理简单：—个时刻只处于一个状态，符合条件时跳转状态</li><li>随着状态增多，状态间跳转可能会平方级增长</li><li>状态的重用性差，状态Copy Paste严重</li></ul><h4 id="3-分层有限状态机（Hierarchical-Finite-State-Machine，HFSM）"><a href="#3-分层有限状态机（Hierarchical-Finite-State-Machine，HFSM）" class="headerlink" title="3.分层有限状态机（Hierarchical Finite State Machine，HFSM）"></a>3.分层有限状态机（Hierarchical Finite State Machine，HFSM）</h4><ul><li>通过状态分层(分组)，做到状态按组重用</li><li>每层都有自己的“历史状态”的引用节点</li><li>重回状态层时，直接进入H所引用的状态</li></ul><h4 id="4-行为树（Behavior-Tree）"><a href="#4-行为树（Behavior-Tree）" class="headerlink" title="4.行为树（Behavior Tree）"></a>4.行为树（Behavior Tree）</h4><ul><li>本质是树</li><li>应用游戏︰始于Halo2，不计其数</li><li>节点返回当前执行状态：运行中、已成功、已失败</li><li>组合节点（Composite）有1~N个孩子，其决定直接孩子的执行方式<ul><li>顺序执行（Sequence）</li><li>选择执行（Selector）</li><li>并行执行（Parallel）</li><li>可继承可扩展</li></ul></li><li>叶子节点<ul><li>判断节点（Conditional），读取环境信息判断是否符合执行条件</li><li>行为行节点（Action），执行具体行为</li></ul></li><li>节点可被继承为特定功能的节点类型<ul><li>比如一个Action是一个状态机，</li><li>一个判断节点是一个效用决策器</li></ul></li></ul><h4 id="5-效用决策（Utility-Decision-System）"><a href="#5-效用决策（Utility-Decision-System）" class="headerlink" title="5.效用决策（Utility Decision System）"></a>5.效用决策（Utility Decision System）</h4><ul><li>应用游戏：模拟人生</li><li>蚂蚁军团:现在要扩展领土?还是培育更多兵力?</li><li>根据环境，个体对每个特性进行归一化评分<ul><li>人口拥挤程度：0.9</li><li>健康程度：0.92</li><li>培育剩余空间：0.15</li></ul></li><li>为每个特性加上权重，发现扩展的分数0.91大于培育分数0.535</li><li>所以最终选择扩展领土的行为</li><li>相比之前框架，行为开始显得非常动态自驱</li><li>缺点︰可能难以调参</li></ul><pre><code class=" mermaid">graph LRPopulation:4500 --&gt; Crowdedness:0.9MaxPop:5000 --&gt; Crowdedness:0.9Food:92 --&gt; Health:0.92NurserySpace:15 --&gt; Nursery:0.15Crowdedness:0.9 --&gt; ActionExpandScore:0.91Health:0.92 --&gt; ActionExpandScore:0.91Health:0.92 --&gt; ActionBreedScore:0.535Nursery:0.15 --&gt; ActionBreedScore:0.535</code></pre><h4 id="6-GOAP（Goal-Oriented-Action-Planners，目标导向行为规划）"><a href="#6-GOAP（Goal-Oriented-Action-Planners，目标导向行为规划）" class="headerlink" title="6.GOAP（Goal-Oriented Action Planners，目标导向行为规划）"></a>6.GOAP（Goal-Oriented Action Planners，目标导向行为规划）</h4><ul><li>应用游戏：F.E.A.R、Fallout3、JustCause2，…..</li><li>开发者定义每个行为：先决条件、消耗、结果</li><li>运行时后向搜索：从目标状态开始回溯搜索，搜索满足条件的行为列表</li><li>挑选消耗和最小的行为列表</li><li>执行这个行为列表</li><li>优点：开发者只需配置行为本身，行为序列的建立通过运行时搜索动态建立</li></ul><p>配置</p><div class="table-container"><table><thead><tr><th style="text-align:center">Action</th><th style="text-align:center">Condition</th><th style="text-align:center">Effect</th><th style="text-align:center">Cost</th></tr></thead><tbody><tr><td style="text-align:center">巡逻</td><td style="text-align:center">没发现敌人&amp;&amp;无来电</td><td style="text-align:center">安全</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">接电话</td><td style="text-align:center">没发现敌人&amp;&amp;有来电</td><td style="text-align:center">信息更新</td><td style="text-align:center">30</td></tr><tr><td style="text-align:center">关闭出入口</td><td style="text-align:center">发现敌人</td><td style="text-align:center">安全</td><td style="text-align:center">40</td><td></td></tr><tr><td style="text-align:center">攻击敌人</td><td style="text-align:center">发现敌人&amp;&amp;有武器&amp;&amp;已关闭出入口</td><td style="text-align:center">安全</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">获取武器</td><td style="text-align:center">发现敌人&amp;&amp;无武器</td><td style="text-align:center">有武器</td><td style="text-align:center">10</td></tr></tbody></table></div><h4 id="7-HTN（Hierarchical-Task-Networks，层级任务网络）"><a href="#7-HTN（Hierarchical-Task-Networks，层级任务网络）" class="headerlink" title="7.HTN（Hierarchical Task Networks，层级任务网络）"></a>7.HTN（Hierarchical Task Networks，层级任务网络）</h4><ul><li>应用游戏：上古卷轴、Killzone3、HorizonZeroDawn，……</li><li>和GOAP有相似之处，但不同点主要在于:<ul><li>元任务（Primitive Task）可组合为组合任务（Compound Task）</li><li>每个任务有自己的条件、行动、结果</li><li>运行时前向搜索，不断地搜索符合条件的任务(元任务、组合任务)</li><li>直到所有任务都是元任务，得出一个任务列表，</li><li>执行这个任务列表</li></ul></li></ul><h4 id="8-Maching-Learning"><a href="#8-Maching-Learning" class="headerlink" title="8.Maching Learning"></a>8.Maching Learning</h4><h3 id="寻路"><a href="#寻路" class="headerlink" title="寻路"></a>寻路</h3><p>搜索需要基于一定的规则，将地图离散化<br>a. 原始地图<br>b.按格子离散<br>c.按waypoint离散<br>d.按三角形离散，Nav Mesh</p><div class="table-container"><table><thead><tr><th style="text-align:center">实现</th><th style="text-align:center">量级</th><th style="text-align:center">搜索速度</th><th style="text-align:center">平滑</th><th style="text-align:center">编辑</th></tr></thead><tbody><tr><td style="text-align:center">简单</td><td style="text-align:center">大</td><td style="text-align:center">慢</td><td style="text-align:center">低</td><td style="text-align:center">易</td></tr><tr><td style="text-align:center">较简单</td><td style="text-align:center">中</td><td style="text-align:center">中</td><td style="text-align:center">中</td><td style="text-align:center">中</td></tr><tr><td style="text-align:center">较复杂</td><td style="text-align:center">小</td><td style="text-align:center">快</td><td style="text-align:center">高</td><td style="text-align:center">难</td></tr></tbody></table></div><h4 id="Astar寻路算法"><a href="#Astar寻路算法" class="headerlink" title="Astar寻路算法"></a>Astar寻路算法</h4><h4 id="Jump-Point算法"><a href="#Jump-Point算法" class="headerlink" title="Jump Point算法"></a>Jump Point算法</h4><h1 id="Unreal的游戏AI实现介绍"><a href="#Unreal的游戏AI实现介绍" class="headerlink" title="Unreal的游戏AI实现介绍"></a>Unreal的游戏AI实现介绍</h1><h2 id="行为树"><a href="#行为树" class="headerlink" title="行为树"></a>行为树</h2><h2 id="Al-Perception"><a href="#Al-Perception" class="headerlink" title="Al Perception"></a>Al Perception</h2><h2 id="Environment-Query-System-EQs"><a href="#Environment-Query-System-EQs" class="headerlink" title="Environment Query System (EQs)"></a>Environment Query System (EQs)</h2>]]></content>
    
    
    <categories>
      
      <category>Unreal</category>
      
      <category>腾讯公开课</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08 网络同步</title>
    <link href="/2025/04/29/UE_TOC/08-%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/"/>
    <url>/2025/04/29/UE_TOC/08-%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><ul><li>通信流程：Socket是“打开―读/写一关闭”模式的实现，UDP模式服务器端没有Listen、<br>Accept，客户端没有Connect流程。</li></ul><h2 id="TCP-amp-UDP"><a href="#TCP-amp-UDP" class="headerlink" title="TCP&amp;UDP"></a>TCP&amp;UDP</h2><h2 id="P2P连接"><a href="#P2P连接" class="headerlink" title="P2P连接"></a>P2P连接</h2><ul><li>P2P又称点对点，是无中心服务器、依靠用户群（ peers）交换信息的互联网体系。对等网络的每个用户端既是一个节点，也有服务器的功能。</li></ul><h2 id="C-S架构"><a href="#C-S架构" class="headerlink" title="C/S架构"></a>C/S架构</h2><ul><li>C/s架构也称主从式架构，架构分为客户端和服务器，所有客户端只和服务器对连，客户端之间的通信必须通过服务器。软件开发简单，可控性好。但是服务器性能压力大。</li></ul><h1 id="数据同步基础"><a href="#数据同步基础" class="headerlink" title="数据同步基础"></a>数据同步基础</h1><h2 id="RPC（Remote-Procedure-Call）"><a href="#RPC（Remote-Procedure-Call）" class="headerlink" title="RPC（Remote Procedure Call）"></a>RPC（Remote Procedure Call）</h2><ul><li><p>RPC，即远程过程调用。本地调用远端提供的函数方法，因为不是一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p></li><li><p>RPC调用带来的问题</p><ul><li>在远程调用时，我们需要执行的函数体是在远程的机器上的。也就是执行是在另一个进程中。另一端是不知道函数指针和堆栈数据的。这就带来了几个新问题:<ul><li>Call ID映射</li><li>序列化和反序列化</li><li>网络传输 </li></ul></li></ul></li></ul><h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><ul><li><p>像函数ID映射一样，本地用到对象实例想要在另一端也能够直接使用，这样会大大简化上层业务逻辑开发，这就需要对象序列化。</p></li><li><p>对象序列化是将对象转换成一系列字节，这样对象就可以很容易地保存到持久存储中，或者通过通信链路传输。然后将字节流反序列化――转换为原始对象的副本。</p></li></ul><h2 id="属性同步"><a href="#属性同步" class="headerlink" title="属性同步"></a>属性同步</h2><ul><li>属性同步是对象序列化带来的额外福利，对象A的某个属性更改了，其他端的镜像A对象对应的属性也需要更改，这就是属性同步。属性同步一般是服务器更改，同步到其他所有客户端，主要是为了解决数据冲突和安全性考虑</li></ul><h2 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h2><ul><li>所谓同步，就是要多个客户端表现效果一致</li></ul><h3 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h3><ul><li>帧同步技术是早期RTS游戏常用的一种同步技术。帧同步只同步操作，其大部分游戏逻辑都在客户端上实现，服务器主要负责广播和验证操作，有着逻辑直观易实现、数据量少、可重播，一致性好等优点。</li></ul><h3 id="状态同步"><a href="#状态同步" class="headerlink" title="状态同步"></a>状态同步</h3><ul><li><p>状态同步同步的是游戏中的各种状态。</p></li><li><p>一般的流程是客户端上传操作到服务器，服务器收到后计算游戏行为的结果，然后以广播的方式下发游戏中各种状态，客户端收到状态后再根据状态显示内容。</p></li><li><p>状态同步其实是一种不严谨的同步。不同玩家屏幕上的表现的一致性并不是重要指标，只要每次操作的结果相同即可。所以状态同步对网络延迟的要求并不高。像玩RPG游戏，200-300ms的延迟也可以接受。但是在RTS游戏中，50ms的延迟也会很受伤。</p></li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">状态同步</th><th style="text-align:center">帧同步</th></tr></thead><tbody><tr><td style="text-align:center">客户端一致性</td><td style="text-align:center">最终一致，中间可能拉扯</td><td style="text-align:center">一直保持一致</td></tr><tr><td style="text-align:center">网络延迟要求</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">网络流量</td><td style="text-align:center">与物体数量成正比</td><td style="text-align:center">与操作数量成正比</td></tr><tr><td style="text-align:center">服务器任务</td><td style="text-align:center">接受输入、全局仿真、状态复制</td><td style="text-align:center">同步操作</td></tr><tr><td style="text-align:center">客户端任务</td><td style="text-align:center">局部游戏世界的展示</td><td style="text-align:center">全局仿真</td></tr><tr><td style="text-align:center">玩家断线或中途加入</td><td style="text-align:center">容易</td><td style="text-align:center">困难，如需从第一帧重新运算</td></tr><tr><td style="text-align:center">开发效率</td><td style="text-align:center">低，前后台联合开发</td><td style="text-align:center">高，接近于单机游戏</td></tr><tr><td style="text-align:center">安全性</td><td style="text-align:center">服务器逻辑安全性高，部分功能在客户端实现较容易作弊</td><td style="text-align:center">安全性低，但可事后验证</td></tr></tbody></table></div><h2 id="网络延迟和抖动"><a href="#网络延迟和抖动" class="headerlink" title="网络延迟和抖动"></a>网络延迟和抖动</h2><ul><li><p>网络延迟高或者抖动，会影响游戏体验，常见的表现有拉扯，瞬移，攻击敌方没有伤害等</p></li><li><p>对抗网络延迟的方法：</p><ul><li>平滑算法<ul><li>插值</li><li>预测</li><li>缓存</li></ul></li><li>延迟补偿</li></ul></li></ul><h1 id="UE网络同步"><a href="#UE网络同步" class="headerlink" title="UE网络同步"></a>UE网络同步</h1><h2 id="Unreal网络架构"><a href="#Unreal网络架构" class="headerlink" title="Unreal网络架构"></a>Unreal网络架构</h2><ul><li><p>以“客户端-服务器”模型为基础</p></li><li><p>实现面向对象式封装</p></li><li><p>实现网络代码和游戏逻辑完全分离</p></li><li><p>网络同步支持可视化编程</p></li><li><p>网络协议使用UDP通讯</p></li></ul><blockquote><p>Unreal为何使用纯UDP协议?</p><ul><li>TCP协议的可靠性无法定制<ul><li>所有数据都是可靠的（游戏中很多数据是可以丢失的)</li><li>为了保证数据的时序性，牺牲了时效性（一旦出现丢包，会阻塞后面数据的发送）</li></ul></li><li>TCP协议与UDP协议混合使用?<ul><li>对于时序性要求很高的数据，通过TCP协议传输</li><li>对于时效性要求很高的数据，通过UDP协议传输</li><li>增加了设计的复杂度</li><li>TCP与UDP都是基于IP协议，它们在底层会互相干扰</li></ul></li><li>纯UDP协议的好处<ul><li>可以自己定制丢包时的处理逻辑</li><li>可以同时兼顾时序性数据和时效性数据<h2 id="Unreal网络模式"><a href="#Unreal网络模式" class="headerlink" title="Unreal网络模式"></a>Unreal网络模式</h2></li></ul></li></ul></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">网络模式类型</th><th style="text-align:center">功能/理想用例</th></tr></thead><tbody><tr><td style="text-align:center">NM_Standalone</td><td style="text-align:center">此类型说明服务器在本地计算机上运行且不接受来自远程计算机的客户端。此类型最适合单人游戏或本地多人游戏。</td></tr><tr><td style="text-align:center">NM_DedicatedServer</td><td style="text-align:center">专属服务器没有本地玩家，可以通过丢弃声音、图形、用户输入和其他面向玩家的功能来更高效地运行。此类型服务器用于托管在受信任服务器上的多人游戏，如竞赛性MOBA游戏、MMO游戏或需要高性能可靠服务器的在线射击游戏。</td></tr><tr><td style="text-align:center">NM_ListenServer</td><td style="text-align:center">监听服务器是一个既托管本地玩家，同时也对来自远程玩家的连接开放的服务器。此类型服务器适合于不需要专属服务器，且用户可以在没有第三方服务器的情况下设置和玩自己的游戏的竞争或合作类游戏。由于主机没有网络延迟，此类型网络模式可能会给主机带来一些优势，并且可以在没有主机警告的情况下终止游戏。</td></tr><tr><td style="text-align:center">NM_Client</td><td style="text-align:center">这是唯一为非服务器的模式。在此模式下，本地计算机是专属或监听服务器的客户端，因此不会运行服务器端逻辑。</td></tr></tbody></table></div><h2 id="Actor的复制"><a href="#Actor的复制" class="headerlink" title="Actor的复制"></a>Actor的复制</h2><ul><li><p>Actor是UE网络同步核心。所有的数据同步都是围绕Actor展开的。服务器将保留一份Actor列表并定期更新客户端，以便客户端保留每个Actor（那些需要被同步的Actor）的近似复本。</p></li><li><p>Actor主要通过两种方式进行更新:</p><ul><li>Replicate属性更新</li><li>RPC（远程过程调用） </li></ul></li><li>可以在蓝图或者在通过C++代码设置Actor可以被复制。组件也可以进行类似的设置</li></ul><h2 id="属性复制的规则"><a href="#属性复制的规则" class="headerlink" title="属性复制的规则"></a>属性复制的规则</h2><ul><li><p>只支持从服务器复制到客户端，且都是Reliable的</p></li><li><p>在每帧更新完所有Actor的属性状态会执行一遍所有Actor的属性复制</p></li><li><p>只复制那些与上一帧对比发生过变化的属性</p></li><li><p>如果是第一次复制，则复制跟默认值对比不一致的属性</p></li><li><p>只支持复制静态数组，并且只复制数组中与上一帧对比发生过变化的那一项</p></li><li><p>支持复制结构体，结构体中任意属性与上一帧对比发生过变化，都会导致复制结构体的所有属性</p></li><li><p>属性复制支持回调事件</p></li></ul><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><ul><li>支持服务器和客户端双向复制</li><li>可以被标记为：Client、Server、 NetMulticast·可以是Reliable或者UnReliable的</li><li>函数复制是没有返回值的，也不支持输出型参数</li></ul><h3 id="RPC要求和注意事项"><a href="#RPC要求和注意事项" class="headerlink" title="RPC要求和注意事项"></a>RPC要求和注意事项</h3><ul><li>它们必须从Actor上调用。</li><li>如果RPC是从服务器调用并在客户端上执行，则只有实际拥有这个Actor的客户端才会执行函数。</li><li>如果RPC是从客户端调用并在服务器上执行，客户端就必须拥有调用RPC的Actor。</li><li>多播RPC则是个例外：<ul><li>如果它们是从服务器调用，服务器将在本地和所有已连接的客户端上执行它们。</li><li>如果它们是从客户端调用，则只在本地而非服务器上执行。</li><li>现在，我们有了一个简单的多播事件限制机制:在特定Actor的网络更新期内，多播函数将不会复制两次以上。按长期计划，我们会对此进行改善，同时更好的支持跨通道流量管理与限制。</li></ul></li></ul><h2 id="UE网络的实现"><a href="#UE网络的实现" class="headerlink" title="UE网络的实现"></a>UE网络的实现</h2><h3 id="NetDriver-——网络管理类"><a href="#NetDriver-——网络管理类" class="headerlink" title="NetDriver ——网络管理类"></a>NetDriver ——网络管理类</h3><ul><li>管理网络连接，驱动整个网络收发逻辑</li><li>创建和管理NetConnection</li><li>收发网络Packet</li><li>除了GameNetDriver，还有DemoNetDriver专门处理录像回放的逻辑</li></ul><h3 id="NetConnection-——抽象的网络连接-amp-Packet——数据包"><a href="#NetConnection-——抽象的网络连接-amp-Packet——数据包" class="headerlink" title="NetConnection ——抽象的网络连接  &amp; Packet——数据包"></a>NetConnection ——抽象的网络连接  &amp; Packet——数据包</h3><ul><li>客户端与服务器之间的连接</li><li>服务器会有多个NetConnection，每一个对应一个客户端连接</li><li>客户端会有一个ServerConnection</li><li>创建和管理Channel</li><li>每个通信包是一个Packet，每个Packet有一个唯一的Seq，Seq自增且不会重复利用</li><li>Packet 网络不稳定可能出现丢包，丢包时Connection不会重发，但会通知Channel</li></ul><h3 id="Channel——数据传输的管道"><a href="#Channel——数据传输的管道" class="headerlink" title="Channel——数据传输的管道"></a>Channel——数据传输的管道</h3><ul><li>每个NetConnection管理着自己的Channel集合</li><li>Channel以Bunch为单位进行数据的接收和发送</li><li>发送时，Channel将Bunch数据交给NetConnection以Packet发送</li><li>接收时，NetConnetion将Bunch分发给对应的Channel进行处理。</li><li>Channel有4种类型<ul><li>ActorChannel</li><li>ControlChannel</li><li>FileChannel</li><li>VoiceChannel</li></ul></li></ul><blockquote><p>ActorChannel</p><ul><li>实现数据传输的面向对象式的封装</li><li>每个ActorChannel绑定一个与玩家相关的Actor</li><li>每个ActorChannel只传输绑定的Actor所需要同步的数据</li></ul></blockquote><h3 id="Bunch——管道中传输的数据串"><a href="#Bunch——管道中传输的数据串" class="headerlink" title="Bunch——管道中传输的数据串"></a>Bunch——管道中传输的数据串</h3><ul><li><p>数据流通的基本单位</p></li><li><p>位流，充分利用了每一个Bit</p><ul><li>对于bool型的数据，使用一个Bit来存储</li><li>对于其他类型的数据，会根据数据的范围选择最节省的若干个Bit来存储</li></ul></li><li><p>Reliable(可靠) &amp; UnReliable（不可靠)</p><ul><li>Reliable Bunch，保证一定会发送到远端，并且按发送的顺序进行处理</li><li>UnReliable Bunch，网络丢包有可能导致Bunch不能发送到远端</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Unreal</category>
      
      <category>腾讯公开课</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07 渲染基础</title>
    <link href="/2025/04/29/UE_TOC/07-%E6%B8%B2%E6%9F%93%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/04/29/UE_TOC/07-%E6%B8%B2%E6%9F%93%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="渲染与管线"><a href="#渲染与管线" class="headerlink" title="渲染与管线"></a>渲染与管线</h1><p>渲染即通过计算机程序，由2D/3D模型生成具有真实感或非真实感的图像的过程</p><h2 id="渲染的实时性"><a href="#渲染的实时性" class="headerlink" title="渲染的实时性"></a>渲染的实时性</h2><p>渲染可以是实时的，也可以是离线的，二者开销不同</p><h2 id="实时渲染"><a href="#实时渲染" class="headerlink" title="实时渲染"></a>实时渲染</h2><p>应用程序通过调用操作系统提供的图像接口，调用显卡绘制图形，然后通过一系列的渲染管线，来绘制好显示在屏幕上的图像</p><h1 id="模型与坐标变换"><a href="#模型与坐标变换" class="headerlink" title="模型与坐标变换"></a>模型与坐标变换</h1><h2 id="网格模型"><a href="#网格模型" class="headerlink" title="网格模型"></a>网格模型</h2><p>网格模型是由若干顶点构成的一组多边形</p><ul><li><p>顶点位置基于同一个坐标系统</p></li><li><p>顶点按照一定顺序排列(索引组织)起来</p></li><li>有序的顶点组成若干平面(三角形)</li><li><p>每个顶点可以附带除位置外的其他信息</p><ul><li>法/切向量</li><li>顶点色<ul><li>uv<h2 id="level-of-Detail"><a href="#level-of-Detail" class="headerlink" title="level of Detail"></a>level of Detail</h2>准备好不同细节的模型，随着视距（或屏占比）的远近而切换<h2 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h2></li></ul></li></ul></li><li><p>模型坐标-&gt; 世界坐标-&gt; 相机坐标</p></li><li><p>相机（透视相机、正交相机）</p></li><li>投影变换</li><li>裁剪、视口变换<h2 id="光栅化与像素阶段"><a href="#光栅化与像素阶段" class="headerlink" title="光栅化与像素阶段"></a>光栅化与像素阶段</h2><h2 id="可编程的GPU渲染管线"><a href="#可编程的GPU渲染管线" class="headerlink" title="可编程的GPU渲染管线"></a>可编程的GPU渲染管线</h2>详细流程见《unity shader 入门精要》<h1 id="光照、材质与着色"><a href="#光照、材质与着色" class="headerlink" title="光照、材质与着色"></a>光照、材质与着色</h1><h2 id="光的特性"><a href="#光的特性" class="headerlink" title="光的特性"></a>光的特性</h2></li><li><p>真实世界中，光是一切物体色彩的来源</p></li><li><p>光有光源，有方向，有强度，有不同的频率分布（颜色)</p></li><li>光击中物体表面会发生反射/折射，不同材质的物体，反射/折射的形式和程度不同</li></ul><h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><ul><li><p>材质体现了物体在不同光照环境下的视觉表现</p></li><li><p>材质用于描述物体表面的特性：例如颜色（纹理)，光泽度，凹凸变化，透明度，自发光等等</p></li></ul><h2 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h2><ul><li>通过模拟光与物体材质之间的互动，计算出最终投射到屏幕像素上的光的色彩和强度的过程，称之为“着色”，这个过程的数学描述称之为“着色模型”<h2 id="基本光源类型及属性"><a href="#基本光源类型及属性" class="headerlink" title="基本光源类型及属性"></a>基本光源类型及属性</h2></li><li>类型：<ul><li>Directional Light </li><li>Spot Light </li><li>Point Light</li></ul></li><li>属性<ul><li>光强</li><li>光源颜色</li><li>光源动态开关</li><li>阴影投射开关<h2 id="移动性与光照烘焙"><a href="#移动性与光照烘焙" class="headerlink" title="移动性与光照烘焙"></a>移动性与光照烘焙</h2><h2 id="UE4的材质系统"><a href="#UE4的材质系统" class="headerlink" title="UE4的材质系统"></a>UE4的材质系统</h2></li></ul></li></ul><h1 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h1><ul><li><p>在场景元素绘制完成之后，对整帧画面进行的若干图像处理</p></li><li><p>一般使用Post Process Volume</p></li><li>也可以使用自定义的Post Process  Material</li></ul><h1 id="渲染调试"><a href="#渲染调试" class="headerlink" title="渲染调试"></a>渲染调试</h1><ul><li><p>借用ue引擎的可视化选项</p></li><li><p>常用的渲染性能统计命令</p><ul><li><p>stat unit</p></li><li><p>stat rhi</p></li><li>stat SceneRendering</li></ul></li><li>使用RenderDoc调试渲染过程</li></ul>]]></content>
    
    
    <categories>
      
      <category>Unreal</category>
      
      <category>腾讯公开课</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06 游戏物理</title>
    <link href="/2025/04/29/UE_TOC/06-%E6%B8%B8%E6%88%8F%E7%89%A9%E7%90%86/"/>
    <url>/2025/04/29/UE_TOC/06-%E6%B8%B8%E6%88%8F%E7%89%A9%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="游戏物理的基本概念"><a href="#游戏物理的基本概念" class="headerlink" title="游戏物理的基本概念"></a>游戏物理的基本概念</h1><blockquote><p><strong>物理引擎是现代商业引擎中一个非常重要模块</strong><br>物理引擎通过为刚性物体赋予真实的物理属性的方式来计算运动、旋转和碰撞反映实现包括布料，破碎，粒子等各种酷炫的物理效果</p></blockquote><h2 id="主流的物理引擎"><a href="#主流的物理引擎" class="headerlink" title="主流的物理引擎"></a>主流的物理引擎</h2><h3 id="PhysX"><a href="#PhysX" class="headerlink" title="PhysX"></a>PhysX</h3><ul><li>属于NVIDA，现已开源，是UE4和Unitl的主要内置物理引擎，使用它的游戏非常多</li></ul><h3 id="Havok"><a href="#Havok" class="headerlink" title="Havok"></a>Havok</h3><ul><li>老牌的商业引擎，代表作品包括：刺客信条，Doom Eternal，Monster Hunter World等</li></ul><h3 id="Chaos"><a href="#Chaos" class="headerlink" title="Chaos"></a>Chaos</h3><ul><li>Epic Games自研的新一代物理引擎，是UE5的唯一物理引擎</li></ul><p>特性包括布料，破坏，双精度等，目前仍处于测试阶段</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>Bullet Physics(开源)</li><li>Newton Dynamics(开源)</li></ul><p>以下如未特别说明，一般以Chaos和PhysX作为代表</p><h2 id="游戏物理世界的基本组成"><a href="#游戏物理世界的基本组成" class="headerlink" title="游戏物理世界的基本组成"></a>游戏物理世界的基本组成</h2><h3 id="Body和Shape"><a href="#Body和Shape" class="headerlink" title="Body和Shape:"></a>Body和Shape:</h3><ul><li><p>Body是游戏物理引擎的基本模拟对象，它包含着一些基本状态，例如位置，旋转，动量和角动量等等</p></li><li><p>Body本身没有碰撞功能，碰撞功能是由附着在其之上的Shape提供的，一个Body可同时拥有多个碰撞体，以逼近视觉体验</p></li></ul><h3 id="Simulated"><a href="#Simulated" class="headerlink" title="Simulated"></a>Simulated</h3><ul><li>拥有完全模拟特性的Body</li></ul><h3 id="Kinematic"><a href="#Kinematic" class="headerlink" title="Kinematic"></a>Kinematic</h3><ul><li>外部驱动的物理体，拥有无限质量，常用于游戏中一些按轨迹移动的机关，Kinematic之间没有碰撞</li></ul><h3 id="Constraint"><a href="#Constraint" class="headerlink" title="Constraint"></a>Constraint</h3><ul><li>这是一类抽象实体，用来描述Body自身和Body之间的运动限制，一般最常见的是Joint Constraint，它连接着两个Body，提供了6个自由度〔3轴平移和3轴旋转)的限制功能</li></ul><p>物理引擎假设的是一个刚性的世界，就Body和Shape本身而言没有变形和塑形的功能，以下会用刚体一词来代称Body</p><h2 id="物理引擎中的各种shape"><a href="#物理引擎中的各种shape" class="headerlink" title="物理引擎中的各种shape"></a>物理引擎中的各种shape</h2><h3 id="解析类型-最常用，效率最高的碰撞类型"><a href="#解析类型-最常用，效率最高的碰撞类型" class="headerlink" title="解析类型(最常用，效率最高的碰撞类型)"></a>解析类型(最常用，效率最高的碰撞类型)</h3><ul><li>Sphere</li><li>Capsule</li><li>Box</li><li>Plane<h3 id="Convex-Meshes"><a href="#Convex-Meshes" class="headerlink" title="Convex Meshes"></a>Convex Meshes</h3><ul><li>凸多边形，性能一般</li></ul></li></ul><h3 id="Triangle-Meshes"><a href="#Triangle-Meshes" class="headerlink" title="Triangle Meshes"></a>Triangle Meshes</h3><ul><li>任意多边形，性能较差</li></ul><h3 id="Height-Fields"><a href="#Height-Fields" class="headerlink" title="Height Fields"></a>Height Fields</h3><ul><li>高程，主要用于地形</li></ul><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>模拟相当于把物体的运动托管给物理系统，不需要任何的接口调用，通过simulate对场景进行模拟</p><p>物理引擎有自己额外的线程</p><h4 id="模拟的基本流程如下"><a href="#模拟的基本流程如下" class="headerlink" title="模拟的基本流程如下"></a>模拟的基本流程如下</h4><ul><li><p>Pre Physics</p><ul><li>模拟前准备，在这个阶段设置好参数</li></ul></li><li><p>During Physics</p><ul><li>碰撞粗检测，检测碰撞盒的交叉集， 若有，进行进一步检测</li></ul></li></ul><pre><code class="hljs">- 生成Collision Pair，生成Joint Pair， 生成其他Constraint Pair- 生成多个island Graph    - 将有碰撞和被Constraint连接在—起的刚体放到一个容器中，以降低计算复杂度- 不同island之间可以并行计算，得到结果    - integrate    - solve Constraints(Per island)        - Position        - Velocity        - Projection    - 常见约束不同阶段的用途        - 碰撞            - Position：分离姿态            - velocity：反弹和摩擦        - 关节            - Position：关节姿态            - velocity：临界限制的反弹            - Projection:后处理修饰</code></pre><ul><li><p>End Physics</p><ul><li>根据收集的模拟结果，回传状态</li></ul><h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2></li></ul><p>主要是场景进行相关的碰撞检测，返回查询结果，一般分为以下三种</p><ul><li><p>Raycast，射线检测</p></li><li><p>Sweep，给定一个直线轨迹，用几何Shape去测试</p></li><li><p>Overlap，给定一个Transform，用几何Shape去测试</p></li></ul><h1 id="虚幻引擎的物理应用"><a href="#虚幻引擎的物理应用" class="headerlink" title="虚幻引擎的物理应用"></a>虚幻引擎的物理应用</h1><h2 id="碰撞shape类型"><a href="#碰撞shape类型" class="headerlink" title="碰撞shape类型"></a>碰撞shape类型</h2><ul><li><p>Simple</p><ul><li><p>包括Box / Sphere / Capsule /Convex</p></li><li><p>支持完整的模拟特性</p></li><li><p>可用于检测</p></li></ul></li><li><p>Complex</p><ul><li><p>特指Triangle Mesh</p></li><li><p>可用于检测</p></li><li><p>在模拟时，仅支持Kinematic Body</p></li></ul></li><li><p>Simple和Complex可以共存于同一个模型资产和Body上，分别用于不同的用途</p></li></ul><h2 id="碰撞通道"><a href="#碰撞通道" class="headerlink" title="碰撞通道"></a>碰撞通道</h2><ul><li><p>在同一个物理世界中，经常需要将模拟对象相互隔离，所以要引入碰撞通道的<br>概念</p></li><li><p>Channel(也称为Object Type）和响应关系</p><ul><li><p>一个刚体拥有一个Channel和一张碰撞响应表</p></li><li><p>对于检测，API会给出反应Channel</p></li><li><p>对于碰撞，只有两个刚体的碰撞响应表对彼此的Channel都有响应，才会发生碰撞</p></li><li><p>可以在Project Settings中添加新的通道</p></li></ul></li><li><p>三种响应</p><ul><li><p>lgnore忽略（对检测和碰撞都没有反应)</p></li><li><p>Overlap重叠〔检测时不阻挡射线，模拟时无碰撞)</p></li><li><p>Block阻挡〔检测时会阻挡射线，模拟时有碰撞)</p></li></ul></li><li><p>碰撞预设（也称为Profile)</p><ul><li><p>代表─个刚体的Channel和碰撞响应表组合</p></li><li><p>UE默认提供了一组预设，也可以在Project Settings中添加新的预设</p></li><li><p>也可以在刚体上自定义</p></li></ul></li><li><p>注意: Profile和Channel往往拥有同一个名字，但它们不是一回事，不要混淆</p></li></ul><h2 id="物理材质"><a href="#物理材质" class="headerlink" title="物理材质"></a>物理材质</h2><ul><li><p>记录物理参数的资源格式，包含若干个物理相关的参数</p></li><li><p>可被链接在洁染材质上，方便管理</p></li><li><p>也可直接在蓝图和实例上费盖</p></li></ul><h2 id="Skeletal-Mesh-Physics"><a href="#Skeletal-Mesh-Physics" class="headerlink" title="Skeletal Mesh Physics"></a>Skeletal Mesh Physics</h2><ul><li><p>骨骼模型的顶点会参与蒙皮动画的计算，位置会随动画变化</p></li><li><p>采用基本几何体和凸包，配合约束作为骨骼模型的Physics Asset</p></li><li><p>理论上，可以添加Complex /Triangle Mesh作为碰撞体，但实践上很少这么做</p></li><li><p>除了角色的Ragdoll，Skeletal Mesh Physics还可以应用在其它场合，比如车辆</p></li></ul><h2 id="物理动画"><a href="#物理动画" class="headerlink" title="物理动画"></a>物理动画</h2><p>基于动画及真实物理模拟插值的动画系统，应用到骨骼模型上</p><ul><li><p>基本刚体+约束组成</p></li><li><p>骨骼动画更新获取骨骼矩阵</p></li><li><p>刚体基于当前数据，模拟之后获取物理数据</p></li><li><p>基于一定权重做动画与真实物理的融合，得出最终的骨骼位置</p></li></ul><h2 id="物理应用层优化"><a href="#物理应用层优化" class="headerlink" title="物理应用层优化"></a>物理应用层优化</h2><p>优化的基本原则</p><ul><li><p>降低物理场景的复杂度</p></li><li><p>挑选合适的模拟参数</p><ul><li><p>挑选合适的迭代次数</p></li><li><p>使用合理的帧率</p></li><li><p>使用最简单的约束设定以达到关节效果</p></li></ul></li><li><p>使用合适的查询方法</p><ul><li><p>降低碰撞盒查询得到的对象数量</p></li><li><p>降低物理查询本身的损耗</p></li><li><p>返回单一结果</p></li><li><p>使用异步方法进行批量查询</p></li></ul></li><li><p>使用“替代物理”</p><ul><li><p>根据应用场景定制规则</p></li><li><p>与主物理世界隔离</p></li><li><p>能进行针对性的优化</p></li></ul></li></ul><h1 id="未来发展"><a href="#未来发展" class="headerlink" title="未来发展"></a>未来发展</h1><ul><li><p>Tighter integration with gameplay</p></li><li><p>Deterministic Simulation</p></li><li><p>Big World</p></li><li><p>Deformable</p></li><li><p>GPU Acceleration</p></li><li><p>More data driven, more intelligence</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Unreal</category>
      
      <category>腾讯公开课</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05 骨骼动画</title>
    <link href="/2025/04/29/UE_TOC/05-%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/"/>
    <url>/2025/04/29/UE_TOC/05-%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="骨骼动画原理"><a href="#骨骼动画原理" class="headerlink" title="骨骼动画原理"></a>骨骼动画原理</h1><h2 id="序列帧动画"><a href="#序列帧动画" class="headerlink" title="序列帧动画"></a>序列帧动画</h2><p>2d游戏中的动画，实现方式是将一帧一帧的静态图片依序播放，也被称作精灵动画(sprite)。</p><h2 id="3D游戏动画"><a href="#3D游戏动画" class="headerlink" title="3D游戏动画"></a>3D游戏动画</h2><p>3d游戏中的动画，就是改变模型顶点的位置从而形成动画效果。</p><p>模型由大量顶点组成，如果每一帧都直接驱动顶点，造成数据量庞大，性能开销巨大。于是我们采用先驱动骨骼，进而带动顶点的方法：互相连接的骨骼组成骨架结构，通过改变骨骼的朝向和位置来生成动画</p><p>蒙皮：将Mesh的顶点附着（绑定）在骨骼上，并且每个顶点可以被多个骨骼控制</p><h2 id="基础资产类型"><a href="#基础资产类型" class="headerlink" title="基础资产类型"></a>基础资产类型</h2><ul><li><p>SkeletalMesh：骨骼网格体，主要的渲染资源</p></li><li><p>Skeleton：骨架，定义了骨骼的层级结构</p><ul><li>在UE4中，骨架资源将关联动画数据，骨架资源将把骨骼（关节）数据关联到动画轨迹，从而驱动动画。</li></ul></li><li><p>PhysicsAsset：物理资产，关联各骨骼和物理世界的交互</p></li></ul><h1 id="UE4动画蓝图"><a href="#UE4动画蓝图" class="headerlink" title="UE4动画蓝图"></a>UE4动画蓝图</h1><h2 id="动画蓝图"><a href="#动画蓝图" class="headerlink" title="动画蓝图"></a>动画蓝图</h2><ul><li>Event Graph<ul><li>与普通蓝图的Event Graph类似，可以在BeginPlay、Tick中添加逻辑</li></ul></li><li>Anim Graph<ul><li>用于逐帧生成动画Pose，可以进行AnimSequence的采样、混合、骨骼变形等操作，最终产生想要的Pose</li></ul></li></ul><h1 id="常用动画资产"><a href="#常用动画资产" class="headerlink" title="常用动画资产"></a>常用动画资产</h1><h2 id="Animation-Sequence"><a href="#Animation-Sequence" class="headerlink" title="Animation Sequence"></a>Animation Sequence</h2><p>是由一系列关键帧组成的动画序列，也是最基本的动画类型，当动画执行到某个时间点时会由相邻两个关键帧融合出当前Pose</p><p><strong>AnimAdditive</strong></p><ul><li><p>输出的Pose为此动画当前帧的Pose与设置的BasePose的差</p></li><li><p>AdditvieAnimType决定了此结果的Pose中骨骼变换的数据属于哪个空间</p></li></ul><p><strong>Local Space &amp; Mesh Space</strong></p><ul><li><p>Local Space下，Pose中保存的每个骨骼的变换数据为相对父骨骼的变换</p></li><li><p>Mesh Space下，Pose中保存的每个骨骼的变换数据为相对骨骼模型组建的变换</p></li></ul><h2 id="Blend-Space"><a href="#Blend-Space" class="headerlink" title="Blend Space"></a>Blend Space</h2><p>BlendSpaces提供了很便捷的多动画融合功能，通过传入参数值动态计算各个动画的权重输出融合后的结果，可以省去程序或者美术编写复杂的动画融合节点、</p><p>注意:由于Blend Spaces是由若干个Anim Sequences构成，所以当所有的Anim Sequences都为叠加动画时，即可输出叠加型Pose</p><h2 id="AimOffset"><a href="#AimOffset" class="headerlink" title="AimOffset"></a>AimOffset</h2><p>AimOffset是BlendSpace的一个子集，它其实就是一个在MeshSpace下具有叠加属性的BlendSpace。是引擎专门封装好用于做武器瞄准的动画类型（可能是为了降低上手难度，因为最基本的动画也要用到这个功能）。</p><h2 id="Montage"><a href="#Montage" class="headerlink" title="Montage"></a>Montage</h2><p>Montage是一种在编辑器中创建的动画资源（非导入)，它可以由若干个AnimSequence组成，通过其设置的Section和Slot，可以实现一些特殊的动画控制，包括动画的智能循环、基于逻辑的动画切换等等</p><ul><li><p>一个Montage可以设置若干个Slot，具体哪个slot生效，由运行时刻AnimGraph的情况决定</p></li><li><p>每个Slot中可以拖入若干个AnimSequence，顺序可以按需更改。如果AnimSequence为叠加型动画，则这个Montage也为叠加型Montage</p></li><li><p>Montage可以有若干个Section，Section把整个Montage拆分成若干块，这些块之间可以自由的衔接和跳转</p></li></ul><h1 id="常用动画节点"><a href="#常用动画节点" class="headerlink" title="常用动画节点"></a>常用动画节点</h1><h2 id="混合节点（Blend-Nodes"><a href="#混合节点（Blend-Nodes" class="headerlink" title="混合节点（Blend Nodes)"></a>混合节点（Blend Nodes)</h2><ul><li><p>ApplyAdditive：在LocalSpace下把一个动画叠加到另一个动画上</p></li><li><p>ApplyMeshSpaceAdditive：在MeshSpace下执行叠加</p></li><li><p>Blend：把两个Pose根据Alpha参数作为权重进行混合</p></li><li><p>BlendBoneByChannel：可以指定一根骨骼与另一根骨骼进行混合(不常用)</p></li><li><p>BlendMulti：同时对多个pose进行混合，与Blend同理</p></li><li><p>BlendPosesByBool和BendPosesBylnt类似代码中的switch case，根据参数选择用哪个Pose</p></li><li><p>LayeredBlendPerBone：BlendPose可以由指定某个骨骼开始对BasePose进行覆盖，覆盖时可以选择LocalSpace或MeshSpace</p></li></ul><p>. MakeDynamicAdditive：动态生成叠加型Pose，ApplyAdditive的反向操作，输出<br>为两个输入Pose的差</p><h2 id="空间转换-Convert-Spaces-Nodes"><a href="#空间转换-Convert-Spaces-Nodes" class="headerlink" title="空间转换(Convert Spaces Nodes)"></a>空间转换(Convert Spaces Nodes)</h2><p>空间转换会把输入的Pose中存储的每个骨骼的变换信息全部按新的空间进行重新计算，所以应该尽量减少这种节点的使用</p><h2 id="状态机-State-Machine）"><a href="#状态机-State-Machine）" class="headerlink" title="状态机(State Machine）"></a>状态机(State Machine）</h2><p>状态机提供了图形化的方法来控制动画的切换，比如姿势切换、武器、跳跃等等。状态之间可以设置转换条件以及转换的融合相关数据</p><p>注意:频繁的快速转换不适合设置太长的转换融合</p><h2 id="lnertialization惯性插值"><a href="#lnertialization惯性插值" class="headerlink" title="lnertialization惯性插值"></a>lnertialization惯性插值</h2><ul><li>StandBlend<ul><li>Evaluate both SourcePose and TargetPose</li></ul></li><li>lnertialization<ul><li>Evaluate only TargetPose</li></ul></li></ul><h2 id="IK-Inverse-Kinematics"><a href="#IK-Inverse-Kinematics" class="headerlink" title="IK(Inverse Kinematics)"></a>IK(Inverse Kinematics)</h2><ul><li><p><strong>Two Bone lK</strong></p><ul><li>Foot IK</li></ul></li><li><p><strong>FABRIK(Foward and Backward Reaching Incerse Kinematics)</strong></p></li></ul><h1 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h1><ul><li>Epic商城</li><li>adobe mixamo</li></ul><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><ul><li>虚幻引擎官方文档</li></ul>]]></content>
    
    
    <categories>
      
      <category>Unreal</category>
      
      <category>腾讯公开课</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04 UMG界面</title>
    <link href="/2025/04/29/UE_TOC/04-UMG%E7%95%8C%E9%9D%A2/"/>
    <url>/2025/04/29/UE_TOC/04-UMG%E7%95%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="UE4提供的界面开发系统"><a href="#UE4提供的界面开发系统" class="headerlink" title="UE4提供的界面开发系统"></a>UE4提供的界面开发系统</h2><ol><li><p><strong>HUD (Heads-Up Display)</strong>：</p><ul><li><p><strong>HUD</strong>是一个基本对象，用于在屏幕上覆盖显示元素。</p></li><li><p>它用于创建诸如生命值条、能量值、弹药计数、游戏得分等元素。</p></li><li><strong>HUD</strong> 是显示屏幕上覆盖的元素的基本对象。游戏中每个由人类控制的玩家 都有自己的 <code>AHUD</code> 类实例，这个实例会绘制到个人视口上。如果是分屏多人游戏， 多个视口会共享同一个屏幕，但每个HUD仍会绘制到其自己的视口上。</li></ul></li></ol><ol><li><p><strong>Slate</strong>：</p><ul><li><p><strong>Slate</strong>是虚幻引擎中的自定义用户界面系统的名称，是UE4附带的一个完全可定制的、平台无关的用户界面框架。</p></li><li><p><strong>Slate</strong>是虚幻中真正的UI框架，包含了输入处理，事件分发，绘制，渲染等核心功能</p></li><li><p>早期UE4编辑器界面本身就是使用Slate框架创建的，如今大部分也是用Slate创建的</p></li><li><p><strong>Slate</strong>编写布局界面非常麻烦</p></li></ul></li><li><p><strong>UMG (Unreal Motion Graphics UI Designer)</strong>：</p><ul><li><p><strong>UMG</strong>是虚幻4中基于Slate构建的界面编辑系统，是一个可视化UI创建工具，可用于创建UI元素，如游戏内的HUD、菜单或其他与界面相关的图形。</p></li><li><p>为什么用UMG？直接用Slate来“编写”界面布局非常麻烦，需要一个友好的界面编辑器。方便与蓝图进行交互，可在蓝图中控制界面。</p></li><li><p><strong>UMG</strong>是对<strong>Slate</strong>的封装，方便界面编辑以及支持虚幻的垃圾回收机制。<strong>Slate</strong>是底层真正的Ul实现。</p></li></ul></li></ol><h1 id="基本概念及常用控件"><a href="#基本概念及常用控件" class="headerlink" title="基本概念及常用控件"></a>基本概念及常用控件</h1><ul><li><p>控件Widget</p><ul><li>引擎预先封装好的，可以直接拿来使用的一个功能单元。比如: Image、Button</li></ul></li><li><p>UI蓝图</p><ul><li>编写蓝图代码，控制控件的显示隐藏，调整位置，响应事件等</li></ul></li><li><p>槽Slot</p><ul><li>面板控件中用于摆放子控件，包含了定义如何“摆放”的数据信息。如CanvasPanel的Slot说明了槽的位置、大小、堆叠次序等信息</li></ul></li><li><p>锚点Anchor</p><ul><li>主要用于CanvasPanel的Slot，描述了如何设置槽的位置、大小。直观来看就是子控件相对于父控件的位置关系。</li></ul></li></ul><h2 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h2><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>按钮是单子项、可点击的Primitive控件。它可实现基本交互。<br>你可将任何其他控件放入按钮控件中，以在UI中创建一个更复杂且有趣的可点击元素。</p><h3 id="复选框-Check-Box"><a href="#复选框-Check-Box" class="headerlink" title="复选框(Check Box)"></a>复选框(Check Box)</h3><p>借助复选框(Check Box)控件，你可以显示“未选中”、“选中”和“不确定”三种切换状态。你可以使用复选框(Check Box)控件来制作经典复选框、切换按钮或单选按钮。</p><h3 id="图像-lmage"><a href="#图像-lmage" class="headerlink" title="图像(lmage)"></a>图像(lmage)</h3><p>借助图像(Ilmage)控件，你可在UI中显示Slate笔刷、纹理、Sprite或材质。</p><h3 id="进度条-Progress-Bar"><a href="#进度条-Progress-Bar" class="headerlink" title="进度条(Progress Bar)"></a>进度条(Progress Bar)</h3><p>进度条(Progress Bar)控件是可以逐渐填充的简单条形，可以重新设计样式以适应各种用途，例如经验值、生命值、分数等。</p><h3 id="文本-Text"><a href="#文本-Text" class="headerlink" title="文本(Text)"></a>文本(Text)</h3><p>在屏幕上显示文本的基本方法，可以用于选项或其他UI元素的文本说明。</p><h3 id="文本框-Text-Box"><a href="#文本框-Text-Box" class="headerlink" title="文本框(Text Box)"></a>文本框(Text Box)</h3><p>允许用户输入自定义文本。仅允许输入单行文本。</p><h2 id="面板控件"><a href="#面板控件" class="headerlink" title="面板控件"></a>面板控件</h2><p>面板(Panel)类别中包含用于控制布局和放置其他控件的有用控件</p><h3 id="画布面板-Canvas-Panel"><a href="#画布面板-Canvas-Panel" class="headerlink" title="画布面板(Canvas Panel)"></a>画布面板(Canvas Panel)</h3><p>允许在任意位置布局、固定控件，并将这些控件与画布的具它子项按z序排序。</p><h3 id="网格面板-Grid-Panel"><a href="#网格面板-Grid-Panel" class="headerlink" title="网格面板(Grid Panel)"></a>网格面板(Grid Panel)</h3><p>在所有子控件之间平均分刮可用空间的面板</p><h3 id="水平框-Horizontal-Box"><a href="#水平框-Horizontal-Box" class="headerlink" title="水平框(Horizontal Box)"></a>水平框(Horizontal Box)</h3><p>用于将子控件水平排布成一行。</p><h3 id="纵向框-Vertical-Box"><a href="#纵向框-Vertical-Box" class="headerlink" title="纵向框( Vertical Box)"></a>纵向框( Vertical Box)</h3><p>用于自动纵向排布子控件。当需要将控件上下堆叠并使控件保持纵向对齐时，此空件很有用。</p><h3 id="滚动框-Scroll-Box"><a href="#滚动框-Scroll-Box" class="headerlink" title="滚动框(Scroll Box)"></a>滚动框(Scroll Box)</h3><p>一组可任意滚动的控件。当需要在一个列表中显示10-100个控件时非常有用。该控件不支持虚拟化</p><h3 id="控件切换器-widget-Switcher"><a href="#控件切换器-widget-Switcher" class="headerlink" title="控件切换器(widget Switcher)"></a>控件切换器(widget Switcher)</h3><p>控件切换器类似于选项卡控件，但没有选项卡，你可以自行创建并与此控件组合以获得类似于选项卡的效果。一次最多只显示一个控件</p><h2 id="优化控件"><a href="#优化控件" class="headerlink" title="优化控件"></a>优化控件</h2><h3 id="无效框-Invalidation-Box"><a href="#无效框-Invalidation-Box" class="headerlink" title="无效框( Invalidation Box)"></a>无效框( Invalidation Box)</h3><p>封装在失效框中的控件可以令子控件几何图形进行缓存，以加快平板的渲染速度。任何由无效框缓存的控件都不会进行预处理、绘图或上色。</p><h3 id="限位框-Retainer-Box"><a href="#限位框-Retainer-Box" class="headerlink" title="限位框(Retainer Box)"></a>限位框(Retainer Box)</h3><p>先将子控件渲染到渲染目标，然后再将该渲染目标渲染到屏幕。使用该选项，你可以控制频率和相位，以使UI的实际渲染频率低于主游戏渲染频率。它的附带好处是允许在绘制控件之后将材质应用给渲染目标，以应用简单的后期处理,</p><h1 id="让界面动起来"><a href="#让界面动起来" class="headerlink" title="让界面动起来"></a>让界面动起来</h1><blockquote><p><strong>如何在UMG中创建动画?</strong></p><p>控件蓝图编辑器的底部有两个窗口，可用来实施和控制UI控件的动画。第一个是动画窗口，可以创建用来驱动控件动画的基础动画轨。第二个是时间轴窗口，用于指定动画如何随时间应用至控件。</p><ul><li>添加动画轨道</li><li>添加动画关键帧</li></ul></blockquote><h1 id="扩展控件库"><a href="#扩展控件库" class="headerlink" title="扩展控件库"></a>扩展控件库</h1><p>自定义控件，避免重复造轮子</p><ul><li>纯UMG实现</li><li>C++实现</li></ul><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><ul><li>不用或少用属性绑定</li><li>尽量不在UI蓝图中实现Tick</li><li>复杂蓝图逻辑转C++，然后在蓝图中调用C++实现的函数</li><li>正确设置“隐藏”(Hidden &lt;==&gt; Collapsed)</li><li>无效框:<ul><li>无效框可以缓存UI绘制的中间数据，减少绘制的CPU消耗</li></ul></li><li>合理结构提升渲染性能:</li><li>减少UI层级，从而减少UI绘制过程的递归调用</li><li>合理规划UI层次，合并图集，批量渲染以减少DrawCall</li></ul>]]></content>
    
    
    <categories>
      
      <category>Unreal</category>
      
      <category>腾讯公开课</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03 C++代码规范</title>
    <link href="/2025/04/29/UE_TOC/03-C++%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <url>/2025/04/29/UE_TOC/03-C++%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h1 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h1><blockquote><p>一系列该语言编写的指导方针</p><p>覆盖缩进、注释、命名、空格使用、换行等等方面</p><p>由团队/组织/公司制定</p></blockquote><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ul><li>清晰、明确、避免过度缩写</li><li>变量名：大驼峰式(CamelCase)，bool类型须加b前缀</li><li>类型名：前缀+大驼峰式</li><li>引用传入可能修改的函数变量：加Qut前缀</li></ul><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><ul><li>大括号换行</li><li>if-else对齐</li><li>使用Tab缩进</li><li>switch-case语句中，必须要有default，如果fall-through，必须有明确注释</li></ul><p>熟悉代码规范，理解规范设立的原因<br>使用辅助工具，标注出不符合规范的代码·Cpplint, Resharper C++等</p><h1 id="游戏中的3D数学"><a href="#游戏中的3D数学" class="headerlink" title="游戏中的3D数学"></a>游戏中的3D数学</h1><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><ul><li>定义</li><li>点积</li><li>叉积</li><li>基地及坐标<h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2></li><li>线性变换</li><li>旋转变换<ul><li>欧拉角</li><li>四元数</li></ul></li><li>齐次坐标</li></ul>]]></content>
    
    
    <categories>
      
      <category>Unreal</category>
      
      <category>腾讯公开课</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02 游戏模式</title>
    <link href="/2025/04/29/UE_TOC/02-%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%BC%8F/"/>
    <url>/2025/04/29/UE_TOC/02-%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="UE4GamePlay关键元素"><a href="#UE4GamePlay关键元素" class="headerlink" title="UE4GamePlay关键元素"></a>UE4GamePlay关键元素</h1><h2 id="游戏世界的规则与状态保持"><a href="#游戏世界的规则与状态保持" class="headerlink" title="游戏世界的规则与状态保持"></a>游戏世界的规则与状态保持</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><ul><li><p>利用<strong>GameMode</strong>制定和检测胜利规则，并支配世界内的“元素”</p></li><li><p>通过<strong>GameState</strong>记录游戏世界的关键状态</p></li><li><p>使用<strong>PlayerState</strong>保存玩家的状态。</p></li><li><p>通过<strong>GameState</strong>和<strong>PlayerState</strong>来持久化游戏世界的数据，为对局恢复（断线重连，观战）进行，为世界的重建提供支持。”</p></li></ul><table >  <tr align="center">  <th colspan="1"> 游戏模式</th>     <td>"游戏"的概念分为两类。Game Mode和Game State是游戏的定义，包括游戏规则和获胜条件等内容。它仅存在于服务器上。它通常不应有太多在游戏过程中会发生变化的数据，也绝对不应有客户端需要了解的临时数据。</td> </tr>  <tr align="center">  <th rowspan="1"> 游戏状态</th>     <td>GameState包含游戏的状态，其中可以包括联网玩家列表、得分、棋类游戏中棋子的位置，或者在开放世界场景中完成的任务列表。游戏状态存在于服务器和所有客户端上，可以自由复制以保持所有机器处于最新状态。。</td> </tr><tr align="center">  <th colspan="1"> 玩家状态</th> <td>玩家状态是游戏玩家的状态，例受人类玩家或模拟玩家的机器人。作为游戏的一部分而存在的非玩家AI将不会拥有玩家状态。在玩家状态中适当的示例数据包括玩家姓名或得分、比赛中MOBA等的等级，或玩家当前是否在CTF游戏中携带旗帜。所有玩家的玩家状态存在于所有机器上(与玩家控制器不同)，并且可以自由复制以保持同步。</td> </table><h3 id="GameMode"><a href="#GameMode" class="headerlink" title="GameMode"></a>GameMode</h3><h4 id="GameMode-制定的规则"><a href="#GameMode-制定的规则" class="headerlink" title="GameMode 制定的规则"></a>GameMode 制定的规则</h4><ul><li>玩家和观众数量，以及允许的玩家和观众最大数量。</li><li>“玩家进入游戏的方式”，可包含选择生成地点和其他生成/重生成行为的规则。</li><li>基于规则的事件在游戏中发生，需要进行追踪并和所有玩家共享时，信息将通过GameState进行存储和同步。这些信息包括且不限于︰<ol><li>游戏已运行的时间（包括本地玩家加入前的运行时间）。</li><li>每个个体玩家加入游戏的时间和玩家的当前状态。</li><li>游戏是否已开始。</li></ol></li></ul><h4 id="GameMode中的关键方法"><a href="#GameMode中的关键方法" class="headerlink" title="GameMode中的关键方法"></a>GameMode中的关键方法</h4><ul><li>lnitGame<ul><li>在所有Actor激活之前调用（执行PrelnitializeComponents之前）Beginplay。</li></ul></li><li>PreLogin<ul><li>接受或拒绝尝试加入服务器的玩家。如它将ErrorMessage 设为一个非空字符串，会导致Login 函数失败。</li></ul></li><li>PostLogin<ul><li>成功登录后调用。这是首个在PlayerController上安全调用复制函数之处。OnPostLogin 暴露给了蓝图中，用于方便添加额外的逻辑。</li></ul></li><li>HandleStartingNewPlayer<ul><li>在PostLogin后或无缝游历后调用，可在蓝图中覆盖，修改新玩家身上发生的事件。它将默认创建一个玩家pawn</li></ul></li><li>RestartPlayer<ul><li>调用开始生成一个玩家pawn。如需要指定Pawn 生成的地点，还可使用<br>RestartPlayerAtPlayerStart和 RestartPlayerAtTransform 函数。OnRestartPlayer 可在蓝图中实现，在此函数完成后添加逻辑。</li></ul></li><li>SpawnDefaultPawnAtTransform<ul><li>这实际生成玩家Pawn，可在蓝图中覆盖。</li></ul></li><li>Logout<ul><li>玩家离开游戏或被摧毁时调用。可实现OnLogout执行蓝图逻辑。(断线重连）</li></ul></li></ul><h3 id="预置的基础GameMode"><a href="#预置的基础GameMode" class="headerlink" title="预置的基础GameMode"></a>预置的基础GameMode</h3><p>特定的基础（如进行游戏所需要的玩家数量，或玩家加入游戏的方法）在多种类型的游戏中具有共通性。可根据开发的特定游戏进行无穷无尽的规则变化。无论规则如何，GarModes 的任务都是定义和实现规则。Game Modes当前常用的基类有两个。</p><ul><li>AGameModeBase，这是所有Game Mode 的基类，是经典的AGameMode简化版本。简洁高效，是默认的游戏模式。</li><li>AGameMode是AGameModeBase的子类。AGameMode更适用于标准游戏类型<br>（如多人射击游戏），以比赛状态概念作为实现。<h3 id="AGameMode解析"><a href="#AGameMode解析" class="headerlink" title="AGameMode解析"></a>AGameMode解析</h3>AGameMode 包含一个跟踪比赛状态或整体游戏流程的状态机。可使用GetMatchState 或 HasMatchStarted、IsMatchInProgress和HasMatchEnded之类的封装器查询当前的状态。</li></ul><h3 id="设置Game-Mode"><a href="#设置Game-Mode" class="headerlink" title="设置Game Mode"></a>设置Game Mode</h3><h4 id="URL-作为启动参数，指定GameMode"><a href="#URL-作为启动参数，指定GameMode" class="headerlink" title="URL 作为启动参数，指定GameMode"></a>URL 作为启动参数，指定GameMode</h4><ul><li>UE4Editor.exe /Game/Maps/MyMap?game=MyGameMode -game<h4 id="配置默认的GameMode"><a href="#配置默认的GameMode" class="headerlink" title="配置默认的GameMode"></a>配置默认的GameMode</h4></li><li>可在DefaultEngine.ini文件的/Script/Engine.WorldSettings/部分中设置地图前缀(和URL法的别名)。</li><li>这些前缀设置所有拥有特定前缀的地图的默认游戏模式。</li></ul><blockquote><p>[/Script/EngineSettings.GameMapsSettings]<br>+GameModeMapPrefixes=&gt;&gt;(Name=”DM”,GameMode=”/Script/MyGameMode.MyGameMode”)+GameModeClassAliases=(Name=”DM”,GameMode=”/Script/MyGameMode.MyGameMode”)</p></blockquote><h3 id="GameState"><a href="#GameState" class="headerlink" title="GameState"></a>GameState</h3><blockquote><p>包含要复制到游戏中的每个客户端的信息，简而言之，它表示每个联网玩家的”游戏状态。</p><p>它通常包含有关游戏分数、比赛是否已开始和基于世界场景玩家人数要生成的AI数量的信息，以及其他特定于游戏的信息。</p><p>对于多人游戏，每个玩家的机器上都有一个游戏状态实例，而服务器的实例为权威实例。</p><ul><li>GetServerWorldTimeSeconds<ul><li>GetTimeSeconds 的服务器版本，保持客户端和服务器上时间的同步。</li></ul></li><li>PlayerArray<ul><li>存储了所有玩家的APlayerState，方便遍历和获取玩家数据信息。</li></ul></li><li>HasBegunPlay<ul><li>游戏世界中的Actor已执行Beginplay，则返回true。</li></ul></li></ul></blockquote><h3 id="PlayerState"><a href="#PlayerState" class="headerlink" title="PlayerState"></a>PlayerState</h3><ul><li><p>游戏玩家的状态，例如人类玩家或模拟玩家的机器人。作为游戏世界场景的一部分而存在的非玩家Al将不会拥有玩家状态。</p></li><li><p>在玩家状态中适当的示例数据包括玩家姓名或得分、当前等级或生命值。</p></li><li><p>对于多人游戏，所有玩家的玩家状态存在于所有机器上（与玩家控制器不同），并且可以将数据从服务器复制到客户端以保持同步。</p></li></ul><h2 id="游戏世界中的“生命体”"><a href="#游戏世界中的“生命体”" class="headerlink" title="游戏世界中的“生命体”"></a>游戏世界中的“生命体”</h2><h2 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h2><p>存在于游戏世界中最基础最简化的“生命体”。</p><h2 id="Pawn"><a href="#Pawn" class="headerlink" title="Pawn"></a>Pawn</h2><p>可被Controller Possess，且可将其设置接受输入，用于执行各种各样类似于玩家的任务。请注意，Pawn不被认定为具有人的特性。</p><h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><p>角色是类人式的Pawn。默认情况下，它带有一个用于碰撞的胶囊组件和一个角色移动组件。它可以执行类似人类的基本动作，可以流畅地复制网络上的动作，还具有一些与动画相关的功能。</p><h2 id="其他必不可少的元素"><a href="#其他必不可少的元素" class="headerlink" title="其他必不可少的元素"></a>其他必不可少的元素</h2><h2 id="Movement"><a href="#Movement" class="headerlink" title="Movement"></a>Movement</h2><h2 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h2><p>玩家摄像机管理器是玩家的”眼球””，负责管理它的行为。通常情况下，每个玩家控制器也有一个此类型的摄像机。请参见摄像机工作流程页面，了解更多信息</p><h2 id="HUD"><a href="#HUD" class="headerlink" title="HUD"></a>HUD</h2><p>HUD是指”抬头显视”或二维屏幕显示，在许多游戏中较为常用。例如显示血条、弹药指示器、枪准星等。每个玩家控制器通常都配有其中一种显示</p><h1 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h1><h2 id="网络角色NetRole"><a href="#网络角色NetRole" class="headerlink" title="网络角色NetRole"></a>网络角色NetRole</h2><ul><li>authority</li><li>autonomous</li><li>simulate<h2 id="值复制-server"><a href="#值复制-server" class="headerlink" title="值复制(server)"></a>值复制(server)</h2></li><li>相关性的概念（相关时同步actor+最新状态）</li><li>Actor状态的保持（ActorChannel）</li><li>Server—&gt;Client（可靠的，及时的）<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2>RPC(server client) valid(damage10000 : 100, return false)</li><li>两种设置<ul><li>Reliable (pitfall)</li><li>Unreliable(server→client,udp)。</li></ul></li><li>类型<ul><li>Multicast</li><li>Run on Server client—&gt;server</li><li>Run on OwningClient：角色+背包（发光） server -&gt; client specific show</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Unreal</category>
      
      <category>腾讯公开课</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01 UE入门</title>
    <link href="/2025/04/29/UE_TOC/01-UE%E5%85%A5%E9%97%A8/"/>
    <url>/2025/04/29/UE_TOC/01-UE%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><blockquote><p>课程内容：</p><ul><li>UE学习途径和方法的介绍</li><li>UE编辑器使用和编程技巧</li><li>UE引擎工具了解</li></ul><p>课程目标</p><ul><li>熟悉UE引擎的编辑器操作，了解UE引擎的游戏模式框架</li><li>能够独立获取和编译UE源码</li><li>能够在UE引擎中实现蓝图编程和C++编程</li><li>能够使用UE引擎构建Andorid平台游戏安装包</li></ul><p>本节课程作业：</p><ul><li>源码编译UE4/5，新建一个C++工程，进行简单场景编辑和工程设置</li><li>编译并构建安装包，确保能够用来将游戏工程安装到手机正常运行（若无Andorid手机可构建桌面版本）</li></ul></blockquote><h1 id="游戏团队的典型结构"><a href="#游戏团队的典型结构" class="headerlink" title="游戏团队的典型结构"></a>游戏团队的典型结构</h1><pre><code class=" mermaid">graph LR游戏团队 --&gt; 程序游戏团队 --&gt; 美术游戏团队 --&gt; 策划程序 --&gt; 前台程序 --&gt; 后台前台 --&gt; 游戏性-周边系统-工具-性能分析-引擎后台 --&gt; 游戏性-周边系统-工具-性能分析-引擎美术 --&gt; 原画-建模-地编-动画-特效策划 --&gt; 数值-关卡-系统-剧情-战斗</code></pre><h1 id="游戏引擎介绍"><a href="#游戏引擎介绍" class="headerlink" title="游戏引擎介绍"></a>游戏引擎介绍</h1><h2 id="Unreal"><a href="#Unreal" class="headerlink" title="Unreal"></a>Unreal</h2><pre><code class=" mermaid">graph LR优势 --&gt; 渲染品质优势 --&gt; C++与蓝图优势 --&gt; 开发周期优势 --&gt; 跨平台优势 --&gt; 开源渲染品质 --&gt; 电影级别PBR渲染渲染品质 --&gt; 先进的着色模型C++与蓝图 --&gt; 性能与可视化编程并重开发周期 --&gt; 基于射击类的GamePlay框架跨平台 --&gt;  移动-主机-PC-VR开源 --&gt; 有利于技术提升和定制化改造 </code></pre><h2 id="商业引擎"><a href="#商业引擎" class="headerlink" title="商业引擎"></a>商业引擎</h2><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">所属</th><th style="text-align:center">是否开源</th><th style="text-align:center">知名作品</th></tr></thead><tbody><tr><td style="text-align:center">Unity</td><td style="text-align:center">Unity Technologies</td><td style="text-align:center">闭源，商业引擎</td><td style="text-align:center">大部分手游，独立游戏</td></tr><tr><td style="text-align:center">Cry Engine</td><td style="text-align:center">Crytek</td><td style="text-align:center">开源，商业引擎</td><td style="text-align:center">孤岛惊魂，孤岛危机</td></tr><tr><td style="text-align:center">Source2</td><td style="text-align:center">Valve</td><td style="text-align:center">未开源，商业引擎</td><td style="text-align:center">Half-Life: Alyx，CS2，Dota2</td></tr><tr><td style="text-align:center">EA</td><td style="text-align:center">Frostbit Engine</td><td style="text-align:center">内部引擎</td><td style="text-align:center">战地系列</td></tr><tr><td style="text-align:center">顽皮狗</td><td style="text-align:center">Naughty Dog Game Engine</td><td style="text-align:center">内部引擎</td><td style="text-align:center">神海系列，美末系列</td></tr><tr><td style="text-align:center">R星</td><td style="text-align:center">RAGE</td><td style="text-align:center">内部引擎</td><td style="text-align:center">GTA系列，荒野大镖客系列</td></tr><tr><td style="text-align:center">育碧</td><td style="text-align:center">AnvilNext2</td><td style="text-align:center">内部引擎</td><td style="text-align:center">刺客信条系列</td></tr><tr><td style="text-align:center">动视</td><td style="text-align:center">IW Engine（基于id Tech3）</td><td style="text-align:center">内部引擎</td><td style="text-align:center">使命召唤系列</td></tr></tbody></table></div><h2 id="游戏引擎架构"><a href="#游戏引擎架构" class="headerlink" title="游戏引擎架构"></a>游戏引擎架构</h2><blockquote><p><strong>推书</strong>：Game Engine Architecture</p><table>  <tr align="center">  <td colspan=2,>游戏子系统</td>  <td rowspan=2>世界编辑器</td>  </tr>  <tr >  <td align="center">动画</td>  <td>游戏基础系统</td>  </tr>  <tr align="center">  <td>渲染引擎</td> <td>物理引擎</td>  <td rowspan=2>工具</td> </tr>  <tr align="center">  <td colspan=2>资源管理</td>  </tr>  <tr align="center">  <td colspan="3"> 核心系统</td> </tr></tr>  <tr align="center">  <td colspan="3"> 平台独立层</td> </tr></tr>  <tr align="center">  <td colspan="3"> 第三方SDK</td> </tr></tr>  <tr align="center">  <td colspan="3"> OS</td> </tr></tr>  <tr align="center">  <td colspan="3"> 硬件</td> </tr></table></blockquote><p>关于<strong>世界编辑器</strong></p><ul><li><strong>世界编辑器</strong>通常是<strong>关卡编辑</strong>和<strong>地形编辑</strong>等</li><li>一般的游戏引擎都是世界编辑器和游戏引擎独立开来，编辑好后再导入游戏引擎，而<strong>UE</strong>可以在运行过程中修改世界编辑器</li></ul><h2 id="游戏引擎：渲染"><a href="#游戏引擎：渲染" class="headerlink" title="游戏引擎：渲染"></a>游戏引擎：渲染</h2><blockquote><p><strong>推荐</strong></p><ul><li>书：Real Time Rendering</li><li>课程：GAMES101 &amp; GAMES202</li></ul><hr><p><strong>渲染模式</strong></p><ul><li>Deferred Rendering（延迟渲染）<ul><li>编辑器、PC、Console默认渲染管线</li></ul></li><li>Forward+ Renderer<ul><li>用于桌面VR游戏，支持MSAA</li></ul></li><li>Mobile Renderer<ul><li>Forward Render</li><li>Deferred Render</li></ul></li></ul><hr><p><strong>游戏渲染模式</strong></p></blockquote><ul><li><p><strong>Immediate Mode Rendering（立即渲染模式）</strong>：正常处理，对能耗和带宽需求高，适用于PC游戏</p></li><li><p><strong>Tile Based Rendering</strong>：将屏幕划分为多个格子，一次只处理单个小块，有利于减小GPU的显存</p></li><li><p><strong>Tile Based Deferred Rendering</strong>：将渲染过程中看不见的东西提前去掉，减少运算量</p></li></ul><hr><blockquote><p><strong>正向渲染(Forward Rendering)</strong></p><p>我们知道，正向渲染(Forward Rendering)，或称正向着色(Forward Shading)，是渲染物体的一种非常直接的方式，在场景中我们根据所有光源照亮一个物体，之后再渲染下一个物体，以此类推。  </p><p>传统的正向渲染思路是，先进行着色，再进行深度测试。其的主要缺点就是光照计算跟场景复杂度和光源个数有很大关系。假设有n个物体，m个光源，且每个物体受所有光源的影响，那么复杂度就是O(m*n)。</p><p>正向渲染简单直接，也很容易实现，但是同时它对程序性能的影响也很大，因为对每一个需要渲染的物体，程序都要对每个光源下每一个需要渲染的片段进行迭代，如果旧的片段完全被一些新的片段覆盖，最终无需显示出来，那么其着色计算花费的时间就完全浪费掉了</p><p><strong>几何缓冲区（G-buffer）</strong></p><p>G-Buffer，全称Geometric Buffer ，译作几何缓冲区，它主要用于存储每个像素对应的位置（Position），法线（Normal），漫反射颜色（Diffuse Color）以及其他有用材质参数。</p><p>根据这些信息，就可以在像空间（二维空间）中对每个像素进行光照处理。</p><p><strong>Deferred Rendering（延迟渲染）</strong></p><p>可以将延迟渲染( Deferred Rendering)理解为先将所有物体都先绘制到屏幕空间的缓冲（即G-buffer，Geometric Buffer，几何缓冲区）中，再逐光源对该缓冲进行着色的过程，从而避免了因计算被深度测试丢弃的⽚元的着色而产⽣的不必要的开销。</p><p>也就是说延迟渲染基本思想是，先执行深度测试，再进行着色计算，将本来在物空 间（三维空间）进行光照计算放到了像空间（二维空间）进行处理。</p><p>对应于正向渲染O(m*n)的 复杂度，经典的延迟渲染复杂度为O(n+m)。</p><p><strong>移动渲染</strong></p><p>移动平台渲染器独立于桌面和控制台渲染器，具有自己的专门针对移动设备优化的功能子集。</p><p>移动渲染 | 虚幻引擎文档 (unrealengine.com)</p></blockquote><h2 id="游戏引擎：物理"><a href="#游戏引擎：物理" class="headerlink" title="游戏引擎：物理"></a>游戏引擎：物理</h2><p>物理引擎包含的内容：碰撞检测，动态约束，刚体物理，车辆物理，布娃娃系统等等</p><p>知名物理引擎：</p><ul><li>Havok：先后被英特尔和微软收购，CPU友好，闭源，塞尔达使用的就是Havok</li><li>PhysX：被Nvidia收购，GPU友好，集成于UE4和Unity</li><li>Bullet：最早开源，用于GTA5，荒野大镖客等</li></ul><p>UE如今开发了自己的物理引擎Chaos</p><h1 id="UE介绍"><a href="#UE介绍" class="headerlink" title="UE介绍"></a>UE介绍</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><ul><li>UE Evolution</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">版本</th><th style="text-align:center">年份</th><th style="text-align:center">作品</th><th style="text-align:center">类型</th></tr></thead><tbody><tr><td style="text-align:center">UE1</td><td style="text-align:center">1998</td><td style="text-align:center">Unreal</td><td style="text-align:center">FPS</td></tr><tr><td style="text-align:center">UE2</td><td style="text-align:center">2003</td><td style="text-align:center">UnrealTournament 2003</td><td style="text-align:center">FPS</td></tr><tr><td style="text-align:center">UE3</td><td style="text-align:center">2006</td><td style="text-align:center">Gears of War</td><td style="text-align:center">TPS</td></tr><tr><td style="text-align:center">UE4</td><td style="text-align:center">2014</td><td style="text-align:center">Fortnite</td><td style="text-align:center">TPS</td></tr><tr><td style="text-align:center">UE5</td><td style="text-align:center">2021</td><td style="text-align:center">Fortnite</td><td style="text-align:center">TPS</td></tr></tbody></table></div><ul><li>UE学习资料<ul><li>Youtube虚幻引擎官方账号</li><li>B站虚幻引擎官方账号</li><li>知乎虚幻引擎官方账号</li></ul></li></ul><h2 id="编辑器的使用"><a href="#编辑器的使用" class="headerlink" title="编辑器的使用"></a>编辑器的使用</h2><blockquote><ul><li>不仅是一个世界编辑器</li><li>管理整个游戏资产数据</li><li>提供统一、实时、所见即所得的资产数据库视图</li></ul></blockquote><h3 id="1-典型功能"><a href="#1-典型功能" class="headerlink" title="1.典型功能"></a>1.典型功能</h3><ul><li><p>地图关卡的创建和分层</p></li><li><p>可视化游戏世界</p></li><li><p>导航</p><ul><li>WSAD/QE + 鼠标右键：改变视角</li><li>F：将相机聚焦在所选的物体上</li><li>Bookmarks：保存和读取视角</li><li>G：取消线框</li></ul></li><li><p>选取</p><ul><li>ctrl+alt：框选区域中的全部物体 </li></ul></li><li><p>属性设置</p></li><li><p>安防与对齐辅助工具</p><ul><li>物体的旋转缩放，选中物体后按WER </li><li>对齐工具</li><li>贴地<ul><li>中心贴地：End</li><li>轴心贴地：Alt + End</li><li>碰撞盒贴地：Shift + End</li></ul></li></ul></li><li><p>快速迭代</p></li><li><p>Volume</p></li><li><p>光源</p></li></ul><h3 id="2-命名规范"><a href="#2-命名规范" class="headerlink" title="2.命名规范"></a>2.命名规范</h3><p><a href="https://github.com/Allar/ue5-style-guide">链接1</a><br><a href="https://github.com/skylens-inc/ue4-style-guide">链接2</a></p><h1 id="UE编程技巧"><a href="#UE编程技巧" class="headerlink" title="UE编程技巧"></a>UE编程技巧</h1><h2 id="游戏框架"><a href="#游戏框架" class="headerlink" title="游戏框架"></a>游戏框架</h2><pre><code class=" mermaid">graph LRPlayerController -- Join --&gt; GameGame --&gt; GameModeGame --&gt; GameStatePlayerController -- Possess --&gt; PawnAIController -- Possess --&gt; PawnPlayerController -- Contains --&gt; HUD,Input,PlayerCameraManager</code></pre><p>GameMode 游戏模式<br>游戏模式类负责设置正在执行的游戏的规则。<br>规则可包括玩家如何加入游戏，是否课暂停，关卡过度，以及任何特定的游戏行为</p><p>GameState游戏状态<br>游戏状态包含要复制到游戏中的每个客户端的信息，它表示整个游戏的“游戏状态”。通常包含有关游戏分数，比赛进程等等</p><h2 id="Blueprint与Lua"><a href="#Blueprint与Lua" class="headerlink" title="Blueprint与Lua"></a>Blueprint与Lua</h2><h3 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h3><p>蓝图是一类特殊的asset，可以使用直观、基于节点的方式创建逻辑，或者设置一些变量数据。</p><p>蓝图也可以选择继承C++类，获取C++中定义的变量，调用C++中定义的函数，或者实现C++中定义的event</p><p>缺点：</p><ul><li>容易形成蜘蛛网</li><li>二进制格式，Diff和MErge不方便</li></ul><p>使用原则：</p><ul><li>用于数值配置</li><li>用于简单的效果展示</li><li>用于特别简单的逻辑（代码不超过屏幕范围）</li></ul><h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3><p>Lua是目前最主流的游戏脚本语言，UE也支持Lua</p><p>使用Lua可以不用再次编译，便于游戏热更新</p><h2 id="C-In-UE"><a href="#C-In-UE" class="headerlink" title="C++ In UE"></a>C++ In UE</h2><p><strong>编程规范</strong></p><ul><li><p>T-模板类的前缀, i.e. TArray, TMap, TQueue</p></li><li><p>U- 继承自 UObject 的类前缀， i.e. UTexture</p></li><li><p>A-继承自AActor 的类前缀， i.e. AGameMode</p></li><li><p>F-structs及其他多数类均以F为前缀， i.e. FName, FVector</p></li><li><p>I- 抽象接口类前缀， i.e. ITransaction</p></li><li><p>E-枚举类型的前缀。，i.e. ESelectionMode</p></li><li><p>b-布尔变量必须以b为前缀，i.e. bEnabled</p><p>  <strong>UnrealHeaderTool需要正确的前缀才能正常编译</strong></p></li></ul><p><strong>基本类型</strong></p><ul><li><p>不使用C++原生的整型(char, short, int, long, etc.)</p></li><li><p>自定义ints &amp; strings in GenericPlatform.h (int32, uint32, uint64, TCHAR, ANSICHAR etc.)</p></li></ul><p><strong>容器</strong></p><ul><li><p>TArray, TSparseArray-Dynamic arrays</p></li><li><p>TLinkedList, TDoubleLinkedList</p></li><li><p>TMap-Key-value hash table</p></li><li><p>TQueue- Lock free FIFO</p></li><li><p>TSet-Unordered set (without duplicates)</p></li><li><p>And many more in Core module</p></li></ul><p><strong>智能指针</strong></p><ul><li><p>TSharedPtr, TSharedRef-for regular C++ objects</p></li><li><p>TWeakPtr-for regular C++ objects</p></li><li><p>TWeakObjPtr – for UObjects</p></li><li><p>TAutoPtr, TScopedPtr</p></li><li><p>TUniquePtr</p></li></ul><p><strong>其他常用结构体</strong></p><ul><li>FBox, FColor, FGuid, FVariant, FVector, TBigInt, TRange</li></ul><p><strong>UObject</strong></p><p><strong>UObjects增加了标准C++的很多功能</strong> </p><ul><li><p>Run-time reflection of class properties and functions</p></li><li><p>Serialization from/to disk and over the network </p></li><li><p>Garbage collection</p></li><li><p>Meta data</p></li><li><p>Also: Blueprint integration</p></li></ul><p><strong>Magic Macros</strong></p><ul><li><p>UCLASS - 类</p></li><li><p>USTRUCT- 结构体</p></li><li><p>UFUNCTION- 成员函数</p></li><li><p>UPROPERTY-成员变量 </p></li></ul><h1 id="引擎工具"><a href="#引擎工具" class="headerlink" title="引擎工具"></a>引擎工具</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ul><li><p>UE_LOG</p></li><li><p>可视化日志</p></li></ul><h2 id="内置控制台"><a href="#内置控制台" class="headerlink" title="内置控制台"></a>内置控制台</h2><p><strong>游戏运行时，～键用来打开控制台输入窗口（Mobile使用四指同时滑屏操作）</strong></p><ul><li><p>Stat FPS (显示帧数)</p><pre><code class="hljs">  t.MaxFPS 1000 (最高帧率限制到1000)</code></pre></li><li><p>Stat UNIT （对游戏线程，渲染线程，GPU耗时进行统计，分析瓶颈）</p></li><li><p>Stat GAME (对游戏各个模块的tick耗时进行统计)</p></li><li><p>Stat SceneRendering （渲染基本信息统计，可以看DrawCall数)</p></li><li><p>Stat Engine（渲染信息统计，可以看三角形数量）</p></li><li><p>Stat InitViews (可以看到视口剔除的三角形数量)</p></li><li><p>Stat RHI (可以看到所有的DrawCall)</p></li></ul><h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><ul><li><p>GPU Profile</p></li><li><p>RenderDoc </p></li><li><p>Unreal Insight</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Unreal</category>
      
      <category>腾讯公开课</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11 Animation</title>
    <link href="/2025/01/09/GAMES101/11%20Animation/"/>
    <url>/2025/01/09/GAMES101/11%20Animation/</url>
    
    <content type="html"><![CDATA[<h1 id="11-Animation"><a href="#11-Animation" class="headerlink" title="11 Animation"></a>11 Animation</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>动画可以视作是模型的扩展：将场景模型表示为关于时间的函数</p><p>输出：一系列图像，按顺序观看时产生动态的感觉</p><ul><li>电影：24fps</li><li>视频（一般）：30 fps</li><li>虚拟现实：90 fps</li></ul><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p><img src="/assets/GAMES101/image-20250429135715-g482c03.png" alt="">​</p><p><img src="/assets/GAMES101/image-20250429135656-ycmbdai.png" alt="">​</p><p>动画最早用作科学用途，随着技术的进步，加速了动画的发展</p><p><img src="/assets/GAMES101/image-20250429135751-u54pmvy.png" alt="">​</p><h2 id="关键帧动画"><a href="#关键帧动画" class="headerlink" title="关键帧动画"></a>关键帧动画</h2><p>给定一些关键的帧，其他中间的过渡部分则通过插值的方式生成出来</p><p><img src="/assets/GAMES101/image-20250429140224-khh7mvk.png" alt="">​</p><p>关键帧动画本质是一种插值的技术</p><ul><li>线性插值的效果通常不太好</li><li>会使用更平滑的方式进行插值</li></ul><h2 id="物理模拟"><a href="#物理模拟" class="headerlink" title="物理模拟"></a>物理模拟</h2><p>通过牛顿定律计算物体的后续位置与速度</p><p><img src="/assets/GAMES101/image-20250429140605-cxypysg.png" alt="">​</p><p>只要正确建立了物体之间的相互作用力，自然可以模拟正确的效果</p><h3 id="质点弹簧系统"><a href="#质点弹簧系统" class="headerlink" title="质点弹簧系统"></a>质点弹簧系统</h3><p>质点弹簧系统用于模拟物体形变和运动的物理模型。</p><p>它将物体离散为若干个质点，质点之间通过弹簧连接，通过计算质点之间的相互作用力来模拟物体的物理行为。</p><ul><li><strong>质点</strong> ：具有质量但忽略大小和形状的物体，是系统的基本组成单元。每个质点的位置、速度和加速度等状态变量都需要被跟踪和计算。</li><li><strong>弹簧</strong> ：连接两个质点的弹性元件，其力的计算通常遵循胡克定律，即弹簧力与弹簧的形变量成正比，方向与形变方向相反。公式为 F\=-k*(Δl)，其中 F 为弹簧力，k 为弹簧的劲度系数，Δl 为弹簧的伸长量或压缩量。</li><li><strong>运动方程</strong> ：根据牛顿第二定律，质点的加速度与所受合力成正比，与质点质量成反比。通过对质点所受的弹簧力以及其他外力（如重力、阻尼力等）进行求和，得到质点的加速度，进而积分得到质点的速度和位置。</li></ul><p>在计算机图形学中，可用于模拟布料、毛发、皮肤等柔性体的运动和形变；在物理模拟中，可用于研究物体的振动、碰撞等物理现象。</p><p>对于复杂的面，质点之间会进行额外的连接，以便更好的符合实际情况</p><p><img src="/assets/GAMES101/image-20250429180221-d2gwa5i.png" alt="">​</p><h3 id="有限元方法"><a href="#有限元方法" class="headerlink" title="有限元方法"></a>有限元方法</h3><p>除了质点弹簧系统之外，还有其他的模拟方法，例如有限元方法</p><p>有限元方法是一种用于求解物理问题和工程问题的数值计算方法。它将连续的物理域离散为有限个单元，通过在单元上建立近似方程，并利用变分原理或加权残值法等方法，将原问题转化为代数方程组进行求解。</p><h3 id="粒子系统"><a href="#粒子系统" class="headerlink" title="粒子系统"></a>粒子系统</h3><p>粒子系统用于模拟由大量微小粒子组成的复杂现象和效果。</p><p>每个粒子具有自己的属性，如位置、速度、颜色、大小等，通过对粒子的更新和绘制，可以生成各种逼真的动态效果。</p><p><strong>挑战：</strong></p><ul><li>可能需要大量例子</li><li>可能需要加速结构（例如，寻找相互作用的最近粒子）</li></ul><p><strong>更新：</strong> 粒子会在每一帧更新</p><ul><li>如有需要，创建粒子</li><li>计算每个粒子的作用力</li><li>更新每个粒子的位置和速度</li><li>如有需要，移除死亡粒子</li><li>渲染粒子</li></ul><p><strong>粒子系统的力：</strong></p><ul><li><p>吸引力和排斥力：</p><ul><li>引力、电磁力</li><li>弹力，推力</li></ul></li><li>阻尼力：摩擦力，空气阻力</li><li><p>碰撞：</p><ul><li>墙壁，容器，固定物件</li><li>动态物体，角色身体部位</li></ul></li></ul><h2 id="运动学"><a href="#运动学" class="headerlink" title="运动学"></a>运动学</h2><h3 id="正向运动学"><a href="#正向运动学" class="headerlink" title="正向运动学"></a>正向运动学</h3><p>正向运动学是从关节空间到操作空间的映射过程。</p><p>它主要研究机械臂（或类似的运动学结构）的各个关节角度（或位置）与末端执行器在空间中的位置和姿态之间的关系。</p><p>简单来说，当已知机械臂各个关节的参数（如旋转角度或伸缩长度）时，通过正向运动学可以计算出末端执行器在空间中的具体位置和姿态。</p><h3 id="逆向运动学"><a href="#逆向运动学" class="headerlink" title="逆向运动学"></a>逆向运动学</h3><p>逆向运动学是正向运动学的逆过程。</p><p>它的目标是确定机械臂的关节角度（或位置），使得末端执行器能够准确地到达指定的空间位置和姿态。</p><p>也就是说，已知末端执行器期望的位置和姿态，要求解出各个关节的参数，以实现该位置和姿态。</p><p>值得注意的是，对于给定的末端位置，可能存在多个解或不一定存在解满足条件</p><h3 id="Rigging"><a href="#Rigging" class="headerlink" title="Rigging"></a>Rigging</h3><p>Rigging是指为 3D 模型创建骨骼结构和控制系统，以便能够对模型进行动画制作的过程。</p><ul><li><strong>骨骼绑定</strong> ：将骨骼放置在模型内部，例如在人物模型中，将脊柱、四肢等骨骼放在相应的位置，以模拟人体骨骼的分布。</li><li><strong>蒙皮</strong> ：也称为权重分配。这是将模型的几何体与骨骼关联起来的过程。通过蒙皮，定义了模型的每个部分受哪些骨骼的控制以及控制的程度。例如，在手臂模型上，赋予手臂骨骼对皮肤的控制权重，使得当骨骼移动时，模型的皮肤也随之变形。</li><li><strong>动画控制</strong> ：创建各种控制器，如控制面板、滑块、旋钮等，方便动画师控制角色的动作。例如，一个旋转控制器可以用来控制手臂的弯曲角度。</li></ul><p>Rigging 是正向运动学和逆向运动学在角色动画中的具体应用。在 Rigging 过程中，会利用正向运动学来计算骨骼的运动关系，例如，当动画师调整手臂骨骼的旋转角度时，模型的手臂会按照正向运动学的原理进行相应的位置变化。</p><p>同时，也会使用逆向运动学来解决一些复杂的运动问题。比如，在角色行走时，脚部的位置和姿态是已知的，通过逆向运动学可以计算出腿部骨骼的运动角度，以实现自然的行走动作。</p><h2 id="动作捕捉"><a href="#动作捕捉" class="headerlink" title="动作捕捉"></a>动作捕捉</h2><h3 id="Motion-Capture"><a href="#Motion-Capture" class="headerlink" title="Motion Capture"></a>Motion Capture</h3><p>通过在物体（通常是演员的身体或物体表面）上放置标记点（Marker）或传感器，利用光学、惯性、电磁等技术捕捉这些标记点或传感器的位置和运动数据，然后将这些数据转换为数字信号，用于驱动虚拟角色或物体的运动。</p><h3 id="Facial-Motion-Capture"><a href="#Facial-Motion-Capture" class="headerlink" title="Facial Motion Capture"></a>Facial Motion Capture</h3><p>主要针对演员的面部表情和口型进行捕捉，通过特定的技术获取面部肌肉的运动、五官的变化等数据，将其转化为数字信号，用于驱动虚拟角色的面部表情和口型。</p><h2 id="单粒子模拟"><a href="#单粒子模拟" class="headerlink" title="单粒子模拟"></a>单粒子模拟</h2><p>已知某个物体在某个时刻的速度和位置，求解一段时间之后它的位置和速度。</p><p>很多情况下物体不是匀速运动，粒子在不同的位置具有的速度不一致。</p><p>假设存在一个速度场，对于一个粒子来说，只要知道它的位置，就能够知道它的速度。</p><h3 id="欧拉方法"><a href="#欧拉方法" class="headerlink" title="欧拉方法"></a>欧拉方法</h3><p>取一个很小的时间${\Delta}t$，可以认为，在这个时间里，物体是做匀加速直线运动</p><p>那么，可以通过逐步递进的方式，求解最终的物体位置</p><p>$x^{t + {\Delta}t} = x^t + v^t {\Delta}t  \\ v^{t + {\Delta}t} = v^t + a^t {\Delta}t  $  </p><p>通过上面的公式反复迭代，可以最终得到结果</p><p>缺陷：</p><ul><li>因为每一次的模拟都是近似，随着迭代次数的增加，<strong>误差</strong>会逐渐增大</li><li><strong>稳定性</strong>差，难以适用于曲线：在曲线上的误差会更大，更容易偏离曲线轨迹</li></ul><h3 id="中点法"><a href="#中点法" class="headerlink" title="中点法"></a>中点法</h3><p>中点法是一种改进方法，思路是算两次欧拉方法</p><p><img src="/assets/GAMES101/image-20250429211958-7dn3jwb.png" alt="">​</p><p>对于一次单独的迭代来说</p><ul><li>先算一次，得到路径a</li><li>取路径的中点b的速度</li><li>应用中点的速度重新算一次，得到路径c</li></ul><h3 id="自适应补偿"><a href="#自适应补偿" class="headerlink" title="自适应补偿"></a>自适应补偿</h3><p><img src="/assets/GAMES101/image-20250429212506-hb8uda5.png" alt="">​</p><p>自适应补偿的思路是：</p><ul><li>将步长减半，比较步长减半与不减半的差异</li><li>如果差异过大，则继续步长减半的做法，最终得到合适的自适应步长</li></ul><h3 id="隐式欧拉方法"><a href="#隐式欧拉方法" class="headerlink" title="隐式欧拉方法"></a>隐式欧拉方法</h3><p>原来的欧拉方法，是用上个时刻的速度，加速度来更新位置</p><p>而隐式欧拉方法，是用这个时刻的速度和加速度来更新从上一时刻到这一时刻的位置</p><p>$x^{t + {\Delta}t} = x^t + v^{t+{\Delta}t} {\Delta}t  \\ v^{t + {\Delta}t} = v^t + a^{t+{\Delta}t} {\Delta}t  $  </p><p>这种情况需要提前求解速度和加速度</p><h3 id="量化误差"><a href="#量化误差" class="headerlink" title="量化误差"></a>量化误差</h3><p>如何确定 / 量化 “稳定性”？</p><ul><li>我们使用局部截断误差（每一步） / 总累积误差（整体）</li><li>绝对值无关紧要，但相对于步长的阶（order）很重要</li><li><p>隐式欧拉方法具有一阶精度，这意味着：</p><ul><li>局部截断误差：$O(h^2)$</li><li>全局截断误差：$O(h)$（h 是步长，即 Δt）</li></ul></li><li><p>对 O(h) 的理解：</p><ul><li>如果我们将 h 减半，我们可以期望误差也会减半。</li></ul></li></ul><p>阶数越高越好</p><h3 id="Runge-Kutta-Families-——-RK4"><a href="#Runge-Kutta-Families-——-RK4" class="headerlink" title="Runge-Kutta Families —— RK4"></a>Runge-Kutta Families —— RK4</h3><p>这是一类用于求解常微分方程（ODEs）的先进方法。</p><ul><li>特别擅长处理非线性问题。</li><li>其四阶版本最为广泛使用，通常被称为 RK4。</li></ul><h3 id="Position-Based-Verlet-Intergration"><a href="#Position-Based-Verlet-Intergration" class="headerlink" title="Position-Based / Verlet Intergration"></a>Position-Based / Verlet Intergration</h3><p><strong>思想：</strong></p><ul><li>在修改后的欧拉前向步之后，约束粒子的位置，以防止发散和不稳定的行为。</li><li>使用约束后的位置来计算速度。</li><li>这两种方法都会耗散能量，从而增加稳定性。</li></ul><p><strong>优缺点：</strong></p><ul><li>快速且简单。</li><li>不基于物理原理，会耗散能量（存在误差）。</li></ul><h3 id="刚体模拟"><a href="#刚体模拟" class="headerlink" title="刚体模拟"></a>刚体模拟</h3><p>刚体不会发生形变，其运动等效于质点，</p><p>除了速度和位置之外，还存在角度和角速度</p><h2 id="流体模拟"><a href="#流体模拟" class="headerlink" title="流体模拟"></a>流体模拟</h2><h3 id="Position-Based"><a href="#Position-Based" class="headerlink" title="Position-Based"></a>Position-Based</h3><p>关键思想</p><ul><li>假设水由小的刚体球组成</li><li>假设水不可被压缩（即密度恒定）</li><li>因此，只要某处密度发生变化，就应该通过改变粒子位置来进行“修正”，这象征着水的流动</li></ul><p>任何一个点处的密度，都是任何一个其他的小球的位置的函数</p><p>使用<strong>梯度下降法</strong>来实现粒子位置更新</p><h3 id="欧拉方法与拉格朗日方法"><a href="#欧拉方法与拉格朗日方法" class="headerlink" title="欧拉方法与拉格朗日方法"></a>欧拉方法与拉格朗日方法</h3><p>拉格朗日方法（质点法）：假设物体是由多个小粒子组成</p><p><img src="/assets/GAMES101/image-20250429220504-qbk5bl0.png" alt="">​</p><p>欧拉方法（网格法）：将空间分割为网格，考虑网格随时间的变化情况</p><h3 id="物质点法"><a href="#物质点法" class="headerlink" title="物质点法"></a><strong>物质点法</strong></h3><p><strong>Material Point Method, MPM</strong></p><p>一种混合方法，结合了欧拉（Eulerian）和拉格朗日（Lagrangian）观点：</p><ul><li><strong>拉格朗日观点</strong>：考虑携带材料属性的粒子。</li><li><strong>欧拉观点</strong>：使用网格进行数值积分。</li><li><strong>交互过程</strong>：粒子将属性传递给网格，网格执行更新，然后通过插值将结果反馈回粒子。</li></ul><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
      <category>GAMES101</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10 Color and Perception</title>
    <link href="/2025/01/09/GAMES101/10%20Color%20and%20Perception/"/>
    <url>/2025/01/09/GAMES101/10%20Color%20and%20Perception/</url>
    
    <content type="html"><![CDATA[<h1 id="10-Color-and-Perception"><a href="#10-Color-and-Perception" class="headerlink" title="10 Color and Perception"></a>10 Color and Perception</h1><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>一般人眼看到的光都是混合光，由多种波长的光混合而来，可以从光谱看出其组成。</p><p>不同波长的光有不同的折射率。</p><p>光谱是一个很长的范围，可见光的光谱分布在波长400~700nm之间。</p><h3 id="谱功率密度"><a href="#谱功率密度" class="headerlink" title="谱功率密度"></a>谱功率密度</h3><p><strong>Spectral Power Distribution ，（SPD）</strong></p><p>通过SPD，可以描述不同光的分布。</p><p>SPD具有线性叠加的性质，；两种光混合后的SPD = 两种光的SPD之和。</p><p><img src="/assets/GAMES101/image-20250428230445-xlpqml0.png" alt="">​</p><h3 id="视网膜细胞"><a href="#视网膜细胞" class="headerlink" title="视网膜细胞"></a>视网膜细胞</h3><p>颜色是人眼的感知，与SPD并不等同。</p><p>人眼的组成结构如下：</p><p><img src="/assets/GAMES101/image-20250428230551-h81rh5a.png" alt="">​</p><p>视网膜上主要有<strong>视锥细胞</strong>和<strong>视杆细胞</strong></p><ul><li>视锥细胞感受光的颜色</li><li>视杆细胞主要感受光的强度</li></ul><p>视锥细胞分为 S ，M ，L 三类，分别对应于三种波长的感知。而不同人的视锥细胞分布也有很大不同。</p><p>也就是说，每个人看到的颜色并不完全一致。</p><h3 id="同色异谱"><a href="#同色异谱" class="headerlink" title="同色异谱"></a>同色异谱</h3><p><strong>Metamerism</strong></p><p>由于视网膜只看到了三种颜色，因此可能会出现，两种光线的光谱不同，但人眼看到的颜色却相同。</p><p>在这种机制的作用下，我们能够使用三种颜色进行混合来匹配其他颜色。</p><h3 id="颜色匹配"><a href="#颜色匹配" class="headerlink" title="颜色匹配"></a>颜色匹配</h3><p><strong>Color Reproduction / Matching</strong></p><p>RGB图形就是通过RGB三种通道混合来匹配可见的颜色</p><h2 id="颜色空间"><a href="#颜色空间" class="headerlink" title="颜色空间"></a>颜色空间</h2><p>色域：一个颜色空间所有可以表示的颜色。不同颜色空间的色域范围不一致。</p><p><img src="/assets/GAMES101/image-20250428233001-ims6e9d.png" alt="">​</p><h3 id="CIE-RGB-空间"><a href="#CIE-RGB-空间" class="headerlink" title="CIE RGB 空间"></a>CIE RGB 空间</h3><p><strong>CIE RGB</strong> ：是 CIE（国际照明委员会）1931 年定义的一种用于描述人眼所能感知的色彩范围的颜色空间标准。</p><p>它基于人眼的三色视觉理论，通过红、绿、蓝三种原色光的组合来表示色彩，主要用于颜色科学研究和颜色测量等领域，为颜色的定量描述和比较提供了一个标准框架。</p><p>它是一种加色混合模型，因为是通过不同强度的红、绿、蓝光相加来产生各种颜色。例如，当红、绿、蓝三色光强度都为最大值时，混合得到的是白色光；当三色光强度都为 0 时，得到黑色。</p><p>能够表示人眼可见光谱中的大部分颜色。通过不同比例的 RGB 三色组合，可以生成大量的色彩，涵盖了从红色（R \= 1，G \= 0，B \= 0）到绿色（R \= 0，G \= 1，B \= 0）再到蓝色（R \= 0，G \= 0，B \= 1）以及其他各种过渡颜色。</p><p>CIE规定了三种波长作为主光</p><p><img src="/assets/GAMES101/image-20250428232806-vlh0c7y.png" alt="">​</p><h3 id="HSV-空间"><a href="#HSV-空间" class="headerlink" title="HSV 空间"></a>HSV 空间</h3><p>HSV 是 Hue（色调）、Saturation（饱和度）、Value（亮度）的缩写。它也是一种颜色空间模型。</p><p>与 RGB 颜色空间不同，它更侧重于从人类对颜色的直观感受角度来表示颜色。</p><ul><li><strong>色调</strong>（Hue）表示颜色的种类，例如红色、绿色、蓝色等。它通常用角度来表示，在色相环上从 0° 到 360°，0° 或 360° 代表红色，120° 代表绿色，240° 代表蓝色等。</li><li><strong>饱和度</strong>（Saturation）表示颜色的纯度，即颜色中彩色成分所占的比例。饱和度越高，颜色就越鲜艳；饱和度越低，颜色就越接近灰色。例如，高饱和度的红色是鲜艳的红色，而低饱和度的红色则偏暗淡，会向灰红色靠近。</li><li><strong>亮度（Value）</strong> 表示颜色的明暗程度，从完全黑暗（黑色）到完全明亮（白色）。亮度越高，颜色越明亮；亮度越低，颜色越暗淡。</li></ul><p><img src="/assets/GAMES101/image-20250428233031-c19whwx.png" alt="">​</p><h3 id="CIE-LAB-空间"><a href="#CIE-LAB-空间" class="headerlink" title="CIE LAB 空间"></a>CIE LAB 空间</h3><p>CIE LAB 颜色空间也是由 CIE 定义的一种颜色空间。它是一种设备无关的颜色空间，旨在更加均匀地表示颜色差异，即颜色在空间中的距离可以近似地表示人眼对颜色差异的感知。</p><p>CIE LAB 颜色空间由一个明度通道（L）和两个色度通道（A 和 B）组成。L 通道表示亮度，其值范围通常为 0（黑色）到 100（白色）。A 通道表示从红色到绿色的色彩变化，其值范围一般为 - 128 到 127（或类似的范围），负值表示绿色方向，正值表示红色方向。B 通道表示从蓝色到黄色的色彩变化，同样其值范围一般为 - 128 到 127，负值表示蓝色方向，正值表示黄色方向。</p><p>它与人类视觉感知紧密相关，能够更加准确地表示颜色之间的差异。例如，在 CIE LAB 颜色空间中，两个颜色的欧几里得距离可以近似地表示人眼对这两个颜色差异的感知程度，这在颜色匹配和质量控制等领域非常重要。</p><p><img src="/assets/GAMES101/image-20250428233114-mdawp0l.png" alt="">​</p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
      <category>GAMES101</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09 Cameras, Lenses and Light Fields</title>
    <link href="/2025/01/09/GAMES101/09%20Cameras,%20Lenses%20and%20Light%20Fields/"/>
    <url>/2025/01/09/GAMES101/09%20Cameras,%20Lenses%20and%20Light%20Fields/</url>
    
    <content type="html"><![CDATA[<h1 id="09-Cameras-Lenses-and-Light-Fields"><a href="#09-Cameras-Lenses-and-Light-Fields" class="headerlink" title="09 Cameras, Lenses and Light Fields"></a>09 Cameras, Lenses and Light Fields</h1><h2 id="成像方法"><a href="#成像方法" class="headerlink" title="成像方法"></a><strong>成像方法</strong></h2><p>计算机图形学有两种成像方法，包括合成和捕捉</p><ul><li>合成：光栅化和光线追踪</li><li>捕捉：使用相机等设备记录真实世界图像</li></ul><p>‍</p><h2 id="相机原理"><a href="#相机原理" class="headerlink" title="相机原理"></a>相机原理</h2><h3 id="小孔成像"><a href="#小孔成像" class="headerlink" title="小孔成像"></a><strong>小孔成像</strong></h3><p>通过小孔形成倒立实像，所有点清晰无虚化。</p><p><img src="/assets/GAMES101/image-20250428103345-vtlh2o3.png" alt="">​</p><p>使用小孔成像原理的相机称作<strong>针孔相机</strong>，除此之外，还存在使用透镜的相机。</p><p>针孔相机拍出来的东西没有深度可言，不存在虚化的部分，背景都是清晰的</p><h3 id="相机结构"><a href="#相机结构" class="headerlink" title="相机结构"></a>相机结构</h3><p>相机由镜头和传感器组成。</p><ul><li><strong>镜头</strong>：由多个透镜组成，负责光线聚焦。</li><li><strong>传感器</strong>：记录光线强度，现代相机中通常为数字传感器。</li></ul><p><strong>为什么传感器必须要镜头？</strong></p><ul><li>实际上，记录光线的传感器并不能区分光的方向，它接受的是irradiance，而不是radiance</li><li>因此，必须要使用镜头来隔绝其他无关的光线</li></ul><h3 id="视场"><a href="#视场" class="headerlink" title="视场"></a><strong>视场</strong></h3><p><strong>视场角（Field of View, FOV）</strong> ：由传感器大小和焦距决定，影响拍摄范围。</p><p>一般来说，FOV有水平FOV和垂直FOV两种</p><p><img src="/assets/GAMES101/image-20250428105555-bzmddy4.png" alt="">​</p><p>定义传感器的大小为h；而传感器到镜头的距离为f，f也被称为焦距</p><p>于是，我们可以得到FOV的计算公式</p><p>$FOV = 2arctan(h/{2f})$  </p><p><strong>等效焦距</strong>：基于35mm胶片标准定义的焦距，便于不同相机参数比较。</p><ul><li>17mm对应的FOV为104</li><li>50mm对应的FOV为47</li><li>200mm对应的FOV为12</li></ul><p><img src="/assets/GAMES101/image-20250428105911-56lcf9y.png" alt="">​</p><p>上图是使用不同焦距的相机于同一位置拍摄的，</p><h2 id="曝光度"><a href="#曝光度" class="headerlink" title="曝光度"></a>曝光度</h2><h3 id="曝光"><a href="#曝光" class="headerlink" title="曝光"></a><strong>曝光</strong></h3><p><strong>H = t × E</strong></p><p>其中 H 为曝光度，t 为曝光时间，E 为Irradiance。</p><p>在相机中，曝光度由光圈、快门速度和ISO共同决定。</p><ul><li><strong>光圈（Aperture）</strong> ：控制进入相机的光量，由F数表示，F数越大光圈越小。</li><li><strong>快门速度（Shutter Speed）</strong> ：控制光线进入时间，影响运动模糊。</li><li><strong>感光度（ISO gain）</strong> ：可以认为是后处理。但是这个后处理可以发生在硬件上，例如传感器本身可以调节对光的敏感度，或者从数字信号上调整。</li></ul><p>光圈，快门速度，感光度的影响分别如下图所示</p><p><img src="/assets/GAMES101/image-20250428163138-c65l3yp.png" alt="">​</p><p>可以看到，高ISO虽然可以提升曝光度，但会导致图像噪点增加</p><p><strong>F数</strong>：焦距除以光圈的直径</p><p><strong>运动模糊</strong>的产生：对于机械的快门来说，它在打开和关闭会持续一段时间，而在运动的物体在这段时间会移动，中间的过程也会被记录下来，传感器平均之后会产生模糊</p><p>采取更短的曝光时间，那么可以一定程度上减轻运动模糊，但是相应的曝光度也会降低，为了平衡，可以调节光圈或者ISO</p><p>如下显示了F数和快门时间的对应</p><p><img src="/assets/GAMES101/image-20250428164135-bkexomt.png" alt=""></p><p>每一列设置的曝光度都大致相同，但是得到的结果并不完全一样</p><ul><li>大光圈会引起景深的问题</li><li>快门时间会影响运动模糊</li><li>一般是景深运动模糊二选一</li></ul><h3 id="高速摄影"><a href="#高速摄影" class="headerlink" title="高速摄影"></a>高速摄影</h3><p>高速摄影：每秒拍更多照片，有更高的帧数，然后按照正常帧数来放</p><p>因此，每张照片对应的快门时间非常短</p><p>快门时间短了，那么需要更大的光圈</p><p><img src="/assets/GAMES101/image-20250428165113-cc8d92v.png" alt="">​</p><h3 id="延时摄影"><a href="#延时摄影" class="headerlink" title="延时摄影"></a>延时摄影</h3><p>延时摄影：对一些照片应用特别长的曝光时间，且采取更小的光圈</p><p><img src="/assets/GAMES101/image-20250428165048-6nvffr7.png" alt="">​</p><h2 id="镜头"><a href="#镜头" class="headerlink" title="镜头"></a>镜头</h2><p>相机镜头复杂，无论是手机相机还是专业相机，镜头均由多个透镜组成。如下图是Iphone的摄像头</p><p><img src="/assets/GAMES101/image-20250428165220-igl9dc9.png" alt="">​</p><p>为简化描述，我们引入理想化的薄透镜模型，忽略其厚度。</p><p>假设薄透镜能将平行于透镜的光线聚焦到一点，此点即焦点，焦点到透镜中心的距离称作焦距。</p><p><img src="/assets/GAMES101/image-20250428165811-3hvc25u.png" alt="">​</p><p>假设这个薄透镜的焦距是可变的（在现实中，是通过透镜组的方式来改变的）</p><p>有以下基本假设：</p><ol><li>忽略透镜厚度</li><li>平行入射光线聚焦于焦点（焦距定义为焦点到透镜中心的距离）</li><li>遵循光路可逆原理</li><li>过中心光线方向不变</li></ol><p><img src="/assets/GAMES101/image-20250428170023-i07ycdz.png" alt="">​</p><p>其中$f$为焦距，$z_i$为物距，$z_0$为像距。此公式揭示了物像位置的对应关系，可通过几何光学中的相似三角形原理推导得出。</p><h3 id="弥散圆"><a href="#弥散圆" class="headerlink" title="弥散圆"></a>弥散圆</h3><p><strong>弥散圆（Circle of Confusion, CoC）概念</strong>：当物点偏离焦平面时，其成像会形成扩散光斑</p><p><img src="/assets/GAMES101/image-20250428172814-yd4a7c6.png" alt="">​</p><p>CoC直径计算公式如下：<img src="/assets/GAMES101/image-20250428173001-lkqwok1.png" alt="">​  </p><p>其中A为光圈孔径，$z_s$为感光元件位置，$f$为F数。</p><p>由此可知，CoC大小与光圈孔径正相关，与F数负相关。</p><p>这解释了为何大光圈（小F值）会产生显著景深效果。</p><h3 id="薄透镜光线追踪"><a href="#薄透镜光线追踪" class="headerlink" title="薄透镜光线追踪"></a>薄透镜光线追踪</h3><p>我们可以模拟薄透镜进行光线追踪</p><ul><li>确定成像平面（传感器）的物理尺寸与空间位置</li><li>设定焦距 f 与光圈孔径值</li><li><p>根据高斯公式推导像距</p></li><li><p>对感光元件每个像素进行双采样操作：  </p><ul><li><strong>透镜面采样</strong>：在透镜孔径范围内选择光线起点</li><li><strong>场景追踪</strong>：向场景投射光线并计算辐射传输</li></ul></li></ul><h3 id="景深"><a href="#景深" class="headerlink" title="景深"></a><strong>景深</strong></h3><p>景深（Depth of Field）指场景中成像清晰的轴向深度范围</p><p>焦平面（Focal Plane）上的物体无散焦模糊，偏离焦平面则产生弥散圆（CoC）</p><p>景深的<strong>影响因素</strong>：</p><ul><li><strong>光圈：</strong> 光圈越小（F数越大），景深范围越广</li><li><strong>焦距：</strong> 长焦距导致浅景深，短焦距增加景深范围</li><li><strong>CoC阈值</strong>：定义可接受的模糊极限值（与感光元件分辨率相关）</li></ul><p><img src="/assets/GAMES101/image-20250428174934-qzhdvqg.png" alt="">​</p><h3 id="光场"><a href="#光场" class="headerlink" title="光场"></a>光场</h3><p><strong>Light Field / Lumigraph</strong></p><p><strong>全光函数（The Plenoptic Function）</strong> 是用来描述在某一时刻，某一位置上能够看到的所有东西</p><p>全光函数的完整表示为$P(θ,ϕ,λ,t,V_x,V_y,V_z) $，其中θ和ϕ是极坐标表示，λ是波长，t是时刻，$V_x,V_y,V_z$是位置。</p><p>光场可以视作全光函数的一部分。</p><p><strong>光场</strong>：在任何一个位置往任何一个方向的光的强度。</p><p>特别地，我们可以使用包围盒来囊括物体，这样的好处在于包围盒的形状简单，易于记录。</p><p>有了光场之后，当观察点在包围盒外时，我们可以知道任意一个位置，任意一个方向看向物体时的信息</p><p>有了光场之后，实际上我们并不需要知道物体本来是什么，我们只需要知道它的光场信息，就可以看到物体</p><p><strong>光场照相机：</strong> 光场照相机的优点在于支持先照相，然后重新聚焦。</p><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
      <category>GAMES101</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08 Advanced Topics in Rendering</title>
    <link href="/2025/01/09/GAMES101/08%20Advanced%20Topics%20in%20Rendering/"/>
    <url>/2025/01/09/GAMES101/08%20Advanced%20Topics%20in%20Rendering/</url>
    
    <content type="html"><![CDATA[<h1 id="08-Advanced-Topics-in-Rendering"><a href="#08-Advanced-Topics-in-Rendering" class="headerlink" title="08 Advanced Topics in Rendering"></a>08 Advanced Topics in Rendering</h1><h2 id="高级光线传播"><a href="#高级光线传播" class="headerlink" title="高级光线传播"></a>高级光线传播</h2><p>光线追踪中大部分情况下都使用蒙特卡洛估计。</p><p>对于蒙特卡洛估计来说：</p><ul><li>如果无论采用多少样本，期望均等于真实值，那么这种估计称为<strong>无偏估计</strong></li><li><p>如果期望和真实值不一致，则称为<strong>有偏估计</strong></p><ul><li>特别地，如果在样本趋近于无穷多时为无偏的，即期望值收敛到正确值，称之为<strong>一致的</strong></li></ul></li></ul><h3 id="双向路径追踪"><a href="#双向路径追踪" class="headerlink" title="双向路径追踪"></a>双向路径追踪</h3><p><strong>Bidirectional Path Tracing ，BDPT （无偏）</strong></p><p>BDPT 利用光向可逆性，从光源和相机分别发出半路径，将端点连接起来则形成一条路径。</p><p>特别适用于光线传播复杂的环境，尤其是环境中大部分被漫反射光照亮的情况，此时从相机出发的路径很难正确达到光源（漫反射难以反射到光源的位置）</p><p><img src="/assets/GAMES101/image-20250427202817-m406dxj.png" alt="">​</p><p>如上图所示，右侧的双向路径追踪效果更好，因为侧面墙壁上很难漫反射到光源的位置，从光源出发的光线更容易计算</p><p>BDPT实现难度很高，并且运行慢很多</p><h3 id="Metropolis光线传播"><a href="#Metropolis光线传播" class="headerlink" title="Metropolis光线传播"></a>Metropolis光线传播</h3><p><strong>Metropolis Light Transport ，MLT（无偏）</strong></p><p>Metropolis 光线传播是一种无偏的光线传播估计方法，其核心思想是<strong>使用马尔可夫链</strong>来生成与当前路径相似的新路径，以进行光线采样。</p><p>具体来说，当找到一条路径后，通过对其路径上的点位置进行微小扰动，生成新的路径，并利用这些路径来估计渲染函数的值。该方法特别适合处理复杂的光路传播，例如在光线需要经过多次反射和折射才能到达观察点的场景中表现良好。</p><p>缺点：</p><ul><li>其收敛速度难以在理论上进行分析，无法准确预测渲染图像何时能够收敛到无噪声状态。</li><li>此外，由于操作是局部的，每个像素的收敛速度可能不一致，导致图像出现脏点，且不适合作为渲染动画的方法，因为相邻帧之间的收敛情况差异会导致图像抖动。</li></ul><h3 id="光子映射"><a href="#光子映射" class="headerlink" title="光子映射"></a>光子映射</h3><p><strong>Photon Mapping（有偏，一致）</strong></p><p>光子映射是一种有偏但一致的光线传播估计方法。</p><p>光子映射特别适合处理光线经过多次反射和折射后形成的复杂光照现象，如 Costics 效果（光线聚焦产生的强烈图案）。</p><p>其工作原理是</p><ol><li>首先，从光源发射大量光子，并记录光子在场景中的传播路径和与物体的相互作用。当光子碰到物体时，根据物体的材质属性决定是反射、折射还是吸收。特别地，当光子打到漫反射物体上时，光子会停止传播，并记录下其位置和能量信息。</li><li>在渲染阶段，从相机或观察者的位置出发，生成一系列的光线路径。当这些光线路径与物体表面相交时，通过查找该点周围一定范围内的光子分布情况，利用光子的能量和位置信息来估计该点的光照强度和颜色。这通常涉及到计算局部密度估计，即根据周围光子的数量和分布来确定该点的光照贡献。</li></ol><p>尽管光子映射在光子数量有限时会产生有偏的结果（如模糊效果），但随着光子数量的增加，其结果会逐渐趋近于真实值。</p><p>该方法在电影行业等对光照效果要求较高的领域得到了广泛应用。</p><h3 id="VCM（Vertex-Connection-and-Merging）"><a href="#VCM（Vertex-Connection-and-Merging）" class="headerlink" title="VCM（Vertex Connection and Merging）"></a>VCM（Vertex Connection and Merging）</h3><p>VCM 的核心思想是将双向路径追踪和光子映射结合起来。</p><ul><li>在双向路径追踪中，会从光源和相机分别生成子路径（sub-path），然后尝试连接这些子路径的端点以形成完整的光线路径。</li><li>而光子映射则侧重于从光源出发，记录光子在场景中的分布情况，尤其关注光子在漫反射物体上的积累。</li></ul><p>VCM将双向路径追踪和光子映射结合起来，如果BDPT的半路径的终点不能连接起来，但是其在一个局部平面里，就可以用光子映射将其合并</p><h3 id="实时辐射度（Instant-Radiosity-，IR）"><a href="#实时辐射度（Instant-Radiosity-，IR）" class="headerlink" title="实时辐射度（Instant Radiosity ，IR）"></a>实时辐射度（Instant Radiosity ，IR）</h3><p>从光源打出多条半路径，其终点所在位置即为虚拟点光源（VPL），使用这些VPL渲染场景。</p><p>优点是速度快，在漫反射场景有较好的效果。</p><p>缺点是不能在gloosy场景使用，且渲染的点太近会出现小光源</p><h2 id="高级材质模型——非表面模型"><a href="#高级材质模型——非表面模型" class="headerlink" title="高级材质模型——非表面模型"></a>高级材质模型——非表面模型</h2><h3 id="散射介质"><a href="#散射介质" class="headerlink" title="散射介质"></a>散射介质</h3><p>光线在穿过<strong>散射介质</strong>时会发生吸收和散射，如雾、云等。</p><p>用<strong>相位函数（Phase Function）</strong> 描述光线在参与介质中的散射性质，即光线是往后集中散射、往前集中散射还是各向同性散射。</p><p><strong>渲染方法</strong>：</p><ul><li>随机选择一个方向进行光线反弹。</li><li>随机选择一个直线传播的距离。</li><li>在每个“着色点”，连接到光源。</li></ul><h3 id="头发外观"><a href="#头发外观" class="headerlink" title="头发外观"></a>头发外观</h3><p><strong>Kajiya-Kay模型</strong>：将头发视为圆柱体，光线照射到头发上会形成圆锥形散射，同时也会向四面八方散射，类似于漫反射和镜面反射的结合。</p><p><strong>Marschner模型</strong>：将散射的光线分为三种：R（反射）、TT（透射两次）、TRT（透射一次后反射再透射）。该模型将头发视为玻璃圆柱体，分为角质层（cuticle）和皮层（cortex），皮层含有色素会吸收光线。</p><p><strong>动物毛发</strong>：动物毛发的髓质（medulla）较大，光线进入后更容易发生散射。使用双层圆柱模型来模拟髓质，增加散射穿过的TTS和散射反射出来的TRTS。</p><h3 id="颗粒状材质"><a href="#颗粒状材质" class="headerlink" title="颗粒状材质"></a><strong>颗粒状材质</strong></h3><p>如沙子、盐等，由小颗粒构成。</p><p>可简化为统计各成分百分比进行渲染，但计算量大，目前尚未得到很好解决。如盐、糖、沙子；</p><h2 id="高级材质模型——表面模型"><a href="#高级材质模型——表面模型" class="headerlink" title="高级材质模型——表面模型"></a>高级材质模型——表面模型</h2><h3 id="半透明材质与次表面散射"><a href="#半透明材质与次表面散射" class="headerlink" title="半透明材质与次表面散射"></a>半透明材质与<strong>次表面散射</strong></h3><p>光线从一个点进入物体，从另一个点射出，形成次表面散射。不仅仅是半透明，光线在内部还会发生折射，如玉石、水母、牛奶、人耳等。</p><p>次表面散射BSSRDF是对 BRDF 的延伸，需考虑光线进入和离开点的位置与方向。可使用高斯径向模糊等方法近似渲染效果，能显著提升皮肤等材质的真实感。</p><h3 id="布料材质"><a href="#布料材质" class="headerlink" title="布料材质"></a>布料材质</h3><p><strong>纤维结构</strong>：布料是由纤维缠绕而成的。</p><ul><li>每一根纱线由纤维缠绕而成。</li><li>每一股毛线由纱线缠绕而成。</li></ul><p><strong>渲染方法</strong>：</p><ul><li><strong>作为表面渲染</strong>：根据织物图案计算整体行为，使用 BRDF 渲染。但对于像天鹅绒这样的布料效果无法展现。</li><li><strong>作为参与介质渲染</strong>：考虑单个纤维的属性及其分布，转化为散射参数。将布料视为空间中分布的体积，对每个小格子中的布料性质进行采样，类似渲染云雾，但计算量大。</li><li><strong>作为实际纤维渲染</strong>：显式渲染每一根纤维，但计算量更大。</li></ul><h3 id="细节材质"><a href="#细节材质" class="headerlink" title="细节材质"></a>细节材质</h3><p><strong>非真实感问题</strong>：过于完美的渲染结果反而不真实，真实世界物体表面存在划痕等细节。</p><p>微表面模型可描述法线分布，但计算复杂。引入细节时还需考虑波动光学效应。</p><h2 id="高级材质模型——程序化生成材质"><a href="#高级材质模型——程序化生成材质" class="headerlink" title="高级材质模型——程序化生成材质"></a><strong>高级材质模型——程序化生成材质</strong></h2><p>三维模型和材质的存储量极大的情况，不一定需要显式生成材质，可以通过查询噪声函数动态生成。</p><ul><li>使用噪声函数动态计算，避免显式存储。</li><li>三维噪声函数可以生成内部结构，如切割或破损后的材质内部结构。</li><li>对噪声函数进行阈值处理（如二值化）以生成不同效果。</li></ul><p><strong>复杂噪声函数的应用</strong>：</p><ul><li>Perlin Noise：用于生成地形、三维木材等。</li><li>其他噪声函数：如 Goodbye Noise 等。</li></ul><p><strong>Houdini</strong>：用于程序化生成材质（显式生成）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://immmortal.notion.site/Lec-18-Advanced-Topics-in-Rendering-c40ecbb678744b8e85fd2cf095067026">Lec 18 - Advanced Topics in Rendering</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
      <category>GAMES101</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07 Materials and Appearances</title>
    <link href="/2025/01/06/GAMES101/07%20Materials%20and%20Appearances/"/>
    <url>/2025/01/06/GAMES101/07%20Materials%20and%20Appearances/</url>
    
    <content type="html"><![CDATA[<h1 id="07-Materials-and-Appearances"><a href="#07-Materials-and-Appearances" class="headerlink" title="07 Materials and Appearances"></a>07 Materials and Appearances</h1><p>有不同的材质，在某些光照下，就会表示出不同的外观，所以说外观是光线和材质共同作用的结果。</p><p>因此，在研究材质的时候，实际上研究的是光线如何与材质进行作用</p><h2 id="图形学中的材质"><a href="#图形学中的材质" class="headerlink" title="图形学中的材质"></a>图形学中的材质</h2><p>材质可以通过非物理的方式用贴图，法线来模拟</p><p>从渲染方程来看，可以说 Material == BRDF，即决定了光如何进行反射与折射</p><h3 id="漫反射材质"><a href="#漫反射材质" class="headerlink" title="漫反射材质"></a>漫反射材质</h3><p>漫反射材质无光泽，无反射，例如陶瓷，木头</p><p><img src="/assets/GAMES101/image-20250427182401-ebo1tit.png" alt="">​</p><p>在Blinn-Phong模型中，漫反射系数是一个经验系数，其取值范围为(0, 1)</p><p>$L_d = K_d \left( \frac{I}{r^2} \right) \max(0, \mathbf{n} \cdot \mathbf{l})$  </p><p>在渲染方程中，类似地，可以推出对应的漫反射系数</p><p>假设入射光是均匀的，即各个方向都是均匀的，那么入射光的能量等于出射光的能量</p><p>假设$f_{r}$和$L_{i}$都是常数，则有</p><p>$\begin{aligned} L_{o}\left(\omega_{o}\right) &amp;=\int_{H^{2}} f_{r} L_{i}\left(\omega_{i}\right) \cos \theta_{i} \mathrm{d} \omega_{i} \\ &amp;=f_{r} L_{i} \int_{H^{2}} \cos \theta_{i} \mathrm{d} \omega_{i} \\ &amp;=\pi f_{r} L_{i} \end{aligned}$  </p><p>因此，有</p><p>$f_{r}=\frac{\rho}{\pi}$  </p><p>可以认为ρ就是反射率，其取值范围是0~1</p><h3 id="光泽材质"><a href="#光泽材质" class="headerlink" title="光泽材质"></a>光泽材质</h3><p>有光泽，无反射的材质，例如金属</p><p><img src="/assets/GAMES101/image-20250427182337-zg70vhw.png" alt="">​</p><h3 id="镜面材质"><a href="#镜面材质" class="headerlink" title="镜面材质"></a>镜面材质</h3><p>镜面材质用于透明，半透明的物体，例如水，玻璃</p><p><img src="/assets/GAMES101/image-20250427182350-qotxexo.png" alt="">​</p><h3 id="完美镜面反射"><a href="#完美镜面反射" class="headerlink" title="完美镜面反射"></a>完美镜面反射</h3><p>完美镜面反射的反射角是可算的，左图是正视图，右图是俯视图</p><p><img src="/assets/GAMES101/image-20250427182419-ix4x9n3.png" alt="">​​​</p><h3 id="镜面折射"><a href="#镜面折射" class="headerlink" title="镜面折射"></a>镜面折射</h3><p>光从一种介质入射到另一种介质时，可能会发生折射现象</p><p><strong>折射定律：</strong></p><p>（1）折射光线位于入射光线和界面法线所决定的平面内；</p><p>（2）折射线和入射线分别在法线的两侧；</p><p>（3）入射角i的正弦和折射角i′的正弦的比值，对折射率一定的两种媒质来说是一个常数。</p><p><img src="/assets/GAMES101/image-20250427182433-nwfmfgm.png" alt="">​</p><p><img src="/assets/GAMES101/image-20250427182446-da6r1oy.png" alt="">​</p><p>可以看出，某些情况$cos\theta_{i}$不存在，不会存在折射现象，此时会发生全反射</p><p><strong>斯涅耳窗：</strong> 从水底看，由于折射现象的存在，人只能看到锥形视野范围内的光</p><p><img src="/assets/GAMES101/image-20250427182458-b67tqrx.png" alt="">​</p><h3 id="BTDF"><a href="#BTDF" class="headerlink" title="BTDF"></a>BTDF</h3><p>双向反射分布函数（BRDF）</p><p>双向折射(透射)分布函数（BTDF）</p><p>BRDF和BTDF统称为双向散射分布函数（BSDF）</p><h3 id="菲涅耳反射"><a href="#菲涅耳反射" class="headerlink" title="菲涅耳反射"></a>菲涅耳反射</h3><p>根据光的反射规律可知，折射反射的程度取决于观察者的角度。简单的讲，就是视线垂直于表面时，反射较弱，而当视线非垂直表面时，夹角越小，反射越明显</p><p>例如站在湖边，低头看脚下的水，会发现水是透明的，但是看远处的湖面，湖面更像一面镜子</p><p>此外，入射角相同，不同材质的菲涅尔项也不一样</p><p><img src="/assets/GAMES101/image-20250110232904-rt1rrlm.png" alt="">​</p><p>上面的s和p跟光的波动有关，这里只需要知道有这么个东西可以算就行了</p><h2 id="微表面理论"><a href="#微表面理论" class="headerlink" title="微表面理论"></a>微表面理论</h2><p>微表面理论认为，所谓的平面实际上是由不同方面的微观表面组成</p><p><img src="/assets/GAMES101/image-20250110234010-ab35xda.png" alt="">​</p><p>对于粗糙和光滑的平面来说，实际上就是微观表面的朝向聚集不同</p><p><img src="/assets/GAMES101/image-20250427182521-iem3h4c.png" alt="">​</p><h3 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h3><p>根据微表面模型，BRDF方程可以进一步优化，表示为</p><p><img src="/assets/GAMES101/image-20250427182534-9k5o5df.png" alt="">​​​</p><ul><li>F为菲涅尔项</li><li>D为微平面的法线分布，用于查询半程向量h</li><li>G为几何项：由于在微表面上，对于那些几乎和表面平行的入射光，很容易发生互相遮挡的现象，从而使得部分微表面失去作用，我们把这种光线角度称为掠射角度（Grazing Angle），在这种角度下的着色会非常亮，G项就起到了一定的修正作用</li></ul><p>微表面模型可以得到非常非常真实的渲染结果，是基于物理的方法，也是现在的state of art</p><h3 id="各向同性-各向异性"><a href="#各向同性-各向异性" class="headerlink" title="各向同性/各向异性"></a>各向同性/各向异性</h3><p>材质可以分为两类</p><ul><li>各向同性：各项同性材料的微表面的方向是均匀的</li><li>各向异性：各项异性材料的微表面的方向是不均匀的</li></ul><p>如果入射光和出射光做一定方位角的旋转前后，BRDF方程不变，那么这 种材质就是各向同性的，反之则为各向异性</p><h2 id="BRDF总结"><a href="#BRDF总结" class="headerlink" title="BRDF总结"></a>BRDF总结</h2><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p><strong>非负性：</strong> 描述能量分布</p><p><strong>线性性：</strong> 可以被拆分成不同项的线性组合（ambient，diffuse，specular）</p><p><strong>可逆性：</strong> 调换入射出射方向，BRDF渲染结果严格不变</p><p><strong>能量守恒：</strong> 出射光线的能量永远不能超过入射光线的能量</p><p><strong>各向同/异性：</strong> 如果是各项同性材质，则BRDF值只和相对方位角有关，四维的BRDF材质可以被降维为三维，并且根据可逆性，结果不需要考虑方位角的正负</p><p><img src="/assets/GAMES101/image-20250427182549-l0vja06.png" alt="">​</p><p><img src="/assets/GAMES101/image-20250427182605-65qn47h.png" alt="">​</p><p><img src="/assets/GAMES101/image-20250427182617-t0ychz8.png" alt="">​</p><h3 id="BRDF的测量"><a href="#BRDF的测量" class="headerlink" title="BRDF的测量"></a>BRDF的测量</h3><p>BRDF虽然在理论上可计算，但并不完全符合实际</p><p>因此，实验上的测量可以无需理论推导而直接使用</p><p><img src="/assets/GAMES101/image-20250427182641-5uma7pw.png" alt="">​</p><p>给定一个着色点，通过改变入射和出射的角度（改变光源与相机位置）进行测量</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">foreach</span> outgoing direction wo<br>move light to illuminate surface <span class="hljs-keyword">with</span> a thin beam <span class="hljs-keyword">from</span> wo<br> <span class="hljs-keyword">for</span> each incoming direction wi<br>move sensor to be at direction wi <span class="hljs-keyword">from</span> surface<br> measure incident radiance<br></code></pre></td></tr></table></figure><p>如算法伪代码所示，这样测出来的BRDF是四维的，这样的测量是非常费时的</p><p>为了提高效率，我们可以尽量让材质呈各向同性</p><p>就像之前说的，这不仅可以让BRDF从四维降至三维，还能由光路可逆性再砍去一半的测量</p><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
      <category>GAMES101</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06 Ray Tracing</title>
    <link href="/2025/01/06/GAMES101/06%20Ray%20Tracing/"/>
    <url>/2025/01/06/GAMES101/06%20Ray%20Tracing/</url>
    
    <content type="html"><![CDATA[<h1 id="06-Ray-Tracing"><a href="#06-Ray-Tracing" class="headerlink" title="06 Ray Tracing"></a>06 Ray Tracing</h1><h2 id="光线追踪"><a href="#光线追踪" class="headerlink" title="光线追踪"></a>光线追踪</h2><p><strong>光栅化的局限</strong></p><p>光栅化并做不好全局的效果，如软阴影，反射，环境光照，渲染的质量不高。相比之下，光线追踪处理速度虽慢，渲染质量却很高。此外，光栅化很容易做到实时，而光线追踪更多的应用于离线渲染。</p><p><strong>图形学中的光线假设</strong>——光线沿直线传播 </p><ul><li>光线之间彼此不会发生碰撞</li><li>从光源发出光线到达人眼，经过了多次反射与折射，由于光是可逆的，我们可以认为是从人眼发出光线，最终到达了光源。</li></ul><p><strong>光线追踪的基本思想</strong></p><p>因为光路是可逆的，那么就让光线从眼睛出发，沿屏幕每个像素投射出去，判断与场景物体的交点，然后计算该交点的受光照情况。形成一个屏幕图像就需要投射出屏幕分辨率个光线出去，这种计算量无疑是巨大的，但是图像质量极高。</p><h2 id="递归式光线追踪"><a href="#递归式光线追踪" class="headerlink" title="递归式光线追踪"></a>递归式光线追踪</h2><p><strong>Whitted-Style  Ray Tracing（Recursive Ray Tracing）</strong></p><p><img src="/assets/GAMES101/image-20250427145739-cfjqixo.png" alt="">​</p><ol><li>从相机出发，发射出屏幕像素个数的光线，穿过每一个像素点，打到物体。由于一条光线可能穿过多个物体，取取光路与物体最近的交点（涉及深度测试），这个点称为着色点。</li><li><p>在这个着色点上，可能发生两种情况：</p><ol><li>这一点发生了<strong>漫反射</strong>：如果光源能看见着色点（着色点不在阴影中），那么就生成一条有效光路，计算能量并着色（我们很容易知道这个着色点的法线，入射方向等信息，这时候可以用各种各样的着色模型（如Blinn Phong））</li><li>这一点发生了完美的<strong>折射与反射</strong>：折射或反射后的光线会打到新的着色点上，对于这个新的着色点进行同样的判断与处理。</li></ol></li><li>最后，将每个交点的受光照情况（使用Blinn Phong算法）以一定权重综合起来，得到的颜色即是该像素的颜色。</li></ol><p>需要注意的是：</p><ul><li>为了减少递归次数，可以额外给予一定的递归终止条件（如允许的最大反射或折射次数为10）。</li><li>光线在每次反射和折射之后都有能量损耗的（由系数决定），因此经过多次投射后的光线贡献的能量就越小。</li><li>如果投射光线没有碰撞到物体，一般直接返回一个背景色。</li></ul><p><strong>漫反射表面（diffuse surface）</strong> ：粗糙的表面，可以认为它会向各个方向等强度地反射光，因此光线投射到该表面时，本应该会有无数条光线反射出去，但是为了减少计算量，Whitted-Style  则直接对该交点进行 Blinn Phong 着色后就终止递归。</p><h2 id="光线与物体求交"><a href="#光线与物体求交" class="headerlink" title="光线与物体求交"></a>光线与物体求交</h2><p>为了研究光线与物体求交问题，我们需要先定义光线：一个光线可以有一个点（光源）和一个方向（光线方向）确定，则可设光线上的点的表达式：</p><p><img src="/assets/GAMES101/image-20250427155115-5pzis5z.png" alt="">​</p><h3 id="与球体求交"><a href="#与球体求交" class="headerlink" title="与球体求交"></a><strong>与球体求交</strong></h3><p><img src="/assets/GAMES101/image-20250427155413-0ylixkc.png" alt="">​</p><h3 id="隐式表面求交"><a href="#隐式表面求交" class="headerlink" title="隐式表面求交"></a><strong>隐式表面求交</strong></h3><p><img src="/assets/GAMES101/image-20250427155427-5ph3zgp.png" alt="">​</p><h3 id="显示表面求交"><a href="#显示表面求交" class="headerlink" title="显示表面求交"></a><strong>显示表面求交</strong></h3><p>显示表面中最常见的就是三角形，因此最重要的就是判断与三角形求交的问题</p><p><strong>判断点是否在物体内部</strong>：判断该点发射的光线与物体的交点数量是奇数还是偶数。</p><p><strong>判断三角形与光线的交点：先判断是否与三角面所在平面相交，求出交点，再判断交点是否在三角形内</strong></p><p><strong>光线和平面求交</strong></p><p><img src="/assets/GAMES101/image-20250427155502-1469lnx.png" alt="">​</p><p><strong>判断交点在不在三角形内部</strong></p><p>Möller  Trumbore Algorithm——MT算法：利用重心坐标，交点可以被重心坐标表示出来，三个未知数三个方程，可求解</p><p><img src="/assets/GAMES101/image-20250427170555-vz22mo5.png" alt="">​</p><h2 id="加速光线追踪"><a href="#加速光线追踪" class="headerlink" title="加速光线追踪"></a><strong>加速光线追踪</strong></h2><p>对于每一个屏幕像素点投射出来的光线，我们都要计算光线与空间中的所有三角形是否有交点，计算次数=像素数×三角形数×弹射次数。显然这是一个十分巨大的开销。</p><p>我们可以利用<strong>轴对齐包围盒（AABB）</strong> 来优化这个过程。</p><p>我们引入包围盒的概念，将一个复杂的物体用简单的形状围起来。如果光线连包围盒都碰不到，那肯定碰不到包围盒里的物体。对于三维的情况，我们一般用特殊的长方体包围盒——轴对齐包围盒，即包围盒的每一个边都对应和一个坐标轴平行。</p><p><img src="/assets/GAMES101/image-20240210174342-vvm4dl2.png" alt=""></p><p>如上图，可以得出：只有当光线进入了三组对面，才能说明光线进入了包围盒，同理，只要光线离开了任一对面，就说明光线离开了包围盒。</p><h3 id="光线与包围盒求交算法"><a href="#光线与包围盒求交算法" class="headerlink" title="光线与包围盒求交算法"></a><strong>光线与包围盒求交算法</strong></h3><p>对于任一对面，我们计算出光线进入对面的最小时间tmin和最大时间tmax（负数也无所谓），接着即可求出光线进入和离开包围盒的时间。</p><p><img src="/assets/GAMES101/image-20240210174342-sn62kyf.png" alt="">​</p><ul><li>如果$t_{enter}$&lt;$t_{exit}$，说明光线进入了这个盒子里，反之就是没有</li><li><p>总的来说</p><ul><li>如果$t_{exit}&lt;0$：说明包围盒在光线的后面——没有交点</li><li>如果$t_{exit}&gt;0$ and $t_{enter}&lt;0$：说明光线起点在包围盒之中——有交点</li><li>总的来说，光线和AABB的交点有且仅有 $t_{enter}<t_{exit} 且t_{enter}>=0$​​</li></ul></li></ul><h3 id="确定包围盒的位置——均匀划分"><a href="#确定包围盒的位置——均匀划分" class="headerlink" title="确定包围盒的位置——均匀划分"></a><strong>确定包围盒的位置——均匀划分</strong></h3><p>通过上述分析，我们已经知道了光线如何和包围盒求交，接下来需要在空间中确定包围盒的位置。</p><p>我们判断光线与物体求交的步骤为：</p><ul><li>找到整个场景包围盒</li><li>均匀划分该包围盒</li><li>判定与物体相交的子包围盒</li><li>与物体求交</li></ul><p>我们可以使用均匀划分的方法，均匀划分就是将空间均匀划分成包围盒。</p><ul><li>量级：如果划分太稀疏或是太密集，效率都不会高，根据经验，人们大概得出划分成场景中物体数目的27倍的格子数比较好</li><li>缺点：格子的划分方法在大量均匀分布的物体上比较有效，然而在复杂空旷的场景中，会造成很多资源浪费</li></ul><h3 id="确定包围盒的位置——空间划分"><a href="#确定包围盒的位置——空间划分" class="headerlink" title="确定包围盒的位置——空间划分"></a><strong>确定包围盒的位置——空间划分</strong></h3><p>在网格均匀划分中划分出来的都是大小相同的格子，但场景中的物体一般不会是均匀分布，空旷的地方不需要进行这样划分</p><p>我们希望在没有物体的地方用大的包围盒，有物体的地方用小的包围盒，这也就引出了空间划分的方法。</p><p>注意：这里提到的空间划分，不是物体划分。比如说一个物体，可以划分到多个包围盒里</p><p><img src="/assets/GAMES101/image-20240210174342-4jp8oaa.png" alt="">​</p><p><strong>八叉树</strong></p><ul><li>每一次把空间划分成八份（三维上），直到满足一定的停止规则（比如某一次划分8个子空间中7个为空）</li><li>缺点是维数越高越复杂，n维空间对应叉树</li></ul><p><strong>KD树</strong></p><ul><li>每次把空间划分为两份，x，y，z轴轮流切分，直到被切分节点中不存在物体则停止</li></ul><p><strong>BSP树</strong></p><ul><li>一种对空间二分的划分方法，每次选一个方向进行划分，与KD树的区别在于它不是横平竖直地切，且它会有越高维越不好计算的问题（用线切开二维，用面切开三维，维度越高越复杂）</li></ul><p><strong>KD树如何进行划分</strong></p><p><img src="/assets/GAMES101/image-20240210174342-go9mp5o.png" alt=""></p><p>如果一条光线与当前结点空间有交点，则继续寻找该结点的子节点，直到找到叶子结点，再与其中物体求交</p><p><strong>KD树的局限：</strong></p><p>给出一个节点的包围盒，要判断他与物体哪些三角形有交集，才能进行后续着色，这种算法确实存在，但不太好写</p><p>其次，很多情况下一个物体和很多包围盒都有交集，它可能会存在很多个叶子节点中，会造成重复计算</p><p>因此，KD树现在很少使用到，我们更多使用的是根据物体划分的BVHs划分。</p><p><strong>确定包围盒的位置——BVHs划分（Bounding  Volume Hierarchy）</strong></p><p>找到场景包围盒 -&gt; 每次将物体分为两堆 -&gt; 对两堆物体重新计算包围盒 -&gt;  直到一堆中物体少到一定程度</p><p>KD树的包围盒不会发生重合，而BVHs会发生相交</p><h2 id="辐射度量学"><a href="#辐射度量学" class="headerlink" title="辐射度量学"></a>辐射度量学</h2><p>Blinn-Phong着色模型中会设置一个数当做光照强度，但我们都不清楚这个数的真实的物理意义，甚至连单位是什么也不知道，研究过程中我们只是将这些物理量简化为一个数，另外Whitted风格的光线追踪所得到的结果也不是我们所想要的真实的效果（路径追踪会提到），而所有的这些都会被辐射度量学解决，这同样也是后面学习路径追踪的基础。</p><p>辐射度量学给出了一系列度量方法和单位去定义光照，它定义了光照在空间中的属性，并且这在物理上是完全正确的</p><p><img src="/assets/GAMES101/image-20240210174353-07hst5z.png" alt="">​</p><p>关于这个Radiance，我们认为它的物理意义是，从dA面积上，向某个方向辐射出的能量；或者说某个方向的能量照射到dA上，作为dA吸收到总能量的一部分。</p><p><img src="/assets/GAMES101/image-20250427181257-tb6qocm.png" alt="">​</p><p>相比于Irradiance的单位面积上的能量，Radiance可以看作是单位面积上吸收到的单个方向上的能量，于是我们有</p><p>$dE(\mathbf{p}, \omega) = L_i(\mathbf{p}, \omega) \cos \theta \, d\omega \qquad E(\mathbf{p}) = \int_{H^2} L_i(\mathbf{p}, \omega) \cos \theta \, d\omega$  </p><p>即dA面积上的能量 = 所有方向的能量之和，因为是连续的方向，所以是求积分。</p><h3 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a><strong>BRDF</strong></h3><p><img src="/assets/GAMES101/image-20250427181345-ob9l8rb.png" alt="">​</p><p>由上式，BRDF就是吸收能量后往某一方向反射时取的比例，即某个角度入射到dA面积上的能量，乘以比例fr后反射到另一个角度。</p><p>于是我们只考虑某一个出射方向，毫无疑问的，这个出射方向的能量 = 全部光线打到dA上时，反射到该被考虑方向上的能量之和。</p><p>渲染方程与反射方程相比，加上了物体自发光的项，渲染方程如下：</p><script type="math/tex; mode=display">L_o(\mathbf{x}, \mathbf{\omega}_o) = L_e(\mathbf{x}, \mathbf{\omega}_o) + \int_{\Omega} L_i(\mathbf{x}, \mathbf{\omega}_i) f_r(\mathbf{x}, \mathbf{\omega}_i, \mathbf{\omega}_o) (\mathbf{\omega}_i \cdot \mathbf{n}) \, d\mathbf{\omega}_i</script><ul><li>$L_o(x,ω_o)$：表示从点 x 沿方向 $ω_o$ 发出的光强（出射光强）。</li><li>$L_e(x,ω_o)$：表示点 x 在方向 $ω_o$上的自身发光强度（发射光强），对于非光源物体，这一项通常为零。</li><li>$L_i(x,ω_i)$：表示从点 x 沿方向$ω_i$到达的光强（入射光强）。</li><li>$fr(x,ω_i,ω_o)$：表示双向反射分布函数（Bidirectional Reflectance Distribution Function，BRDF），它描述了从方向 ωi 到方向 ωo 的反射光强的比例。</li><li>$ω_i⋅n$：表示方向 ωi 与表面法线 n 的点积，用于表示入射光与表面的夹角，只有当入射光与表面夹角小于90度时（即点积大于零）才会有有效反射。</li><li>Ω：表示所有可能的入射方向的集合，通常是一个半球面。</li></ul><p>渲染方程描述了从一个点出发的光强由两部分组成：</p><ul><li><strong>自身发光</strong>：物体自身发出的光（如灯泡、荧光屏等）。</li><li><strong>反射光</strong>：其他物体或光源发出的光照射到该点后，经过表面反射而产生的光。</li></ul><p><img src="/assets/GAMES101/image-20250427181634-dzh5t8u.png" alt="">​</p><h3 id="蒙特卡洛积分"><a href="#蒙特卡洛积分" class="headerlink" title="蒙特卡洛积分"></a><strong>蒙特卡洛积分</strong></h3><p><img src="/assets/GAMES101/image-20240210174353-w5h00tg.png" alt="">​</p><p><img src="/assets/GAMES101/image-20240210174353-mnjtj1c.png" alt="">​</p><p>在这之中，$F_N = \int_{a}^{b} f(x) \, dx$</p><p>蒙特卡洛方法可以通过随机采样的方式求解数学问题，对于求解定积分问题，可以通过蒙特卡洛方法估计出一个近似数值解。</p><p>我们把积分变量看成连续型随机变量，每次采样，就用采样所得变量映射得到的函数值，代表所有积分区间内所有变量对应的函数值，多次采样逐渐逼近真实函数的在积分域内所得积分值。</p><h3 id="路径追踪"><a href="#路径追踪" class="headerlink" title="路径追踪"></a><strong>路径追踪</strong></h3><p><img src="/assets/GAMES101/image-20240210174353-kc8hfy3.png" alt="">​</p><p>Whitted-Style光线追踪的做法是，光线在镜面反射表面弹射，而在漫反射表面停止，这显然是不符合现实的</p><p>其中一个问题，拿经典的Utah teaport为例，whitted光追只能做左图的光照效果，而对于那种有光泽但不全是镜面反射的glossy材质（右图），whitted做出来的效果并不尽如人意</p><p>第二个问题，whitted风格光线追踪不考虑漫反射，虽然递归的思想是正确的，但就像下图（康奈尔盒子）所示，whitted的天花板由于接收不到来自环境光照，呈现一个全黑的状态，并且whitted渲染出的长方体并没有表现红墙和绿墙上反射过来的带有色彩的光，相比之下，路径追踪的结果就真实很多</p><p><img src="/assets/GAMES101/image-20250427181856-39usvwy.png" alt="">​</p><h2 id="求解渲染方程"><a href="#求解渲染方程" class="headerlink" title="求解渲染方程"></a><strong>求解渲染方程</strong></h2><p>对于之前的渲染方程，我们可以用蒙特卡洛积分法进行求解，忽略自发光项（仅计算直接光照），简单考虑均匀采样的情况</p><p><img src="/assets/GAMES101/image-20240210174353-mryjp2a.png" alt="">​</p><p><img src="/assets/GAMES101/image-20250427181918-1r14x51.png" alt="">​​​</p><p>接着引入间接光照：要知道着色点P因Q的反射获得多少能量，其实就相当于摄像机在P点处计算Q的直接光照</p><p><img src="/assets/GAMES101/image-20240210174353-wteq8zd.png" alt="">​</p><p>那么就只需要在上述算法中加一条判断，看看从P点反射出来的光线有没有打到其他物体</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>至此，基本的求解渲染方程已经有了大概的架构，但依然存在一些不可忽视的问题</p><p><strong>问题传递的可行性</strong></p><p>P点的着色需要Q点的环境光照信息，而Q点的环境光照信息又必须包含其他物体的环境光照信息，如此需要追踪的光线数量会呈指数级增长</p><p>只有当采样数为1的时候，即N=1时，才不会受到这种影响，路径追踪也因此得名（N!=1时称为分布式光线追踪）</p><p>虽然但是，这样一来误差就会特别大，渲染结果势必会有非常多的噪点，为了解决这个问题，我们对单个像素计算多次路径追踪结果（SPP），随后求平均，这个过程其实也用到了蒙特卡洛方法</p><p><strong>递归结束条件</strong></p><p>很容易看出，上述算法的递归没有终止条件，放到现实中这也是非常合理的，因为现实中的光并不会弹射一定次数后终止弹射，而会一直弹射下去，在算法中强行设置终止次数结束递归不满足现实情况的能量守恒定律，会有一定亮度差异（弹射3次和弹射17次的亮度差异是非常明显的），为了解决这一问题，我们需要用到与俄罗斯轮盘赌类似的思想</p><p>这个思想其实就是一个伯努利分布（均匀分布）概念，让光线在每个弹射点都有一定概率继续弹射，设这个概率为p，那么光线停止弹射的概率为（1-p），为了得到相同的路径追踪结果，意味着这个伯努利实验的期望值必须保持Lo不变，那么我们可以巧妙的认为p概率继续弹射得到的能量是L_0/P（终止弹射的结果很自然就是0）</p><p><img src="/assets/GAMES101/image-20240210174353-ffsea1h.png" alt="">​</p><p>这样一来，我们就有了一个合理的递归终止条件</p><p>思考：闫老师上课提了一个问题，对于分布式光线追踪，这个期望值是多少</p><p><img src="/assets/GAMES101/image-20240210174353-30ss2br.png" alt="">​</p><h3 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a><strong>优化算法</strong></h3><p>至此，我们的路径追踪算法已经做到完全正确，但又出现了一个矛盾点，即像素的采样率</p><p><img src="/assets/GAMES101/image-20240210174353-xau2756.png" alt="">​</p><p>在路径追踪算法中，采样率（Samples Per Pixel，SPP）决定了每个像素的光线追踪次数。如果采样率过低，可能会出现以下问题：</p><ul><li><strong>光源太小，采样可能错过光源</strong>：如果光源面积很小，而采样率不高，那么从着色点（被照亮的点）发出的随机光线可能完全错过光源，导致该点看起来过暗，即使它理论上应该被照亮。</li></ul><p>所以我们不用这种基于着色点采样的方式，而改为一种基于光源的采样</p><h3 id="基于着色点采样-vs-基于光源采样"><a href="#基于着色点采样-vs-基于光源采样" class="headerlink" title="基于着色点采样 vs. 基于光源采样"></a><strong>基于着色点采样 vs. 基于光源采样</strong></h3><p><strong>基于着色点采样</strong></p><ul><li><strong>原理</strong>：从着色点随机发射光线，计算这些光线与光源的交点。</li><li><strong>问题</strong>：如果光源面积小，采样率低，很容易错过光源。</li></ul><p><strong>基于光源采样</strong></p><ul><li><strong>原理</strong>：直接在光源表面采样，计算从光源到着色点的光线贡献。</li><li><strong>优点</strong>：不会错过光源，因为采样点直接在光源上，确保了光源的贡献能够被计算。</li><li><strong>假设</strong>：先不考虑光源和着色点之间有物体阻挡的情况，光源被视为一个矩形表面。</li></ul><p>先不考虑光源和着色点之间有物体阻挡这种情况，把光源视为一个矩形表面，直接在光源上采样，就不会发生这种浪费</p><h3 id="改写蒙特卡洛积分"><a href="#改写蒙特卡洛积分" class="headerlink" title="改写蒙特卡洛积分"></a>改写蒙特卡洛积分</h3><p>在基于光源采样的情况下，蒙特卡洛积分的公式需要改写。原本的积分是基于着色点的随机采样，现在改为在光源上采样。</p><p><img src="/assets/GAMES101/image-20250425172645-r3b2uc3.png" alt="">​</p><p>光源贡献的公式可以表示为：</p><p><img src="/assets/GAMES101/image-20250425172446-5b9bm41.png" alt="">​</p><p>对于非光源的贡献，仍然使用传统的路径追踪方法</p><p><img src="/assets/GAMES101/image-20250425172426-55bj1wm.png" alt="">​</p><h3 id="整体思路总结"><a href="#整体思路总结" class="headerlink" title="整体思路总结"></a><strong>整体思路总结</strong></h3><p>路径追踪的整体思路可以概括为以下步骤：</p><ol><li><strong>像素采样</strong>：从每个像素出发，生成多条光线（根据SPP）。</li><li><strong>确定着色点</strong>：追踪这些光线，找到它们与场景的交点（着色点）。</li><li><strong>光源采样</strong>：对于每个着色点，直接在光源上采样，计算光源的贡献。</li><li><strong>非光源贡献</strong>：对于非光源部分，使用传统的路径追踪方法计算。</li><li><strong>合并结果</strong>：将光源贡献和非光源贡献合并，得到最终的着色结果。</li><li><strong>返回像素值</strong>：将计算结果返回给像素，完成渲染。</li></ol><h3 id="考虑遮挡"><a href="#考虑遮挡" class="headerlink" title="考虑遮挡"></a><strong>考虑遮挡</strong></h3><p>在实际应用中，还需要考虑光源和着色点之间可能有物体阻挡的情况。这可以通过以下方式实现：</p><ul><li>在计算光源贡献时，检查从光源点 xs 到着色点 x 的路径是否被遮挡。</li><li>如果被遮挡，则忽略该光源点的贡献。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>基于光源采样</strong>：直接在光源上采样，避免了采样率低时错过光源的问题。</li><li><strong>改写蒙特卡洛公式</strong>：将积分从着色点转移到光源上。</li><li><strong>考虑遮挡</strong>：在计算光源贡献时，检查路径是否被遮挡。</li><li><strong>路径追踪的整体思路</strong>：从像素采样到着色点计算，再到光源采样和非光源贡献的合并，最终返回像素值。</li></ul><p>下图是真实光线和路径追踪的比较</p><p><img src="/assets/GAMES101/image-20240210174353-rqfkiej.png" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/av756164342/?vd_source=fa868a89c47131bf7faa4e6af78a3a9e">【RTX光线追踪-2】细说光栅化与光线追踪的区别_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
      <category>GAMES101</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05 Geometry</title>
    <link href="/2025/01/06/GAMES101/05%20Geometry/"/>
    <url>/2025/01/06/GAMES101/05%20Geometry/</url>
    
    <content type="html"><![CDATA[<h1 id="05-Geometry"><a href="#05-Geometry" class="headerlink" title="05 Geometry"></a>05 Geometry</h1><h2 id="三维几何表示"><a href="#三维几何表示" class="headerlink" title="三维几何表示"></a>三维几何表示</h2><p><strong>隐式几何</strong></p><p>用空间中的满足一定条件的点的集合来表示面，隐式几何不会表示点的具体位置信息，而是告诉我们这些点满足的函数关系</p><p>我们很难看出隐式想表达的形状是什么，但对于判断点的位置关系（在内，在外还是在表面）会很方便</p><p><strong>显式几何</strong></p><p>直接给出点的位置，或者可以进行参数映射；然而想要判断内外时，显式的表达就很难进行表示</p><p><strong>点云</strong></p><p>用空间中一堆点的集合来表示物体，只要点足够密集，就看不到点与点之间的空隙，理论上可以表示任何几何，通常三维扫描得到的结果就是点云（点云可以转变为三角形）</p><p><strong>多边形网格</strong></p><p>或许是目前最为广为流传的三维几何表达方式</p><h2 id="曲线与曲线"><a href="#曲线与曲线" class="headerlink" title="曲线与曲线"></a>曲线与曲线</h2><h3 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a><strong>贝塞尔曲线</strong></h3><p>参考：<a href="https://zhuanlan.zhihu.com/p/688186803">一文全面解析贝塞尔曲线 - 知乎</a></p><p>用一系列给定的控制点来定义一个曲线</p><p>n阶贝塞尔曲线有n+1个控制点</p><p><strong>2阶贝塞尔曲线如下：</strong></p><p><img src="/assets/GAMES101/image-20250427144017-l3qhqml.png" alt="">​</p><p><strong>3阶贝塞尔曲线如下：</strong></p><p><img src="/assets/GAMES101/image-20250427144100-ux89kb9.png" alt="">​</p><p><strong>性质：</strong></p><ul><li>过起点终点，起始切线方向为前两个点连接的方向，终止切线方向为结尾两个点连接的方向</li><li>在仿射变换下，只需要对顶点做仿射变换，就能得到这个贝塞尔曲线在仿射变换下的结果</li></ul><p><strong>凸包性质：</strong> 贝塞尔曲线始终会在包含了所有控制点的最小凸多边形中，而不是按照控制点的顺序围成的最小多边形</p><p><strong>逐段贝塞尔曲线</strong>将一个完整的曲线划分为多段贝塞尔曲线，一般每段贝塞尔曲线用四个点来控制</p><p><img src="/assets/GAMES101/image-20240210173834-qvaoud6.png" alt="">​</p><h3 id="B样条曲线"><a href="#B样条曲线" class="headerlink" title="B样条曲线"></a><strong>B样条曲线</strong></h3><p>贝塞尔曲线适合表示简单的曲线，但对于更复杂的曲线来说，由于贝塞尔曲线连续性较差，拼接多段贝塞尔曲线时，需要特别设置控制点以保证连续性。</p><p>B样条曲线的优势：</p><ul><li>B样条曲线的局部性使得修改曲线的局部形状更加方便。</li><li>B样条曲线可以很容易地实现高阶连续性，这对于创建平滑的曲线和曲面非常重要。</li><li>B样条曲线可以通过调整控制点和节点向量实现更复杂的曲线形状。</li></ul><p>具体有点复杂，没讲</p><h3 id="贝塞尔曲面"><a href="#贝塞尔曲面" class="headerlink" title="贝塞尔曲面"></a><strong>贝塞尔曲面</strong></h3><p>u方向上画出四条贝塞尔曲线后，在这四个线上再取四个点，并认为这是个点是一组新的贝塞尔曲线的控制点，这些点在空间内向v方向扫描，便形成了贝塞尔曲面</p><p><img src="/assets/GAMES101/image-20250427144228-jyg5np9.png" alt="">​​​</p><p>如上图，蓝色的线滑动，就形成了相应曲面</p><p>更复杂的问题，比如不同贝塞尔曲面之间的无缝衔接，没有讲</p><h2 id="曲面细分与简化"><a href="#曲面细分与简化" class="headerlink" title="曲面细分与简化"></a>曲面细分与简化</h2><h3 id="曲面细分（网格细分）"><a href="#曲面细分（网格细分）" class="headerlink" title="曲面细分（网格细分）"></a><strong>曲面细分（网格细分）</strong></h3><p>Mesh Subdivision</p><p>将一个网格，细分为多个网格，增加面数，使得模型更加光滑</p><p><strong>Loop细分（算法创始人的名字叫Loop）</strong></p><ul><li>连接各边中点，并重新改变各个顶点位置，从而创造出更多三角形面，使得表面更加光滑</li></ul><p><strong>Catmull-Clark 细分</strong></p><ul><li>loop细分只适用于三角形网格，而对于非三角形网格的细分，就需要借助catmull-clark算法</li><li>catmull-clark算法定义，面分为两种——四边形面和非四边面，点也分两种——度为4的奇异点和其余的非奇异点（度为4意思是该点相连的边数为4）</li></ul><blockquote><p>具体做法：</p><ul><li>对每个非四边面都取其中的一个点（重心或者其他点），将其与该面的边的中点相连，</li><li>在这个过程中，会引入一个新的奇异点，但是在第一次细分以后，所有的非四边面都变为了四边形面</li><li>接着我们进行后续的细分，直到曲面细分到符合我们的要求，后续的细分将不会引入新的奇异点</li></ul></blockquote><h3 id="网格简化"><a href="#网格简化" class="headerlink" title="网格简化"></a><strong>网格简化</strong></h3><p>Mesh Simplication</p><p><strong>边坍缩</strong></p><p>可以这样想象，边坍缩就是将一条边的两个端点靠近到一起，在这个过程中，这条边邻接的面会坍缩成边</p><p>二次误差度量：坍缩后的点和原本几个边（面）的距离的平方和最小</p><p><img src="/assets/GAMES101/image-20240210173834-upft5c2.png" alt="">​</p><p>如上图，五个顶点简化为三个顶点，用蓝色的点来代替三个顶点，使得替代后的三角形和原来的五边形近似。</p><p>我们就可以采用二次度量误差的方法，计算蓝色顶点的最优位置，使得蓝色顶点到原来各条边距离平方和值最小</p><p>二次度量误差要更新</p><p>需要注意的是，对一条边做一次坍缩后，其他边也跟着变了，他们对应的二次误差必须被重新计算</p><p>所以需要从二次度量误差中选最小的，取完最小的之后，我们要对它们的二次误差做一次更新，我们要用到优先队列 / 堆这种数据结构，这种数据结构能让我们能取得二次误差最小值的同时也能动态更新其他受影响的元素</p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
      <category>GAMES101</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04 Shading</title>
    <link href="/2025/01/06/GAMES101/04%20Shading/"/>
    <url>/2025/01/06/GAMES101/04%20Shading/</url>
    
    <content type="html"><![CDATA[<h1 id="04-Shading"><a href="#04-Shading" class="headerlink" title="04 Shading"></a>04 Shading</h1><h2 id="Blinn-Phong光照模型"><a href="#Blinn-Phong光照模型" class="headerlink" title="Blinn-Phong光照模型"></a>Blinn-Phong光照模型</h2><p><strong>着色</strong>：对不同的物体应用不同材质的过程</p><p>对于某一点，只考虑光线方向和观测方向，不考虑光源是否被其他物体遮挡，也就是说，不考虑这一点在其他物体的阴影内的情况。</p><p><strong>某一点的光照 = 漫反射 + 高光 + 环境光</strong></p><h3 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a><strong>漫反射</strong></h3><p>首先，同样的光，照射到物体表面上，依据入射角度的不同，获得的能量有区别，因而导致了明暗的不同。</p><p>其次，对于一个点光源，我们认为，某个时刻传播出的能量是不变的。如下图，每次传播形成的球壳的总能量不变，但是随着时间推移，球壳的大小越来越大。于是，单位面积接收到的光源的能量与到光源的距离成平方反比。</p><p><img src="/assets/GAMES101/image-20250427133738-0lze640.png" alt=""></p><p>于是，我们可以得到单个点光源照射下，某个点的总漫反射的强度</p><p>$L_d = K_d \left( \frac{I}{r^2} \right) \max(0, \mathbf{n} \cdot \mathbf{l})$</p><ul><li><strong>I</strong>：表示单位距离的光源能量</li><li>$K_d$表示该着色点的光吸收率</li><li><strong>n</strong>：表示法线方向的单位向量</li><li><strong>l</strong>：表示光源方向的单位向量</li></ul><h3 id="高光"><a href="#高光" class="headerlink" title="高光"></a><strong>高光</strong></h3><p>比较光滑的表面，其入射光的反射方向接近镜面反射方向。</p><p>观测方向越接近反射光的方向，等价于观测向量和入射向量相加得到的半程向量和法线向量夹角越小。</p><p><img src="/assets/GAMES101/image-20240210172031-bbkqtdw.png" alt=""></p><ul><li>$k_s$表示表示镜面反射系数。​</li><li>这里没有考虑入射光和表面因为夹角，导致部分能量未被吸收的问题，漫反射项中考虑了。</li><li>指数p是为了强化夹角余弦的差异，凸显夹角的影响。所以p可以控制高光的大小，p越大，高光越小。</li></ul><h3 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a><strong>环境光</strong></h3><p>假设任何一点接收到环境光的大小都相同，是常数。</p><p><img src="/assets/GAMES101/image-20240210172031-9nff5mt.png" alt="">​</p><h2 id="着色频率"><a href="#着色频率" class="headerlink" title="着色频率"></a>着色频率</h2><p>Shading Frequencies</p><h3 id="着色方式"><a href="#着色方式" class="headerlink" title="着色方式"></a>着色方式</h3><p><strong>Flat Shading（平面着色）</strong></p><pre><code class="hljs">以三角面为单位进行着色，借助于平面的法线进行运算。对于光滑的几何体效果很差</code></pre><p><strong>Gouraud Shading（高洛德着色）</strong></p><pre><code class="hljs">以三角形的顶点为单位进行着色，在三角形内部，通过顶点的颜色进行插值计算，实现点与点之间颜色的平滑过渡</code></pre><p><strong>Phone Shading（冯氏着色）</strong></p><pre><code class="hljs">以像素为单位进行着色，点的法向量是通过顶点法向量插值得到的，冯氏着色最接近现实，可以在减少三角面数的情况下达到相同的效果（插值后法向量会光滑变化），当然，性能开销也非常大</code></pre><h3 id="法线计算"><a href="#法线计算" class="headerlink" title="法线计算"></a>法线计算</h3><p><strong>顶点的法线计算：</strong></p><pre><code class="hljs">一般是该顶点相邻面上的法线求平均，也可以是按照相邻面的面积求加权平均</code></pre><p><img src="/assets/GAMES101/image-20240210172031-suuwzs4.png" alt="">​</p><p><strong>像素法线的计算：</strong></p><pre><code class="hljs">利用顶点的属性（法线，颜色）来对三角形内部的像素点进行插值，都使用同样的方法。</code></pre><h3 id="三角形的重心坐标"><a href="#三角形的重心坐标" class="headerlink" title="三角形的重心坐标"></a><strong>三角形的重心坐标</strong></h3><p>对于三角形所在平面上的任意一点坐标，都可以用三角形的三个顶点坐标的线性组合来表示</p><p>$(x,y) = aA + bB + cC$</p><p>当满足$a + b + c = 1$时，称$(a,b,c)为该点的重心坐标$</p><ul><li>如果a,b,c均在0到1之间，则该点是三角形内部的点</li><li>顶点的属性插值，就是借助于重心坐标来对三个顶点的属性进行加权求和。</li><li>注意：在三维空间投影到二维空间时，投影前后的重心坐标会改变，所以要应用逆变换在三维空间中进行插值，再投影回去。</li></ul><h2 id="图形管线"><a href="#图形管线" class="headerlink" title="图形管线"></a>图形管线</h2><p>Graphics Pipline</p><p><img src="/assets/GAMES101/image-20240210172031-lix35k8.png" alt="">​</p><h2 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h2><p>Texture  Mapping</p><p><strong>纹理映射</strong>是将纹理空间中的纹理像素映射到屏幕空间中的像素的过程</p><p>三维图形的每个三角面顶点都可以对应一个<strong>uv坐标系下的坐标</strong>，uv坐标范围约定在[0,1]之间，至于三角形中的点的uv坐标，可以通过插值计算出来。</p><p><strong>可复用纹理：</strong> 纹理本身可以被设计为无缝衔接（tilable）</p><h3 id="纹理过小"><a href="#纹理过小" class="headerlink" title="纹理过小"></a><strong>纹理过小</strong></h3><p>屏幕的pixel太高，纹理的texel太小，多个pixel映射到了同一个texel</p><p><img src="/assets/GAMES101/image-20250427135327-97fo2qn.png" alt="">​</p><ul><li><strong>Nearest：</strong> 直接四舍五入</li><li><strong>Bilinear</strong>：考虑这个pixel周围的4个texel，应用双线性插值</li></ul><p><img src="/assets/GAMES101/image-20250427135420-zgl99kz.png" alt="">​</p><ul><li><strong>BiCubic：</strong> 考虑这个pixel周围的16个texel，应用双三次插值</li></ul><p><img src="/assets/GAMES101/image-20250427135439-0yun1fd.png" alt="">​</p><p>如上图，红点是pixel，黑点是texel，pixel没有直接对应的texel。Nearest就是找最近的texel，但是这样会导致不够平滑，锯齿严重。BiCubic效果要比Bilinear更好，但更耗费性能。</p><h3 id="纹理过大"><a href="#纹理过大" class="headerlink" title="纹理过大"></a><strong>纹理过大</strong></h3><p>屏幕的pixel太小，纹理的texel太大，特别是看向远处的时候，一个pixel映射到了多个texel，这时候因采样频率不足而导致摩尔纹+锯齿（走样）</p><p>我们可以用上面提到的超采样方法进行范围查询，比如一个pixel对应的是512个texel的区域，我们可以对这些texel进行加权，但是这样性能要求高，我们可以采用Mipmap算法</p><p><strong>Mipmap算法</strong></p><p>事先准备多张不同级别（D）的纹理贴图，每升一个级别，横纵纹素各减小一半，最后显存消耗仅为原来的4/3</p><p><img src="/assets/GAMES101/image-20250427135632-xhedd9i.png" alt="">​</p><p>如此分级之后，设屏幕空间下采样像素与相邻像素中心点之间的距离为L，在u-v坐标系找到这些像素的中心点对应的坐标</p><p><img src="/assets/GAMES101/image-20240210172031-m52rv43.png" alt="">​</p><p>如上图，左侧为屏幕空间，右侧为纹理空间。红色的点即是屏幕空间中的点在纹理空间中的对应。我们通过对这个点和相邻点连线的垂直平分线，可以获得一个粉色的多边形区域。接着用一个正方形框来近似这个多边形区域，这个正方形区域就是pixel对应的覆盖区域，根据这个区域的大小，选择相应的层数进行查询，如果没有合适的层数，进行三线性插值即可。</p><p>但是，Mipmap算法只能在u-v坐标系下做正方形块的查询，有时候会造成过度模糊的情况，为了避免这种情况，引入各向异性过滤</p><p><strong>各向异性过滤</strong></p><p>在准备不同级别的纹理贴图时，不再是简简单单横纵纹素各减小一半进行分级，而是长减半宽不变 or 宽减半长不变  or 长和宽各减半三种情况各进行一次分级，显存消耗为原来的三倍，但性能方面并没有多少影响，这种方法就可以实现在u-v坐标系下进行矩形查询。</p><p><img src="/assets/GAMES101/image-20240210172031-tldxvh1.png" alt="">​</p><p>在显存足够的情况下，各向异性过滤级别开越高越好</p><h2 id="贴图"><a href="#贴图" class="headerlink" title="贴图"></a>贴图</h2><p><strong>环境光贴图</strong></p><ul><li>假设光源无限远，只记录光照的方向信息，这种贴图被称作环境光贴图</li></ul><p><strong>球面环境映射 Spherical  Environment Map</strong></p><ul><li>球心为世界中心。类比地球仪展开铺平，存在纹理的拉升扭曲问题，解决d方法：Cube Map</li></ul><p><strong>立方体贴图 Cube Map</strong></p><ul><li>将环境光照信息记录在一个立方体表面上，但会需要额外判断某一方向上的光照应该记录在立方体的哪个面上，计算量更大</li></ul><p><strong>凹凸贴图（法线贴图）（Bump mapping）</strong></p><ul><li>记录了纹理的高度移动，并不改变原来模型的几何信息，通过法线扰动，得到模拟出来的着色效果，以假乱真</li></ul><p><strong>位移贴图（Displacement mapping）</strong></p><ul><li>与凹凸贴图类似，但位移贴图是真的改变了几何信息，对模型的顶点做位移，比凹凸贴图更加逼真，但是对模型的精度（三角面数量）要求更高，并且运算量也会随之上升</li></ul><p><img src="/assets/GAMES101/image-20240210172031-ly8od2j.png" alt="">​</p><p><strong>程序纹理</strong></p><ul><li>三维的纹理，并非真正生成了纹理的图，而是定义空间中任意点的颜色，具体来说，就是定义三维空间中的噪声函数，再通过映射，得到预想的效果</li></ul><p><strong>预计算着色</strong></p><ul><li>将环境光进行预计算处理，附在原先纹理上，这样使用了纹理的模型看起来就有阴影。</li></ul><p><strong>三维渲染</strong></p><ul><li>Solid Modeling &amp;. Volume Rendering</li><li>广泛应用于物体渲染，如核磁共振等扫描后得到的体积信息，通过这些信息进行渲染，得到结果。</li><li>我们把这些体积信息当作三维的纹理。</li></ul><h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><p>这一节是在Geometry 3那节课最后部分讲的</p><h3 id="阴影贴图"><a href="#阴影贴图" class="headerlink" title="阴影贴图"></a><strong>阴影贴图</strong></h3><p>Shadow Mapping</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/384446688">图形学基础 - 阴影 - ShadowMap及其延伸 - 知乎</a></p><p>核心思想：如果一个点不在阴影里，那么这个点可以被摄像机和光源都看到</p><p>具体实现：</p><p><img src="/assets/GAMES101/image-20250425112904-4yktztk.png" alt="">​</p><p>黄色区域为点光源光照示意范围，绿色区域为相机视锥体范围，很明显，红线处是阴影部分，实际操作时怎样确定这个红线位置呢？有以下步骤：</p><p>1） 第一次 pass，生成阴影贴图。</p><p>将相机放在光源位置，用 z-buffer 的方式存一张深度缓冲，称之为阴影贴图 (Shadow Map)，并记录此时的投影变换矩阵 M，点光源对应透视投影，定向光对应正交投影</p><p>2） 第二次 pass，正式渲染场景。</p><p>将相机放到“人眼”的位置，考察每个片元处是否处于阴影。方法为：用第一次 pass 里面的矩阵 M 将三维点 $(P_x,P_y,P_z)$ 变换为二维坐标 $(p_x,p_y)$ 和深度 $p_z$ ，将 $p_z$ 与第一次 pass 存下来的阴影贴图对应点的深度 $c(p_x,p_y)$ 进行对比，若 $p_z&gt; c(p_x,p_y)$ ，则认为此片元处于阴影中</p><p>此过程如下图所示：</p><p><img src="/assets/GAMES101/image-20250425112944-c77jp3u.png" alt="">​</p><p>但是存在一些问题：</p><p>1） 点光源应该是各个方向都有光，而上图中表现得更像是聚光灯，如果要实现点光源的效果，一个常用的方法是：<strong>分别朝六个方向生成阴影贴图，然后构成一个立方体贴图</strong></p><p>2） 由于深度的数值精度和阴影贴图分辨率都有限，所以在进行深度比较的时候，有可能会出现 Z-fighting 的现象，所以需要在比较时添加偏差，称之为 Depth Bias</p><p>3） 由于阴影贴图分辨率是有限的，每个像素占据一定大小，并且离光源越远，每个像素覆盖的片元就越多，并且涉及到采样和重采样，那么就可能导致阴影产生锯齿 Aliasing</p><h3 id="硬阴影和软阴影"><a href="#硬阴影和软阴影" class="headerlink" title="硬阴影和软阴影"></a><strong>硬阴影和软阴影</strong></h3><p>区别在于阴影的轮廓是否清晰可见，硬阴影轮廓清晰可见，软阴影轮廓模糊</p><p>如果只有点光源，那么一定是硬阴影</p><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
      <category>GAMES101</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03 Rasterization</title>
    <link href="/2025/01/06/GAMES101/03%20Rasterization/"/>
    <url>/2025/01/06/GAMES101/03%20Rasterization/</url>
    
    <content type="html"><![CDATA[<h1 id="03-Rasterization"><a href="#03-Rasterization" class="headerlink" title="03 Rasterization"></a>03 Rasterization</h1><h2 id="视口变换"><a href="#视口变换" class="headerlink" title="视口变换"></a><strong>视口变换</strong></h2><p>上一节中，已经将物体变换到裁剪空间$[-1,1]^3$中，接下来，需要完成到屏幕空间的映射</p><p>其变换矩阵如下：</p><p>$\mathbf{M_{\text{viewport}}} =  \begin{bmatrix} \frac{\text{width}}{2} &amp; 0 &amp; 0 &amp; \frac{\text{width}}{2} \\ 0 &amp; \frac{\text{height}}{2} &amp; 0 &amp; \frac{\text{height}}{2} \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}$  </p><h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p><strong>光栅化——采样</strong></p><ul><li>屏幕是一个二维数组的标准数据集，是离散的，是一个典型的光栅成像设备。</li><li>经过矩阵变换后，再把屏幕空间中的多边形打散成三角形，成像到屏幕上，这就是光栅化的大致流程</li><li>最简单的光栅化方法是<strong>采样</strong>。具体来说，是看三角形和像素的位置关系，这一步要借助于向量乘法判断。</li></ul><p><strong>采样优化</strong></p><ul><li>光栅化时的，为了显示某个三角形。我们需要判断屏幕上的像素和三角形的位置关系。只有在三角形内部的像素点才会被赋予颜色。</li></ul><p><strong>轴向包围盒（AABB）</strong></p><ul><li>借助于<strong>轴向包围盒</strong>，我们可以在光栅化前先判断像素点是否在三角形所在包围盒内，若不在则直接忽略。</li></ul><p><strong>走样（锯齿）</strong></p><ul><li>由于分辨率的限制，可能出现走样的情况。</li><li>要解决普通的反走样，我们先对原图进行模糊处理，再进行采样，可以一定程度上解决走样问题。</li><li>注意反过来是不可行的</li></ul><p><strong>深度缓存 -Zbuffering</strong></p><ul><li>之前并没有考虑过显示的三角形之间的遮挡关系，为了解决这个问题：</li><li>最简单的想法就是利用画家算法：由远及近画画，近处画面覆盖远处画面。但是，这种算法无法处理复杂的深度判断，例如三个三角形互相重叠，并不适用。</li><li>Zbuffering算法对每个像素多存一个深度，显示的时候，进行比较来更新显示的像素点。实际编程中，z值越小表示越远。</li></ul><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><p><strong>傅里叶级数</strong>：把一个周期函数通过最简单的一系列正弦函数来表示。</p><p>利用<strong>傅里叶变换</strong>和<strong>逆傅里叶变换</strong>，我们可以把一个函数转换为另一个函数。</p><p>不同的正余弦函数都有不同的频率，傅里叶变换可以把一个函数转换为不同频率的正余弦函数之和。</p><p><img src="/assets/GAMES101/image-20250427111630-tnpvql4.png" alt="">​</p><p><strong>走样的原因：</strong></p><ul><li><p>在进行等距采样的时候，越是高频的函数，越容易丢失原始的信息。</p></li><li><p>采样两种截然不同的函数反而可能会得到相同的结果</p></li></ul><h3 id="滤波—傅里叶变换角度"><a href="#滤波—傅里叶变换角度" class="headerlink" title="滤波—傅里叶变换角度"></a><strong>滤波—傅里叶变换角度</strong></h3><p>滤波可以认为是去掉某些频率。</p><p>对于一张图片，我们可以使用傅里叶变换，把这个图像从时域（其实没有时间信息，只有空间信息，只是叫这个）变换为频域。</p><p>一般的图片进行傅里叶变换之后，得到频谱。中间的是低频信息，四周的是高频信息（下图右）。</p><p><img src="/assets/GAMES101/image-20250427111717-m0xi8zm.png" alt="">​</p><p>在图像的边界，也就是颜色变化剧烈的地方，就对应的是高频信息，因此<strong>高通滤波</strong>之后得到的是一个图片边缘。</p><p><img src="/assets/GAMES101/image-20250427111731-ef1pizn.png" alt="">​</p><p>经过低通滤波之后，图片变得模糊​​</p><p><img src="/assets/GAMES101/image-20250427111748-ab9aro8.png" alt="">​</p><h3 id="滤波—卷积角度"><a href="#滤波—卷积角度" class="headerlink" title="滤波—卷积角度"></a><strong>滤波—卷积角度</strong></h3><p>滤波可以看作是一种卷积。</p><p><strong>结论：时域的卷积=频域的乘积。</strong></p><p><img src="/assets/GAMES101/image-20250427111830-cb6ahxp.png" alt="">​</p><h2 id="反走样"><a href="#反走样" class="headerlink" title="反走样"></a>反走样</h2><h3 id="SSAA"><a href="#SSAA" class="headerlink" title="SSAA"></a><strong>SSAA</strong></h3><p><strong>SSAA（Supersampling Anti-Aliasing）</strong> ：一个更大的分辨率来渲染场景，然后再把相邻像素值做一个过滤（比如平均等）得到最终的图像。</p><p>SSAA可以说是图形学中最简单粗暴的反走样方法，但同时也最有效，唯一的缺点是性能太差。</p><p>任何类型的走样归根结底都是因为欠采样，那么我们只需要增加采样数，就可以减轻走样现象。这就是SSAA，所以SSAA简单的来说可以分三步：</p><p>（1）在一个像素内取若干个子采样点</p><p>（2）对子像素点进行颜色计算（采样）</p><p>（3）根据子像素的颜色和位置，利用一个称之为resolve的合成阶段，计算当前像素的最终颜色输出</p><p><img src="/assets/GAMES101/network-asset-v2-940e167efe0b74854cf56082d084fbeb_720w-20250427111943-872wx5e.webp" alt="">​</p><p>SSAA<strong>同时是几何反走样和着色反走样方法</strong>，因为它不但增加了当前几何覆盖函数（Coverage）的采样率，也对渲染方程进行了更高频率的采样（单独计算每个子像素的颜色）。</p><h3 id="MSAA"><a href="#MSAA" class="headerlink" title="MSAA"></a><strong>MSAA</strong></h3><p>由于SSAA在光栅化阶段和片元着色阶段都需要大量的额外计算，开销巨大</p><p><strong>MSAA（Multisample Anti-Aliasing）</strong> 则只在<strong>光栅化阶段</strong>，判断一个三角形是否被像素覆盖的时候会计算多个覆盖样本（Coverage sample），但是在pixel shader着色阶段计算像素颜色的时候每个像素还是只计算一次。</p><p>例如下图是4xMSAA，三角形只覆盖了4个coverage sample中的2个。所以这个三角形需要生成一个fragment在pixel shader里着色，只不过生成的fragment还是在像素中央（位置，法线等信息插值到像素中央）然后只运行一次pixel shader，最后得到的结果在resolve阶段会乘以0.5，因为这个三角形只cover了一半的sample。</p><p><img src="/assets/GAMES101/image-20250425112057-v5miayu.png" alt="">​</p><p>现代所有GPU都在硬件上实现了这个算法，而且在shading的运算量远大于光栅化的今天，这个方法远比SSAA快很多。顺便提一下之前NV的CSAA，它就是更进一步的把coverage sample和depth，stencil test分开了。</p><p>由于MSAA拥有硬件支持，相对开销比较小，又能很好地解决几何走样问题，在游戏中应用非常广泛（我们在游戏画质选项中常看到的4x/8x/16x抗锯齿一般说的就是MSAA的子采样点数量分别为4/8/16个）。</p><p>MSAA的一个问题就是和延迟渲染并不兼容。延迟渲染的核心是GBuffer（几何缓冲区），它在渲染的第一阶段将颜色、深度、法线等信息存储到多个纹理中。然而，MSAA需要在光栅化阶段对几何信息进行采样，而延迟渲染在光照计算阶段已经丢失了这些几何信息。例如，GBuffer中的深度和法线信息是逐像素存储的，无法直接用于MSAA的子采样处理</p><p>因为MSAA这个问题现代引擎里都用的是Post Processing AA这一类技术。这一类东西包括FXAA，TAA等，不依赖于任何硬件，完全用图像处理的方法来搞。</p><h3 id="FXAA"><a href="#FXAA" class="headerlink" title="FXAA"></a><strong>FXAA</strong></h3><p>FXAA 是由 NVDIA 发明的高效后处理抗锯齿方案，也是目前所有后处理抗锯齿方案里面同等设置下效率最高的抗锯齿算法</p><p>原理：找到边界，换成没有锯齿的边界，（图像匹配）非常快</p><p>方法和采样无关，采样虽然有误，但是这种方法可以弥补</p><h3 id="TAA"><a href="#TAA" class="headerlink" title="TAA"></a><strong>TAA</strong></h3><p>原理：利用时序信息，借助前面帧提供的信息</p><p>静态场景，相邻两帧同一像素用不同的位置来sample</p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
      <category>GAMES101</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02 Transformation</title>
    <link href="/2025/01/06/GAMES101/02%20Transformation/"/>
    <url>/2025/01/06/GAMES101/02%20Transformation/</url>
    
    <content type="html"><![CDATA[<h1 id="02-Transformation"><a href="#02-Transformation" class="headerlink" title="02 Transformation"></a>02 Transformation</h1><h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a><strong>线性变换</strong></h3><p><img src="/assets/GAMES101/image-20250426163007-sp0lgum.png" alt="">​</p><p><img src="/assets/GAMES101/image-20250426162951-fx7kn44.png" alt="">​</p><p><img src="/assets/GAMES101/image-20250426163020-6j7ui9a.png" alt=""><img src="/assets/GAMES101/image-20250426163034-1pf7g1s.png" alt="">​</p><h3 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a><strong>齐次坐标</strong></h3><p><strong>缩放</strong>，<strong>对称</strong>，<strong>切变</strong>，<strong>旋转</strong>，都是线性变换。但是<strong>平移变换</strong>不是线性变换，不能写成如上形式。</p><p>为了统一上面的五种变换方式，我们引入齐次坐标的概念。</p><p>用N+1维向量来表示N维坐标，用向量的最后一位数来指明是点还是向量（1表示点，0表示向量）。</p><p>对于二维坐标系来说：</p><ul><li>二维点 $(x, y, 1)^T$</li><li>二维向量 $(x, y, 0)^T$</li></ul><p>矩阵的变换可以表示为：</p><p>$\begin{pmatrix} x’ \\ y’ \\ w’ \end{pmatrix} = \begin{pmatrix} 1 &amp; 0 &amp; t_x \\ 0 &amp; 1 &amp; t_y \\ 0 &amp; 0 &amp; 1 \end{pmatrix} \cdot \begin{pmatrix} x \\ y \\ 1 \end{pmatrix} = \begin{pmatrix} x + t_x \\ y + t_y \\ 1 \end{pmatrix}$  </p><p>这样的话，我们可以表示平移。同时通过1或者0也能轻易分辨点还是向量。</p><p>在这种情况下，有如下运算：</p><ul><li>点 + 点 = 点（表示两点的中点）</li><li>点 + 向量 = 点（表示点沿着某个向量移动）</li><li>向量 + 向量 = 向量</li><li>点 - 点 = 两点构成的向量</li></ul><p>此外，在齐次坐标中，$\begin{pmatrix} x \\ y \\ w \end{pmatrix} = \begin{pmatrix} x/ \\ y/w \\ 1 \end{pmatrix} $</p><p><strong>齐次坐标的二维变换</strong>如下：</p><p><img src="/assets/GAMES101/image-20250426203826-dzpfsii.png" alt=""></p><h3 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h3><p><img src="/assets/GAMES101/image-20250426203942-wj9m0q6.png" alt="">​​​</p><ul><li>通常的旋转操作是绕坐标原点进行的。</li><li>旋转矩阵的逆 = 旋转矩阵的转置。</li></ul><h3 id="复杂变换"><a href="#复杂变换" class="headerlink" title="复杂变换"></a><strong>复杂变换</strong></h3><p>复杂的变换可以拆分为多个简单变换的组合。一个符合条件的操作矩阵可以拆分为多个操作矩阵的乘积。</p><p>对向量或者点进行复杂变换时，对应的操作矩阵都是左乘运算。</p><p><strong>矩阵的乘法不满足交换律</strong>：按照同样的数值，先平移再旋转和先旋转再平移，得到的结果很可能不一样。这也符合矩阵的乘法。</p><p><strong>矩阵的乘法满足结合律</strong>：我们可以先将操作矩阵乘起来，最终合成为一个操作矩阵。</p><h3 id="三维变换"><a href="#三维变换" class="headerlink" title="三维变换"></a><strong>三维变换</strong></h3><p><strong>平移变换</strong></p><p>$T(t_x, t_y, t_z) = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; t_x \\ 0 &amp; 1 &amp; 0 &amp; t_y \\ 0 &amp; 0 &amp; 1 &amp; t_z \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}$  </p><p><strong>缩放变换与反射变换矩阵</strong></p><p>$S(s_x, s_y, s_z) = \begin{bmatrix} s_x &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; s_y &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; s_z &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}$  </p><p><strong>旋转变换</strong></p><p>$R_x(\alpha) = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; \cos \alpha &amp; -\sin \alpha &amp; 0 \\ 0 &amp; \sin \alpha &amp; \cos \alpha &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \\ R_y(\alpha) = \begin{bmatrix} \cos \alpha &amp; 0 &amp; \sin \alpha &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ -\sin \alpha &amp; 0 &amp; \cos \alpha &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \\ R_z(\alpha) = \begin{bmatrix} \cos \alpha &amp; -\sin \alpha &amp; 0 &amp; 0 \\ \sin \alpha &amp; \cos \alpha &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}$  </p><p>上面的旋转公式是绕坐标轴旋转，当绕任意轴旋转时：</p><ul><li>如果这个轴的起点在原点，可使用罗德里格斯公式：<a href="https://zhuanlan.zhihu.com/p/113299607?utm_source=qq&amp;utm_medium=social&amp;utm_oi=605668290971045888">罗德里格斯公式Rodrigues&apos;Rotation Formula推导 - 知乎 (zhihu.com)</a></li></ul><p><img src="/assets/GAMES101/image-20240210002829-8volfwb.png" alt="">​</p><ul><li>如果这个轴的起点不在原点，先整体平移到原点，旋转之后再平移回去</li></ul><h2 id="MVP变换"><a href="#MVP变换" class="headerlink" title="MVP变换"></a>MVP变换</h2><h3 id="模型变换"><a href="#模型变换" class="headerlink" title="模型变换"></a><strong>模型变换</strong></h3><p><strong>Model Transformation</strong></p><p>将每个模型的的顶点坐标从局部坐标系变换到世界坐标系</p><h3 id="视图-相机变换"><a href="#视图-相机变换" class="headerlink" title="视图/相机变换"></a><strong>视图/相机变换</strong></h3><p><strong>View Transformation/Camera Transformation</strong></p><p>在场景中放置相机。我们规定摄相机的位置始终处于原点，向上的方向是y轴，看向-z轴。这样一来，我们定义好了相机的属性，即位置，垂直方向，视线方向。</p><p>视图变换则是将世界坐标系转换到摄像机坐标系</p><p>如果摄相机的属性不符合我们的定义，我们可以通过平移变换和旋转变换，将摄像机变换到初始位置。此时，其他所有的物体也应该进行同样的变换以保证相对位置不变。</p><p><img src="/assets/GAMES101/image-20250426205133-s870v7a.png" alt=""></p><h3 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a><strong>投影变换</strong></h3><p><strong>Projection Transformation</strong></p><p>有两种投影变换：<strong>正交投影（orthographic projection）</strong> 与<strong>透视投影（perspective projection）</strong> 。</p><p><img src="/assets/GAMES101/image-20240210155445-2vwldf2.png" alt="">​</p><p><strong>正交投影：</strong> 看向物体时将所有物体的z值归0，然后将物体平移并缩放到 [-1,1]^2之间。相机位置无限远，没有远近概念（忽略深度信息）。</p><p><img src="/assets/GAMES101/image-20240210160421-gvtc46j.png" alt=""></p><p>这个原始的立方体可以视作我们规定的可视范围，分别代表屏幕的长度，宽度，深度。我们通过变换矩阵将给定的立方体变换到[-1,1]^3的标准立方体上，只需先平移，再缩放。</p><p><strong>透视投影：</strong> 把视锥体压缩成一个长方体，能够体现近大远小的视觉特点。</p><p><img src="/assets/GAMES101/image-20250426205433-4ivean7.png" alt="">​</p><p>我们希望对视锥体中的每一个点，乘以一个变换矩阵，即可将其变换为长方体中的点。除此之外，我们还规定，变换前后，远平面和近平面上的点的z轴不变。</p><p>经过推导可以得到变换矩阵：<a href="https://zhuanlan.zhihu.com/p/122411512?utm_source=qq&amp;utm_medium=social&amp;utm_oi=605668290971045888">[图形学笔记]推导投影矩阵 - 知乎 (zhihu.com)</a></p><p>通过这个矩阵，我们可以把原来的透视投影的视锥体压缩为正交投影的视锥体(长方体)。</p><p>最后我们再乘上一开始求出来正交投影矩阵Morth就得到了透视投影矩阵</p><p>此外，视锥体压缩成长方体以后，内部的点的z值更偏向于远平面</p><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
      <category>GAMES101</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01 Review of Linear Algebra</title>
    <link href="/2025/01/06/GAMES101/01%20Review%20of%20LInear%20Algebra/"/>
    <url>/2025/01/06/GAMES101/01%20Review%20of%20LInear%20Algebra/</url>
    
    <content type="html"><![CDATA[<h1 id="01-Review-of-Linear-Algebra"><a href="#01-Review-of-Linear-Algebra" class="headerlink" title="01 Review of Linear Algebra"></a>01 Review of Linear Algebra</h1><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>图形学依赖于：</p><ul><li><strong>基础数学</strong>：线性代数，微积分，统计</li><li><strong>基础物理学</strong>：光学，力学</li><li><strong>其他</strong>：信号处理，数值分析</li><li>一点<strong>美学</strong></li></ul><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><h3 id="向量的概念"><a href="#向量的概念" class="headerlink" title="向量的概念"></a>向量的概念</h3><p><img src="/assets/GAMES101/image-20250426154925-rfussos.png" alt="">​</p><ul><li>通常写作 $\vec{a}$ 或 $\mathbf{a}$</li><li>或者使用起点和终点来表示 $\vec{AB} = B - A$</li><li>有方向和长度</li><li>没有特定的起点</li></ul><h4 id="向量的归一化"><a href="#向量的归一化" class="headerlink" title="向量的归一化"></a>向量的归一化</h4><ul><li>向量的长度可以表示为 $|\vec{a}|$</li><li><p>单位向量</p><ul><li>向量的模长为1</li><li>向量的归一化：$\hat{a} =  \vec{a}/|\vec{a}|$</li><li>用来表示方向</li></ul></li></ul><h4 id="向量加法"><a href="#向量加法" class="headerlink" title="向量加法"></a>向量加法</h4><p><img src="/assets/GAMES101/image-20250426154948-vmdqm55.png" alt="">​</p><ul><li>几何上：平行四边形定理和三角形定理</li><li>代数上：简单的坐标相加</li></ul><h4 id="笛卡尔坐标系"><a href="#笛卡尔坐标系" class="headerlink" title="笛卡尔坐标系"></a>笛卡尔坐标系</h4><p><img src="/assets/GAMES101/image-20250426154351-u77v3qn.png" alt="">​</p><ul><li>X和Y是正交的单位向量</li><li>任一向量都可以用X和Y来表示</li></ul><h3 id="向量的点乘"><a href="#向量的点乘" class="headerlink" title="向量的点乘"></a>向量的点乘</h3><p><img src="/assets/GAMES101/image-20250426154430-4pfcdjd.png" alt="">​</p><p>$\vec{a} \cdot \vec{b} = |\vec{a}| |\vec{b}| \cos \theta$  </p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a><strong>性质</strong></h4><ul><li>交换律：$\vec{a}\cdot\vec{b}=\vec{b}\cdot\vec{a}$</li><li>分配律：$\vec{a}\cdot(\vec{b}+\vec{c})=\vec{a}\cdot\vec{b}+\vec{a}\cdot\vec{c}$</li><li>结合律：$(k\vec{a})\cdot\vec{b}=\vec{a}\cdot(k\vec{b})=k(\vec{a}\cdot\vec{b})$</li></ul><h4 id="笛卡尔坐标系下的点乘"><a href="#笛卡尔坐标系下的点乘" class="headerlink" title="笛卡尔坐标系下的点乘"></a><strong>笛卡尔坐标系下的点乘</strong></h4><p>逐分量相乘后求和</p><ul><li><p>2D</p><p>$\vec{a} \cdot \vec{b} =  \begin{pmatrix} x_a \\ y_a\\ \end{pmatrix} \cdot \begin{pmatrix} x_b \\ y_b\\ \end{pmatrix}  = x_ax_b + y_ay_b$</p></li><li><p>3D</p><p>$\vec{a} \cdot \vec{b} =  \begin{pmatrix} x_a \\ y_a\\ z_a \end{pmatrix} \cdot \begin{pmatrix} x_b \\ y_b\\ z_b \end{pmatrix}  = x_ax_b + y_ay_b + z_az_b$</p></li></ul><h4 id="图形学中的点乘"><a href="#图形学中的点乘" class="headerlink" title="图形学中的点乘"></a><strong>图形学中的点乘</strong></h4><p>求出两个向量间的角度</p><ul><li><p>衡量两个向量靠近的情况</p><p><img src="/assets/GAMES101/image-20250426155759-j30w032.png" alt="">​</p></li><li><p>分解向量</p><p><img src="/assets/GAMES101/image-20250426155813-v12qnog.png" alt="">​</p></li><li><p>判断向前或向后的方向</p><p><img src="/assets/GAMES101/image-20250426155825-whku10i.png" alt="">​</p></li><li><p>找到一个向量在另一个向量上的投影</p><p><img src="/assets/GAMES101/image-20250426155842-p724wzm.png" alt="">​</p></li></ul><h3 id="向量的叉乘"><a href="#向量的叉乘" class="headerlink" title="向量的叉乘"></a>向量的叉乘</h3><p><img src="/assets/GAMES101/image-20250424150904-fc08dha.png" alt="">​</p><ul><li><strong>正交性</strong>：叉乘结果向量与两个初始向量都垂直。</li><li><strong>方向确定</strong>：叉乘结果向量的方向由右手定则确定。</li><li><strong>坐标系构建</strong>：叉乘在后续构建坐标系时非常有用。</li></ul><h4 id="叉乘公式"><a href="#叉乘公式" class="headerlink" title="叉乘公式"></a><strong>叉乘公式</strong></h4><p>$a \times b = \begin{pmatrix} y_az_b - y_bz_a\\\\ z_ax_b - x_az_b\\\\ x_ay_b-y_ax_b \end{pmatrix}$  </p><p>$\vec{a} \times \vec{b} = A * b =  \begin{pmatrix} 0 &amp; -z_a &amp; y_a \\\ z_a &amp; 0 &amp;-x_a \\\ -y_a &amp; x_a &amp; 0 \\ \end{pmatrix} \begin{pmatrix} x_b\\\\ y_b\\\\ z_b\\\\ \end{pmatrix}$  </p><h4 id="图形学中的叉乘"><a href="#图形学中的叉乘" class="headerlink" title="图形学中的叉乘"></a>图形学中的叉乘</h4><p><img src="/assets/GAMES101/image-20250426160012-fi424hl.png" alt="">​</p><ul><li>判定左和右</li><li>判定内与外</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在实际应用中，会存在多个坐标系统，例如：</p><ul><li>全局坐标系统（Global）</li><li>局部坐标系统（Local）</li><li>世界坐标系统（World）</li><li>模型坐标系统（Model）</li><li>模型的部件坐标系统（如头部、手部等）</li></ul><p>关键问题在于如何在这些不同的坐标系统之间进行转换（将在下周的课程探讨）</p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>A矩阵的列数必须 = B矩阵的行数（M×N)(N×P) = (M×P)</p><p>$\begin{pmatrix} 1&amp;3\\ 5&amp;2\\ 0&amp;4 \end{pmatrix} \begin{pmatrix} 3&amp;6&amp;9&amp;4\\ 2&amp;7&amp;8&amp;3\\ \end{pmatrix} = \begin{pmatrix} 9&amp;?&amp;33&amp;13\\ 19&amp;44&amp;61&amp;26\\ 8&amp;28&amp;32&amp;？ \end{pmatrix}$  </p><p>性质：</p><ul><li>不满足交换律：AB 和 BA 结果不同</li><li>满足结合律和分配律</li></ul><script type="math/tex; mode=display">(AB)C = A(BC)\\A(B+C)=AB+AC\\(A+B)C=AC+BC</script><h3 id="转置矩阵"><a href="#转置矩阵" class="headerlink" title="转置矩阵"></a>转置矩阵</h3><p>$A = \begin{pmatrix}  1 &amp; 4  \\  2 &amp; 5 \\  3 &amp; 6 \end{pmatrix}   \qquad  A^T = \begin{pmatrix}  1 &amp; 2 &amp; 3  \\  4 &amp; 5 &amp; 6\\  \end{pmatrix}  $​​</p><ul><li>交换矩阵的行和列</li><li>$(AB)^T = B^TA^T$</li></ul><h3 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h3><p>$I_{3\times3} = \begin{pmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{pmatrix}  \qquad  AA^{-1} = A^{-1}A = I  \qquad  (AB)^{-1} = B^{-1}A^{-1}$  </p><h3 id="矩阵中的向量乘法"><a href="#矩阵中的向量乘法" class="headerlink" title="矩阵中的向量乘法"></a>矩阵中的向量乘法</h3><ul><li><p><strong>点乘</strong></p><p>$\vec{a} \cdot \vec{b} = \vec{a}^T \vec{b}  =  \begin{pmatrix}  x_a &amp; y_a &amp; z_a   \end{pmatrix}   \begin{pmatrix} x_b \\ y_b \\ z_b \end{pmatrix} = (x_a x_b + y_a y_b + z_a z_b)$</p></li><li><p><strong>叉乘</strong></p><p>$\vec{a} \times \vec{b} = A^* b = \begin{pmatrix} 0 &amp; -z_a &amp; y_a \\ z_a &amp; 0 &amp; -x_a \\ -y_a &amp; x_a &amp; 0 \end{pmatrix} \begin{pmatrix} x_b \\ y_b \\ z_b \end{pmatrix}$</p></li></ul><script type="math/tex; mode=display"></script><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
      <category>GAMES101</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>颜色空间</title>
    <link href="/2024/08/29/UnitySummary/%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/"/>
    <url>/2024/08/29/UnitySummary/%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="颜色空间"><a href="#颜色空间" class="headerlink" title="颜色空间"></a>颜色空间</h1><h3 id="线性空间和伽马空间"><a href="#线性空间和伽马空间" class="headerlink" title="线性空间和伽马空间"></a>线性空间和伽马空间</h3><p>在<strong>线性空间</strong>下，我们感知到的强度和对应的数值强度是按比例对应的，也就是说如果有两个数值强度0.25和0.25那么他们相加的数值强度就是0.5。</p><p>使用线性空间，是因为光照计算的需要，只有使用线性空间才能在数学上正确计算出光照</p><p>而使用<strong>伽马空间</strong>，一是因为显示器对颜色强度的感知是非线性的，另一个原因是人眼在较暗的环境下比起亮的环境能够更好的辨别细节。</p><p>因此在图像压缩中我们希望能够在暗部获得更高的精确度，所以对图像每个像素引入了一个幂函数来进行处理，</p><p>使用RGB来表示颜色的时候，一般用0到255的整数或者0到1之间的小数</p><p>线性空间和伽马空间，实质上是对同一颜色在不同标准下的记录</p><p>假设有一种灰色，在线性空间下表示为<code>0.5，0.5，0.5</code>​，在伽马空间下，这个颜色则表示为<code>0.73，0.73，0.73</code>​，但实际上，它们是同一种颜色</p><p><img src="/temp_assets/image-20240829144335-o1avu3i.png" alt=""></p><p>大多数图像在存储时都应用了 0.45 的伽马系数，这将产生如上左图所示的效果。现在，图像的较暗区域使用更大的值范围进行记录，而明亮范围则被压缩。以这种方式存储的图像位于 “gamma 空间” 中。</p><p>例如，图像中的中性灰色的数值强度不是 0.5，而是在 0.73 左右，而纯白色和黑色保持不变。这是几乎所有数码相机以及图像编辑应用程序等的默认行为。事实上，您在计算机上看到的几乎每张图像都应用了该灰度系数。</p><p>为什么图像显示正确，而看起来不会太亮。这就是显示器非线性响应的用武之地。CRT 屏幕，仅从它们的工作原理来看，应用大约 2.2 的伽玛系数，而现代 LCD 屏幕旨在模仿这种行为。当伽玛 2.2（0.45 的倒数）应用于增亮的图像时，会使它们变暗，留下原始图像。</p><p>例如，左上图表示计算机上存储的内容，显示后，结果将类似于中心图像。左侧图像已经过“伽马系数校正”，这意味着它具有伽马系数值，因此在将屏幕的伽马系数应用于图像后，它将正确显示。</p><p>如果计算机存储的是尚未经过 Gamma 校正的中心图像，则显示的结果看起来就像正确的图像，这显然是不需要的行为​​</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在实习的时候，遇到了一点UI和场景中颜色空间的问题。​​</p><p>在项目中，场景使用的是线性空间，而UI使用的是伽马空间，场景计算完成后，会转换为伽马空间，同UI一保持一致，然后经由显示器矫正</p><p><img src="/temp_assets/image-20240829151325-ul7qbkx.png" alt="">​</p><p>因为相框是使用MeshRenderer组件显示在场景中的，而选择时查看的图片是在UI上</p><p>由于场景中要进行正确的光照计算，所以使用的是线性空间，而UI上的图片使用的是伽马空间，自定义的渲染管线会再后面将场景的颜色空间从线性空间再变换为伽马空间，以求和UI同步后进行后续处理</p><p>而直接将UI上Image组件的sprite（这个sprite实际上是原图，从kresource.load加载来的）传给MeshRenderer的sprite时会有色差，因此在MeshRenderer上使用UIInScene材质进行颜色矫正，将sprite从伽马空间变换到线性空间，以便和场景同步</p><p><img src="/temp_assets/image-20240828192742-85zhf30.png" alt=""></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://crunchybiscuits.github.io/2021/05/14/%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E5%92%8C%E4%BC%BD%E9%A9%AC%E7%A9%BA%E9%97%B4/#:~:text=%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%20%E5%9C%A8%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E4%B8%8B%EF%BC%8C%E6%88%91%E4%BB%AC%E6%84%9F%E7%9F%A5%E5%88%B0%E7%9A%84%E5%BC%BA%E5%BA%A6%E5%92%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E5%80%BC%E5%BC%BA%E5%BA%A6%E6%98%AF%E6%8C%89%E6%AF%94%E4%BE%8B%E5%AF%B9%E5%BA%94%E7%9A%84%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%80%BC%E5%BC%BA%E5%BA%A60.25%E5%92%8C0.25%E9%82%A3%E4%B9%88%E4%BB%96%E4%BB%AC%E7%9B%B8%E5%8A%A0%E7%9A%84%E6%95%B0%E5%80%BC%E5%BC%BA%E5%BA%A6%E5%B0%B1%E6%98%AF0.5%E3%80%82%20%E6%B2%A1%E6%9C%89%E8%BF%99%E6%A0%B7%E7%89%B9%E6%80%A7%E7%9A%84%E7%A9%BA%E9%97%B4%E5%B0%B1%E6%98%AF%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E3%80%82,%E4%BC%BD%E9%A9%AC%E7%A9%BA%E9%97%B4%20%E4%B9%8B%E6%89%80%E4%BB%A5%E5%BC%95%E5%85%A5gamma%E7%A9%BA%E9%97%B4%E4%B8%80%E6%98%AF%E5%9B%A0%E4%B8%BA%E6%98%BE%E7%A4%BA%E5%99%A8%E5%AF%B9%E9%A2%9C%E8%89%B2%E5%BC%BA%E5%BA%A6%E7%9A%84%E6%84%9F%E7%9F%A5%E6%98%AF%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%9A%84%EF%BC%8C%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BA%BA%E7%9C%BC%E5%9C%A8%E8%BE%83%E6%9A%97%E7%9A%84%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%AF%94%E8%B5%B7%E4%BA%AE%E7%9A%84%E7%8E%AF%E5%A2%83%E8%83%BD%E5%A4%9F%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%BE%A8%E5%88%AB%E7%BB%86%E8%8A%82%E3%80%82%20%E5%9B%A0%E6%AD%A4%E5%9C%A8%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%E4%B8%AD%E6%88%91%E4%BB%AC%E5%B8%8C%E6%9C%9B%E8%83%BD%E5%A4%9F%E5%9C%A8%E6%9A%97%E9%83%A8%E8%8E%B7%E5%BE%97%E6%9B%B4%E9%AB%98%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%BA%A6%EF%BC%8C%E6%89%80%E4%BB%A5%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%AF%8F%E4%B8%AA%E5%83%8F%E7%B4%A0%E5%BC%95%E5%85%A5%E4%BA%86%E4%B8%80%E4%B8%AA%E5%B9%82%E5%87%BD%E6%95%B0%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%E3%80%82">线性空间和伽马空间 | ZY-Zhang (crunchybiscuits.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RiderFlow</title>
    <link href="/2024/07/14/UnityPackages/RiderFlow/"/>
    <url>/2024/07/14/UnityPackages/RiderFlow/</url>
    
    <content type="html"><![CDATA[<h1 id="RiderFlow"><a href="#RiderFlow" class="headerlink" title="RiderFlow"></a>RiderFlow</h1><p><a href="https://www.bilibili.com/read/cv16329235/">【Unity】场景管理RiderFlow快速概览(F2U) - 哔哩哔哩 (bilibili.com)</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>RiderFlow是Jetbrains开发的免费Unity场景管理插件</p><p>主要功能</p><ol><li>搜索功能—-(搜索所有物体脚本)</li><li>保存摄影机视角</li><li>hierarchy的多颜色划分标签</li><li>物体的书签</li><li>物体上的笔记</li><li>查找物体或脚本，或资源图片的使用状况</li><li>更换物体</li><li>内部轻量级代码编辑</li></ol><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>插件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Timeline</title>
    <link href="/2024/05/24/UnityPackages/Timeline/"/>
    <url>/2024/05/24/UnityPackages/Timeline/</url>
    
    <content type="html"><![CDATA[<h1 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h1><h2 id="Track一览"><a href="#Track一览" class="headerlink" title="Track一览"></a>Track一览</h2><div class="table-container"><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Track Group</td><td>Track组，可以放多个track，可以用来按组分类划分</td></tr><tr><td>Activation Track</td><td>用来控制GameObject是否激活</td></tr><tr><td>Animation Track</td><td>用来控制Animation的播放</td></tr><tr><td>Audio Track</td><td>用来控制Audio的播放</td></tr><tr><td>Control Track</td><td>用来控制gameobject</td></tr><tr><td>Signal Track</td><td>用来发射信号，出发事件</td></tr><tr><td>Playable Track</td><td>用户自定义的轨道</td></tr></tbody></table></div><h3 id="Control-Track"><a href="#Control-Track" class="headerlink" title="Control Track"></a>Control Track</h3><p>用来控制prefab、特效、gameobject等的时间线</p><p>这个<code>Control Track</code>​可以拖入其他director，然后就能调整这个director的播放，形成嵌套效果</p><p><strong>注意：</strong></p><ol><li>在clip外会自动销毁，</li><li>因此拖入了director后不能拖入director控制的其他gameobject，因为在gameobject外自身是被销毁的状态</li></ol><p>在track中的每一个物体，都对应一个clip来控制</p><p><strong>参数</strong></p><p><img src="/assets/UnityPackages/image-20240524162937-j8pcrc8.png" alt=""></p><p>通用属性跳过，看两眼就知道怎么用了</p><p>SourceGameObject：此 clip 要控制的物体</p><p>Prefab：此clip要生成并控制的prefab，当这里赋予了一个Assets下的prefab时，SourceGameObject会变成ParentObject，ParentObject指定的物体将为Prefab生成时的父物体。</p><p>ControlActivation：</p><ul><li>控制激活，控制SourceGameObject的激活状态，</li><li>不勾选SourceGameObject将保持自有状态（也就是会一直存在或者隐藏，取决于自己）</li></ul><p>PostPlayback：剪辑播放完成时SourceGameObject的状态</p><ul><li>Active ：剪辑播放完后，SourceGameObject.active=true</li><li>​​Inactive：剪辑播放完后，SourceGameObject.active=false</li><li>Revert：剪辑播放完后，SourceGameObject.active=播放前的active的值</li></ul><p>Advanced 高级选项：</p><ol><li>ControlPlayableDirectors：控制物体上的 timline 播放状态，勾选后可以控制 clip 物体上的播放进度</li><li>ControlParticleSystem：控制粒子发射器，不勾选只能控制 clip 物体的显隐，勾选后可以 clip 物体上的粒子发射器的发射进度，可以实现粒子发射的倒放</li><li>RandomSeed：当粒子系统的 seed 设置为 AutoRandomSeed 时，这里的值可以设置粒子系统的随机种子，这个选项仅对ps的clip生效，对于 clip 是 timeline 类型的不生效</li><li>ControlItimeControl：勾选后可以同步当前 timeline 的时间到 clip 物体上继承了 ItimeControl 接口的组件上</li><li>ControlChildren：勾选后可以控制 Clip 物体的子对象内的 timeline 、粒子系统和继承了ItimeControl 接口的实体</li></ol><p><strong>ControlTrack clip的操作</strong></p><ul><li>ControlTrack Clip 遵循通用的 clip 操作</li><li>ControlTrack Clip 中间无法做混合，只能做切除操作</li></ul><h3 id="Signal-Track"><a href="#Signal-Track" class="headerlink" title="Signal Track"></a>Signal Track</h3><p><a href="https://blog.csdn.net/qq_42139931/article/details/123913441">Unity【Timeline】- 使用Signal Track添加事件_unity timeline 事件-CSDN博客</a></p><p>因为signal是具体到某个物体上的，需要物体具有signal receiver组件，因此，对于某些额外的物体只需要使用signal功能，就可以采用signal track而不用signal receiver组件</p><p>‍</p><h3 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h3><p><a href="https://docs.unity.cn/Packages/com.unity.timeline@1.7/manual/smpl_custom_annotation.html">注释标记示例 |时间线 |1.7.5 —- Annotation marker sample | Timeline | 1.7.5 (unity.cn)</a></p><p>书签，用来作为注释和标记</p><p>‍</p><h2 id="Timeline-Clip编辑模式"><a href="#Timeline-Clip编辑模式" class="headerlink" title="Timeline Clip编辑模式"></a>Timeline Clip编辑模式</h2><p>Timeline的Clip有三种不同的编辑模式，分别是Mix模式（混合模式，默认），Ripple模式（波纹模式），Replace模式（替换模式）</p><p><img src="/assets/UnityPackages/network-asset-v2-73d52dc280fb94539a38d8ce9b764fd0_720w-20240527143450-wx9yp63.webp" alt=""></p><p>点击上图中的几个按钮，就可以切换不同的模式，一次是Mix模式，Ripple模式，Replace模式。</p><p>还有一种方法是临时切换模式，快速编辑的时候很有用：比如你编辑一个clip的时候想临时切换到Ripple模式，就可以使用快捷键临时切换，而不用切来切去了。切换方法如下：</p><ul><li>按住<code>1</code>​临时切换到Mix模式。</li><li>按住<code>2</code>​临时切换到Ripple模式。</li><li>按住<code>3</code>​临时切换到Replace模式。</li></ul><p>注意是<strong>按住</strong>这些键，并同时操作。</p><h3 id="Mix模式"><a href="#Mix模式" class="headerlink" title="Mix模式"></a><strong>Mix模式</strong></h3><p>默认的编辑模式。使用这种模式时，当你拖动clip，两个clip发生重叠时，会将重叠部分混合。</p><p>在Mix模式下，当光标在clip的不同区域拖拽时，光标会有不同的变化，表示会执行不同的功能。</p><ul><li>在clip的最前面时，光标会变成一个修剪的光标，拖拽可以修改clip自身开始播放的位置。（注意不是在Timeline中开始播放的位置，而是clip自身开始播放的时间，比如clip有5秒，可以修改为从第3秒开始播放。）</li><li>在clip中间时，光标会变成一个移动的光标，此时拖拽可以移动clip。</li><li>在clip最后面时，光标会变成一个修剪的光标，拖拽可以修改clip自身结束播放的位置。</li></ul><p>在Mix模式中，如果拖拽时和其他clip发生重叠，光标会变成一个白色箭头，指示混合的位置。箭头有三种情况，指示混合创建的位置，在开头、结尾、或是开头和结尾都有。</p><h3 id="Ripple模式"><a href="#Ripple模式" class="headerlink" title="Ripple模式"></a><strong>Ripple模式</strong></h3><p>使用这种模式时，调整clip的长度和位置时，后面的clip的相对位置保持不变。</p><p>在Ripple模式下，当你修剪或者移动一个clip时，光标会变成一个黄色的箭头，表示影响后面的clip。一个黄色的竖线，代表ripple开始的点。</p><h3 id="Replace模式"><a href="#Replace模式" class="headerlink" title="Replace模式"></a><strong>Replace模式</strong></h3><p>替换模式。使用这种模式时，当两个clip发生重叠时，当前操作的clip会替换掉重叠的部分，不会发生混合。</p><p>注意重叠的部分被自动覆盖以后，再修改当前操作的clip的长度后，被覆盖的那个clip也不会自动复原，需要操作被覆盖的clip来还原。</p><h2 id="Signal介绍"><a href="#Signal介绍" class="headerlink" title="Signal介绍"></a>Signal介绍</h2><p>信号，是timeline触发事件的媒介，因为其具有广播的性质，所以比event的名字更适合</p><h3 id="如何添加信号"><a href="#如何添加信号" class="headerlink" title="如何添加信号"></a>如何添加信号</h3><ol><li>右击任何一个bindingType是GameObject或者Component的Track，在弹出的菜单栏中点击Add Signal Emitter即可添加信号</li></ol><p><img src="/assets/UnityPackages/network-asset-v2-d8cae529159455580ea03e4a4eb7fa0f_720w-20240524154247-ra0lc31.webp" alt=""></p><ol><li>信号添加好后，会出现下图中的游标，带警告的游标说明没有选择要触发的信号类型(Emit Signal为none)</li></ol><p><img src="/assets/UnityPackages/network-asset-v2-1b9a9da57dbef526eb7b0cd9518850d0_720w-20240524154247-qz1tv6d.webp" alt=""></p><p>3 选中Signal游标，在检视版中选择触发的信号类型</p><p><img src="/assets/UnityPackages/network-asset-v2-fe570c3751a724216245470051789f0d_720w-20240524154247-tojtehe.webp" alt=""></p><ol><li>Signal选好后，需要在下方添加一个Signal Receiver用来选择接收信号的方法，同按钮点击事件，不在赘述</li></ol><p><img src="/assets/UnityPackages/network-asset-v2-f3ceb794532519f09dd9411b9cc7a061_720w-20240524154247-dpcmvvd.webp" alt=""></p><ol><li>至此当timeline播放到signal游标处就会触发对应的事件了，（注意，signal触发的事件，只有signal所在track上的对象上的signal receiver生效）</li></ol><h3 id="如何添加带参信号"><a href="#如何添加带参信号" class="headerlink" title="如何添加带参信号"></a>如何添加带参信号</h3><ol><li>继承SignalEmitter，实现一个新的信号触发器，并在其中加入新的参数</li></ol><p><img src="/assets/UnityPackages/network-asset-v2-73c387be2dee042ffd7b183f8bfc4d58_720w-20240524154247-4yaqj3l.webp" alt=""></p><ol><li>添加自定义的信号。当创建了新的SignalEmitter时，timeline会在原添加信号菜单处加入添加新信号的菜单</li></ol><p><img src="/assets/UnityPackages/network-asset-v2-b25267bb05808a1df5092850e18d0fcc_720w-20240524154247-gf72tao.webp" alt=""></p><ol><li><p>选择信号类型同普通信号。</p></li><li><p>signal receiver需要自己实现，在挂在track的对象上，这个时候就可以通过 notification获取带参信号的参数了！</p></li></ol><p><img src="/assets/UnityPackages/network-asset-v2-0400c87ce645d30735ba31a820bf1a7f_720w-20240524154247-5h1j04s.webp" alt=""></p><h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><p>timeline很强大，除了自带的轨道，还可以自己定义轨道，从而能够根据自身需要添加timeline clip</p><h3 id="自定义clip：Playable-Track"><a href="#自定义clip：Playable-Track" class="headerlink" title="自定义clip：Playable Track"></a>自定义clip：Playable Track</h3><p><strong>创建自定义clip需要2个脚本</strong>：</p><ul><li>一个用于存放数据：需要继承<code>PlayableAsset</code>​</li><li>一个用于处理逻辑：需要继承<code>PlayableBehaviour</code>​</li></ul><p>存放数据的脚本，也是显示在<code>Playable Track</code>​的脚本</p><pre><code class="hljs">这个脚本必须继承自`PlayableAsset`​这个脚本的public成员，会序列化显示在对应的Inspector上，以便进行配置必须重写抽象方法`CreatePlayable`​，这个方法返回一个`Playable`​类对象，在这个方法中可以传递配置好的成员</code></pre><p>处理逻辑的脚本，我们可以重写多个生命周期函数，以进行调用</p><p>以text脚本为例，我们可以写成如下形式，在<code>TextPlayableAsset</code>​中配置数据，然后传到<code>TextPlayableBehaviour</code>​进行逻辑处理</p><p>逻辑处理的部分如下</p><p><img src="/assets/UnityPackages/image-20240723155345-ohpczel.png" alt=""></p><p>为了获得这些数据，我们在<code>TextPlayableAsset</code>​中配置数据，再传递到<code>TextPlayableBehaviour</code>​</p><p><img src="/assets/UnityPackages/image-20240527154904-4ghb610.png" alt=""></p><p>代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TextPlayableAsset</span> : <span class="hljs-title">PlayableAsset</span><br>&#123;<br>    <span class="hljs-comment">//配置的数据</span><br>    <span class="hljs-keyword">public</span> ExposedReference&lt;TextMeshProUGUI&gt; textMeshPro;<br>    <span class="hljs-keyword">public</span> Color color = Color.white;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> fontSize = <span class="hljs-number">14</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> text = <span class="hljs-string">&quot;&quot;</span>;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Playable <span class="hljs-title">CreatePlayable</span>(<span class="hljs-params">PlayableGraph graph, GameObject owner</span>)</span><br>    &#123;<br>        TextMeshProUGUI textMeshProUGUI = textMeshPro.Resolve(graph.GetResolver());<br><br>        ScriptPlayable&lt;TextPlayableBehaviour&gt; playable = ScriptPlayable&lt;TextPlayableBehaviour&gt;.Create(graph);<br>      <br>        TextPlayableBehaviour playableBehaviour = playable.GetBehaviour();<br><br>        playableBehaviour.textMeshPro = textMeshProUGUI;<br>        playableBehaviour.color = color;<br>        playableBehaviour.fontSize = fontSize;<br>        playableBehaviour.text = text;<br>      <br>        <span class="hljs-keyword">return</span> playable;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 逻辑处理：将指定的text格式配置给指定的TextMeshProUGUI</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TextPlayableBehaviour</span> : <span class="hljs-title">PlayableBehaviour</span><br>&#123;<br>   <span class="hljs-keyword">public</span> TextMeshProUGUI textMeshPro;<br>   <span class="hljs-keyword">public</span> Color color = Color.white;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> fontSize = <span class="hljs-number">14</span>;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> text = <span class="hljs-string">&quot;&quot;</span>;<br><br>   <span class="hljs-comment">//clip开始时执行</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnBehaviourPlay</span>(<span class="hljs-params">Playable playable, FrameData info</span>)</span><br>   &#123;<br>      textMeshPro.color = color;<br>      textMeshPro.fontSize = fontSize;<br>      textMeshPro.text = text;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ExposedReference类"><a href="#ExposedReference类" class="headerlink" title="ExposedReference类"></a>ExposedReference类</h3><p>在上面创建playable的相关脚本中，如果使用了继承自MonoBehaviour的字段，那么需要注意的是，</p><ol><li>Unity 的 Asset 只能引用资源对象，不能引用MonoBehaviour对象（场景中的对象）</li><li>Unity 的 MonoBehaviour对象既可以引用资源对象，又可以引用MonoBehaviour对象</li></ol><p>因此会出现场景中的物体不能拖拽，而预制体可以拖拽的情况</p><p>Unity 提供 ExposedReference 和 IExposedPropertyTable 机制来实现 Asset 引用场景中的对象</p><p>以<code>TextMeshProUGUI</code>​为例，假设有字段</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> ExposedReference&lt;TextMeshProUGUI&gt; textMeshPro;<br></code></pre></td></tr></table></figure><p>在继承自<code>PlayableAsset</code>​的脚本中，可以在<code>CreatePlayable</code>​方法中这样处理</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Playable <span class="hljs-title">CreatePlayable</span>(<span class="hljs-params">PlayableGraph graph, GameObject owner</span>)</span><br>&#123;<br><span class="hljs-comment">//解析ExposedReference</span><br><span class="hljs-keyword">var</span> textMeshProUGUI = textMeshPro.Resolve(graph.GetResolver());<br>&#125;<br></code></pre></td></tr></table></figure><p>在继承自<code>PlayableBehaviour</code>​的脚本中，可以这样处理</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnGraphStart</span>(<span class="hljs-params">Playable playable</span>)</span><br>&#123;<br>    <span class="hljs-comment">//获取解析器并解析，检索分配的控制对象</span><br>    <span class="hljs-keyword">var</span> _textMeshPro = textMeshPro.Resolve(playable.GetGraph().GetResolver());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Playable-Track的改进"><a href="#Playable-Track的改进" class="headerlink" title="Playable Track的改进"></a>Playable Track的改进</h3><p>要实现<code>Playable Track</code>​，需要写两个脚本，一个是用来配置数据的，一个是用来处理逻辑的</p><p>但实际书写时，就会发现很多不便，因为我们需要在两个脚本中都写上同样的成员变量，再进行传递</p><p>我们可以利用<code>[serializable]</code>​特性直接进行成员传递，让继承自<code>PlayableBehaviour</code>​的脚本的成员出现在inpector上</p><p>上面的例子可以改成如下</p><p><img src="/assets/UnityPackages/image-20240527160210-7tcdn0z.png" alt=""></p><p><img src="/assets/UnityPackages/image-20240527160308-y27vey2.png" alt=""></p><p>如此，我们可以进行间接配置，从而略去中间的传递数据的过程</p><h3 id="自定义轨道"><a href="#自定义轨道" class="headerlink" title="自定义轨道"></a>自定义轨道</h3><p>使用player track，我们可以更改许多自定义的东西，比如text， transform。但是，player track只能创建clip，我们需要在每一个clip上绑定对应数据，如果我们希望对同一个东西进行频繁修改的话，创建的每一个clip都绑定到了同样的对象上</p><p>通过自定义轨道，能够让数据绑定到轨道上，这样，每一个clip就无需再绑定数据了</p><p>要自定义新轨道，需要继承自<code>TrackAsset</code>​，这个类里面可以什么都不写，如果要实现混合需要酌情重载<code>CreateTrackMixer</code>​和<code>GatherProperties</code>​方法</p><p>要拿到绑定的数据，需要在<code>TextPlayableBehaviour</code>​类中重写方法<code>ProcessFrame</code>​，使用playerData即可</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ProcessFrame</span>(<span class="hljs-params">Playable playable, FrameData info, <span class="hljs-built_in">object</span> playerData</span>)</span><br>&#123;<br>    <span class="hljs-keyword">var</span> textMeshProUGUI = playerData <span class="hljs-keyword">as</span> TextMeshProUGUI;<br><br>    <span class="hljs-keyword">if</span> (textMeshProUGUI == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>      <br><br>    textMeshProUGUI.color = color;<br>    textMeshProUGUI.fontSize = fontSize;<br>    textMeshProUGUI.text = text;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/assets/UnityPackages/image-20240528095855-x938tcn.png" alt=""></p><p>这个时候右击timeline的菜单中就出现自定义的轨道了</p><p><a href="https://blog.csdn.net/qq_52626549/article/details/131415151">【Unity学习笔记】ExposedReference类的初识 + 自定义Timeline轨道初识-CSDN博客</a></p><h3 id="TimelineMixer"><a href="#TimelineMixer" class="headerlink" title="TimelineMixer"></a>TimelineMixer</h3><p>可以这么理解，Mixer是整条track的底层，它用来处理不同clip之间的混合，包括那些空白的部分的状况（是沿用最后的非空白的状态还是回到默认的状态）</p><p><img src="/assets/UnityPackages/image-20240528105509-slp383o.png" alt=""></p><p>要实现Mixer，需要另写一个继承自<code>PlayableBehaviour</code>​的脚本，然后在<code>TrackAsset</code>​中实现<code>CreaterTrackMixer</code>​方法，并绑定到这个脚本</p><ol><li>在这个Mixer脚本中，也需要实现<code>ProcessFrame</code>​方法，并且Mixer的优先级更高，是覆盖执行。也就是说，当Mixer脚本中的重写了<code>ProcessFrame</code>​方法，此前的脚本也重写了<code>ProcessFrame</code>​方法，Mixer脚本中的<code>ProcessFrame</code>​方法会后调用</li><li>需要注意的是，某个clip的<code>ProcessFrame</code>​方法只在播放到这个clip时才启用，而Mixer脚本中的<code>ProcessFrame</code>​方法在整个timeline中都会执行</li><li>Mixer脚本是不知道当前播放到哪里，它只能遍历全部的clip（空白的不管），查询其权重，如果clip返回的权重是1，它才会知道此时播放到这个clip</li><li>如果两个clip重叠，那么过渡的过程中，前面的clip返回的权重就会从1渐变到0，后面的clip返回的权重会从0渐变到1</li></ol><p>还是以卡拉OK为例，之前的做法，在两个clip之间，歌词会沿用上一个clip的歌词，现在我们希望空白部分的歌词为空（最快的做法其实是直接创建clip替代空白，然后歌词不填）</p><p>在<code>TrackAsset</code>​中实现<code>CreaterTrackMixer</code>​方法</p><p><img src="/assets/UnityPackages/image-20240528111627-u9vviws.png" alt=""></p><p>实现Mixer脚本，因为两个clip在设计上是不会重叠的，所以不用管插值的部分，而每个clip自己实现了显示歌词的方法，那么在这个脚本里，我们只需要判断是不是当前没有播放到任何一个clip中，是的话就将歌词设置为默认值即可</p><p><img src="/assets/UnityPackages/image-20240528112929-6v4lg03.png" alt=""></p><h2 id="实战：卡拉OK轨"><a href="#实战：卡拉OK轨" class="headerlink" title="实战：卡拉OK轨"></a>实战：卡拉OK轨</h2><p>来源：<a href="https://www.bilibili.com/video/BV1F54y1a73Q/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=fa868a89c47131bf7faa4e6af78a3a9e">Timeline 3 | 卡拉OK轨 | 自定义轨道 | Unity3d 教程_哔哩哔哩_bilibili</a></p><p>要实现卡拉OK轨，首先要弄明白它的原理</p><p>我们可以使用两个叠加的歌词，一个白色，一个绿色，设置二者的轴心都在左侧边缘，然后将绿色歌词的TextMeshPro组件中的，wrapping设置为disabled，将overflow设置为截断，wrapping启用时，会自动换行，overlfow则是对溢出的处理</p><p>然后修改绿色歌词的RectTransform组件的宽度即可实现想要的功能</p><p><img src="/assets/UnityPackages/image-20240528103320-l1usjhl.png" alt=""></p><p>然后就是书写代码，我们使用四个脚本来实现</p><p><img src="/assets/UnityPackages/image-20240528104025-gmuwdkv.png" alt=""></p><p><img src="/assets/UnityPackages/image-20240528104040-ec6hcgr.png" alt=""></p><p><img src="/assets/UnityPackages/image-20240528104058-nb625ix.png" alt=""></p><p><img src="/assets/UnityPackages/image-20240528104110-nxcpzag.png" alt=""></p><p>表现</p><p><img src="/assets/UnityPackages/1716864118552-20240528104210-1xegif3.gif" alt="1716864118552">​</p><p>注意：这里的显示其实是一个字符一个字符显示的，更好的滑动效果是逐渐显示，可以使用<code>Rect Mask 2D</code>​组件来实现，不控制TextMeshPro转而控制这个组件的属性即可</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>官方文档：<a href="https://docs.unity.cn/Packages/com.unity.timeline@1.7/manual/index.html">关于时间轴 |时间线 |1.7.5 —- About Timeline | Timeline | 1.7.5 (unity.cn)</a></p><p>翻译：<a href="https://blog.csdn.net/linjf520/article/details/104463436">Unity - Timeline 知识汇总_unity2020 timeline-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/29188275">【Unity】TimeLine系列教程——编排剧情！ - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/513872343">Unity Timeline扩展研究之基础篇(一) - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>插件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Post Processing</title>
    <link href="/2024/05/21/UnityPackages/Post%20Processing/"/>
    <url>/2024/05/21/UnityPackages/Post%20Processing/</url>
    
    <content type="html"><![CDATA[<h1 id="Post-Processing"><a href="#Post-Processing" class="headerlink" title="Post Processing"></a>Post Processing</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>使用后期处理有两个主要原因：实现所需的<strong>视觉风格</strong>和确保<strong>视觉保真度</strong></p><ul><li>视觉风格是指项目的风格外观和感觉</li><li>视觉保真度是指场景反映其所要表示的世界的准确程度。</li></ul><h3 id="安装和设置"><a href="#安装和设置" class="headerlink" title="安装和设置"></a>安装和设置</h3><p><img src="/assets/UnityPackages/image-20240523212057-2lyl5hc.png" alt=""></p><p>每个摄像机都可以应用后期处理，要应用后处理，需要勾选Post Processing，以及在Enviroment中的volumn mask要选择volumn文件所在的层</p><p><img src="/assets/UnityPackages/image-20240523173303-1kyxhpr.png" alt=""></p><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p>为了实际应用新效果，我们需要在场景中添加一个叫做 Volume 的东西。体积指定场景中的特定物理区域。当摄像机位于该体积内时，后期处理将影响摄像机渲染的内容。</p><p><img src="/assets/UnityPackages/image-20240521154713-72f6bxx.png" alt=""></p><p>可以使用全局Volume，它将效果应用于整个场景，或者使用较小的局部Volume，仅当摄像机位于特定区域时才应用效果。</p><h3 id="效果一览"><a href="#效果一览" class="headerlink" title="效果一览"></a>效果一览</h3><p><img src="/assets/UnityPackages/image-20240523173608-ocw68ll.png" alt=""></p><p>‍</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>2020版本及以后，Ambient Occlusion 环境光遮蔽和Screen-space reflections已经不在post processing包中支持，具体可见<a href="https://docs.unity.cn/Manual/PostProcessingOverview.html">Unity - 手动：后期处理和全屏效果 —- Unity - Manual: Post-processing and full-screen effects</a></p><p>以下只解释含义，具体参数的含义见：<a href="https://docs.unity.cn/Packages/com.unity.render-pipelines.universal@10.0/manual/integration-with-post-processing.html">Post-processing in the Universal Render Pipeline | Universal RP | 10.0.0-preview.26 (unity.cn)</a></p><h3 id="Ambient-Occlusion-环境光遮蔽"><a href="#Ambient-Occlusion-环境光遮蔽" class="headerlink" title="Ambient Occlusion 环境光遮蔽"></a>Ambient Occlusion 环境光遮蔽</h3><p>环境光遮蔽，顾名思义，指的是场景中的环境光会出现被遮蔽的效果，一般的环境光都是不考虑方向和位置的常量，但是环境光遮蔽会考虑环境光被其他物体遮挡的情况</p><p>环境光遮挡效果可以使挨着折痕线、小孔、相交线和平行表面的地方变暗。在现实世界中，这些区域往往会阻挡或遮挡周围的光线，因此它们会显得更暗。</p><p><img src="/assets/UnityPackages/image-20240523212927-6re91gv.png" alt="">​​​</p><p><img src="/assets/UnityPackages/image-20240523212959-mis23vb.png" alt="">​</p><p><a href="https://www.bilibili.com/read/cv677744/">小科普 | 是什么蒙蔽了你的双眼？是环境光遮蔽（一） - 哔哩哔哩 (bilibili.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/400633131">环境光遮蔽综述 - 知乎 (zhihu.com)</a></p><h3 id="Bloom-辉光效果"><a href="#Bloom-辉光效果" class="headerlink" title="Bloom 辉光效果"></a>Bloom 辉光效果</h3><p>泛光：光源周围产生发光效果</p><p><img src="/assets/UnityPackages/image-20240521155553-ublkg65.png" alt="">​</p><p>注意：只有在相机的渲染设置中启用了 HDR（高动态范围）并且灯光或自发光材质足够亮时，才能实现泛光。</p><p><img src="/assets/UnityPackages/image-20240528135335-tg2pqf6.png" alt=""></p><div class="table-container"><table><thead><tr><th><strong>Property</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><strong>Threshold</strong></td><td>Set the gamma space brightness value at which URP applies Bloom. URP does not apply Bloom to any pixels in the Scene that have a brightness lower than this value. The minimum value is 0, where nothing is filtered. The default value is 0.9. There is no maximum value. <br />设置 URP 应用 Bloom 的 Gamma 空间亮度值，URP 只会将“光晕”应用于场景中亮度高于此值的任何像素。最小值为 0，其中不筛选任何内容。默认值为 0.9。没有最大值。<br /></td></tr><tr><td><strong>Intensity</strong></td><td>Set the strength of the Bloom filter, in a range from 0 to 1. The default is 0, which means that the Bloom effect is disabled. <br />在 0 到 1 的范围内设置 Bloom 滤镜的强度。默认值为 0，表示禁用了辉光效果。<br /></td></tr><tr><td><strong>Scatter</strong></td><td>Set the radius of the bloom effect in a range from 0 to 1. Higher values give a larger radius. The default value is 0.7. <br />将光晕效果的半径设置在 0 到 1 的范围内。值越大，半径越大。默认值为 0.7。<br /></td></tr><tr><td><strong>Tint</strong></td><td>Use the color picker to select a color for the Bloom effect to tint to. <br />使用颜色选取器选择要着色的“绽放”效果的颜色。<br /></td></tr><tr><td><strong>Clamp</strong></td><td>Set the maximum intensity that Unity uses to calculate Bloom. If pixels in your Scene are more intense than this, URP renders them at their current intensity, but uses this intensity value for the purposes of Bloom calculations. The default value is 65472. <br />设置 Unity 用于计算 Bloom 的最大强度。如果场景中的像素强度高于此强度，则 URP 会以当前强度渲染它们，但会使用此强度值进行绽放计算。默认值为 65472。<br /></td></tr><tr><td><strong>High Quality Filtering</strong></td><td>Enable this to use high quality sampling. This reduces flickering and improves the overall smoothness, but is more resource-intensive and can affect performance. <br />启用此功能以使用高质量采样。这样可以减少闪烁并改善整体平滑度，但会占用更多资源，并可能影响性能。<br /></td></tr><tr><td><strong>Skip Iterations</strong></td><td>The last iterations in the processing sequence might have little contribution to the appearance of the rendered frame. In this setting you define the number of final iterations to skip. Increasing this value reduces processing load and increases performance, especially on mobile devices. The default value is 1. <br />处理序列中的最后一次迭代可能对渲染帧的外观影响不大。在此设置中，您可以定义要跳过的最终迭代次数。增加此值可减少处理负载并提高性能，尤其是在移动设备上。默认值为 1。<br /></td></tr></tbody></table></div><p>Lens Dirt 镜头污垢</p><div class="table-container"><table><thead><tr><th><strong>Property</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><strong>Texture</strong></td><td>Assign a Texture to apply the effect of dirt (such as smudges or dust) to the lens. <br />指定纹理以将污垢（如污迹或灰尘）的效果应用于镜头。<br /></td></tr><tr><td><strong>Intensity</strong></td><td>Set the strength of the <strong>Lens Dirt</strong> effect. <br />设置镜头污垢效果的强度。<br /></td></tr></tbody></table></div><h3 id="Chromatic-Aberration-色差"><a href="#Chromatic-Aberration-色差" class="headerlink" title="Chromatic Aberration 色差"></a>Chromatic Aberration 色差</h3><p>模拟相机的色彩偏移效果，在屏幕正中心的地方，不会出现偏移，越靠近屏幕四周，就越会发生偏移</p><p>可以用来模拟喝醉酒之后的镜头</p><p><img src="/assets/UnityPackages/image-20240528140504-m0mx9mj.png" alt=""></p><div class="table-container"><table><thead><tr><th><strong>Property</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><strong>Intensity</strong></td><td>Set the strength of the Chromatic Aberration effect. Values range between 0 and 1. The higher the value, the more intense the effect is. The default value is 0, which disables the effect. <br />设置色差效果的强度。值范围介于 0 和 1 之间。该值越高，效果越强烈。默认值为 0，将禁用效果。<br /></td></tr></tbody></table></div><h3 id="Film-Grain-胶片颗粒"><a href="#Film-Grain-胶片颗粒" class="headerlink" title="Film Grain 胶片颗粒"></a>Film Grain 胶片颗粒</h3><p>胶片颗粒效应模拟了摄影胶片的随机光学纹理，通常是由物理胶片上存在小颗粒引起的。</p><p><img src="/assets/UnityPackages/image-20240528160015-xn26oln.png" alt=""></p><p>‍</p><h3 id="Vignette-边角压暗"><a href="#Vignette-边角压暗" class="headerlink" title="Vignette 边角压暗"></a>Vignette 边角压暗</h3><p>在屏幕四周增加变暗的效果，模拟狙击镜，潜行，恐怖气氛，或者残血提示</p><p><img src="/assets/UnityPackages/image-20240528140723-z1x97wr.png" alt="">​</p><p><img src="/assets/UnityPackages/image-20240528141156-pfctxc1.png" alt=""></p><p><img src="/assets/UnityPackages/image-20240528141027-knfky88.png" alt="">​</p><p><img src="/assets/UnityPackages/image-20240528141104-j5e0sta.png" alt=""></p><div class="table-container"><table><thead><tr><th><strong>Property</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><strong>Color</strong></td><td>Use the color picker to set the color of the vignette. <br />使用颜色选择器设置晕影的颜色。<br /></td></tr><tr><td><strong>Center</strong></td><td>Set the vignette center point. For reference, the screen center is [0.5, 0.5]. <br />设置晕影中心点。作为参考，屏幕中心为 [0.5， 0.5]。<br /></td></tr><tr><td><strong>Intensity</strong></td><td>Set the strength of the vignette effect. <br />设置晕影效果的强度。<br /></td></tr><tr><td><strong>Smoothness</strong></td><td>Use the slider to set the smoothness of the vignette borders. Values range between 0.01 and 1. The higher the value, the smoother the vignette border. The default value is 0.2. <br />使用滑块设置晕影边框的平滑度。取值范围介于 0.01 和 1 之间。该值越高，晕影边框越平滑。默认值为 0.2。<br /></td></tr><tr><td><strong>Rounded</strong></td><td>When enabled, the vignette is perfectly round. When disabled, the vignette matches the shape on the current aspect ratio. <br />启用后，晕影是完全圆形的。禁用后，晕影将与当前纵横比上的形状匹配。<br /></td></tr></tbody></table></div><h3 id="Depth-of-Field-景深"><a href="#Depth-of-Field-景深" class="headerlink" title="Depth of Field 景深"></a>Depth of Field 景深</h3><blockquote><p>景深的原理及shader实现：<a href="https://zhuanlan.zhihu.com/p/565511249">用Unity实现景深效果 - 知乎 (zhihu.com)</a></p><p>三种渲染管线的自带景深实现：<a href="https://blog.csdn.net/weixin_46146935/article/details/129846132">Unity 景深Depth Of Field-CSDN博客</a></p></blockquote><p>景深效果就是用来虚化背景，在现实生活中，相机只能清晰地聚焦在特定距离的物体上。离相机更近或更远的物体都会失焦。unity支持两种模式</p><p><img src="/assets/UnityPackages/image-20240528142026-phecj3o.png" alt=""></p><ul><li><strong>Gaussian</strong>: this mode approximates camera-like effects, but doesn’t imitate them completely. It has a limited blur radius and only does far-field blurring. This mode is the fastest, and is the best mode for lower-end platforms. 高斯：此模式近似于类似相机的效果，但不能完全模仿它们。它的模糊半径有限，只做远场模糊。此模式是最快的，也是低端平台的最佳模式。</li><li><strong>Bokeh</strong>: a slower but higher quality mode that closely imitates the effects of a real-life camera. It can do both near &amp; far-field blurring, and generates bokeh on areas with high luminosity intensity, also known as hot spots. 散景：一种速度较慢但质量较高的模式，与现实生活中的相机效果非常相似。它可以进行近场和远场模糊，并在高光度强度的区域（也称为热点）上产生散景。</li></ul><h4 id="Gaussian-Depth-of-Field"><a href="#Gaussian-Depth-of-Field" class="headerlink" title="Gaussian Depth of Field"></a>Gaussian Depth of Field</h4><p><img src="/assets/UnityPackages/image-20240522094207-dhvw2s6.png" alt=""></p><p>近场和远场：在Unity的景深效果中，通常有一个近场（near field）和远场（far field）的概念。近场中的物体是清晰的，而远场中的物体则逐渐变得模糊。</p><p>模糊半径：模糊半径是指物体因景深效果而变得模糊的程度。在Unity中，这个半径通常是通过算法计算得出的，它基于物体到相机的距离、相机的焦距、光圈大小等因素。模糊半径的大小决定了模糊效果的强弱。半径越大，模糊效果越强烈；半径越小，模糊效果越轻微。</p><div class="table-container"><table><thead><tr><th><strong>Property</strong></th><th><strong>Description</strong></th><th>解释</th></tr></thead><tbody><tr><td><strong>Start</strong></td><td>Set the distance from the Camera at which the far field starts blurring. <br />设置远场开始模糊时，离相机的距离。<br /></td><td>这个参数定义了从相机开始，远场（far field）中的哪些物体开始变得模糊。</td></tr><tr><td><strong>End</strong></td><td>Set the distance from the Camera at which the far field blur reaches its maximum blur radius. <br />设置远场模糊达到其最大模糊半径时，离相机的距离。<br /></td><td>这个参数定义了远场中的物体在距离相机多远时，其模糊效果达到最大。也就是说，超过这个距离的物体，其模糊效果将不会变得更加强烈，而是保持在一个固定的模糊半径。<br /><br />如果End值小于Start，那么无事发生<br />如果End值大于Start，那么模糊会分为两部分<br />    在Start到End之间，模糊逐渐增加<br />    超过End，模糊达到最大<br /></td></tr><tr><td><strong>Max Radius</strong></td><td>Set the maximum radius the far blur can reach. The default value is 1. <br />设置远处模糊可以达到的最大半径。默认值为 1。<br /><strong>Note:</strong>  Values above 1 can cause visual under-sampling artifacts to appear in your Scene. If your blur effects are not smooth or appear to have static noise in them, try decreasing the value back to 1 or lower. <br />注： 大于 1 的值可能会导致场景中出现视觉采样不足伪影。如果您的模糊效果不平滑或看起来有静态噪点，请尝试将该值减小回 1 或更低。<br /></td><td>从相机开始，远场中的物体在模糊时可以达到的最大模糊程度</td></tr><tr><td><strong>High Quality Sampling</strong></td><td>Use higher quality sampling to reduce flickering and improve the overall blur smoothness. This can cause some performance cost. <br />使用更高质量的采样来减少闪烁并改善整体模糊平滑度。这可能会导致一些性能损失。<br /></td></tr></tbody></table></div><p>画个图就是这样的</p><p><img src="/assets/UnityPackages/image-20240528144423-7m2uh1w.png" alt="">​</p><p>所以，高斯模式虽然能够产生景深，性能花销也小，但是效果一般</p><h4 id="Bokeh-Depth-of-Field"><a href="#Bokeh-Depth-of-Field" class="headerlink" title="Bokeh Depth of Field"></a>Bokeh Depth of Field</h4><p><img src="/assets/UnityPackages/image-20240522094701-q6n6igp.png" alt=""></p><p>散景模糊，会使相机所看的某个立方体区域之外的地方变得模糊，这个立方体如下</p><p><img src="/assets/UnityPackages/image-20240522133615-p2j320i.png" alt=""></p><div class="table-container"><table><thead><tr><th><strong>Property</strong></th><th><strong>Description</strong></th><th>解释</th></tr></thead><tbody><tr><td><strong>Focus Distance 焦距</strong></td><td>Set the distance from the Camera to the focus point. <br />设置从相机到焦距点的距离。<br /></td><td>这个立方体离相机的距离</td></tr><tr><td><strong>Focal Length 焦距</strong></td><td>Set the distance, in millimeters, between the Camera sensor and the Camera lens. The larger the value is, the shallower the depth of field. <br />设置相机传感器和相机镜头之间的距离（以毫米为单位）。该值越大，景深越浅。<br /></td><td>值越大，立方体越窄</td></tr><tr><td><strong>Aperture 光圈数</strong></td><td>Set the ratio of aperture (known as f-stop or f-number). The smaller the value is, the shallower the depth of field is. <br />设置光圈比（称为光圈值或f值）。该值越小，景深越浅。<br /></td><td>值越小，立方体越窄</td></tr><tr><td><strong>Blade Count 叶片数</strong></td><td>Use the slider to set the number of diaphragm blades the Camera uses to form the aperture. The more blades you use, the rounder the bokeh appear. <br />使用滑块设置相机用于形成光圈的光圈叶片数量。您使用的叶片越多，散景就越圆。<br /></td><td></td></tr><tr><td><strong>Blade Curvature 叶片曲率</strong></td><td>Use the slider to set the curvature of diaphragm blades the Camera uses to form the aperture. <br />使用滑块设置相机用于形成光圈的光圈叶片的曲率。<br />The smaller the value is, the more visible aperture blades are. A value of 1 makes the bokeh perfectly circular. <br />该值越小，孔径叶片的可见度越高。值为 1 可使散景完全呈圆形。<br /></td><td></td></tr><tr><td><strong>Blade Rotation 叶片旋转</strong></td><td>Use the slider to set the rotation of diaphragm blades in degrees. <br />使用滑块设置隔膜叶片的旋转（以度为单位）。<br /></td></tr></tbody></table></div><h3 id="Motion-Blur-运动模糊"><a href="#Motion-Blur-运动模糊" class="headerlink" title="Motion Blur 运动模糊"></a>Motion Blur 运动模糊</h3><p>“运动模糊”效果模拟当真实世界的摄像机拍摄移动速度快于摄像机曝光时间的物体时图像中发生的模糊。这通常是由于快速移动的物体或曝光时间长造成的。</p><p><img src="/assets/UnityPackages/image-20240528151053-yi5isds.png" alt=""></p><div class="table-container"><table><thead><tr><th><strong>Property</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><strong>Quality</strong></td><td>Set the quality of the effect. Lower presets give better performance, but at a lower visual quality. <br />设置效果的质量。较低的预设可提供更好的性能，但视觉质量较低。<br /></td></tr><tr><td><strong>Intensity</strong></td><td>Set the strength of the motion blur filter to a value from 0 to 1. Higher values give a stronger blur effect, but can cause lower performance, depending on the <strong>Clamp</strong> parameter. <br />将运动模糊滤镜的强度设置为介于 0 到 1 之间的值。较高的值可提供更强的模糊效果，但可能会导致性能降低，具体取决于 Clamp 参数。<br /></td></tr><tr><td><strong>Clamp</strong></td><td>Set the maximum length that the velocity resulting from Camera rotation can have. This limits the blur at high velocity, to avoid excessive performance costs. The value is measured as a fraction of the screen’s full resolution. The value range is 0 to 0.2. The default value is 0.05. <br />设置相机旋转产生的速度可以具有的最大长度。这限制了高速下的模糊，以避免过高的性能成本。该值是以屏幕全分辨率的一小部分来衡量的。取值范围为 0 到 0.2。默认值为 0.05。<br /></td></tr></tbody></table></div><h3 id="Lens-Distortion-镜头畸变"><a href="#Lens-Distortion-镜头畸变" class="headerlink" title="Lens Distortion 镜头畸变"></a>Lens Distortion 镜头畸变</h3><p>镜头失真效果会扭曲最终渲染的图片，以模拟真实世界相机镜头的形状，比如鱼眼，离镜头过近时的变形</p><p><img src="/assets/UnityPackages/image-20240528151436-z2wir9v.png" alt=""></p><div class="table-container"><table><thead><tr><th><strong>Property</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><strong>Intensity</strong></td><td>Use the slider to set the overall strength of the distortion effect. <br />使用滑块设置失真效果的整体强度。<br /></td></tr><tr><td><strong>X Multiplier</strong></td><td>Use the slider to set the distortion intensity on the x-axis. This value acts as a multiplier so you can set this value to 0 to disable distortion on this axis, <br />使用滑块在 x 轴上设置失真强度。此值充当乘数，因此您可以将此值设置为 0 以禁用此轴上的失真，<br /></td></tr><tr><td><strong>Y Multiplier</strong></td><td>Use the slider to set the distortion intensity on the y-axis. This value acts as a multiplier so you can set this value to 0 to disable distortion on this axis, <br />使用滑块在 y 轴上设置失真强度。此值充当乘数，因此您可以将此值设置为 0 以禁用此轴上的失真，<br /></td></tr><tr><td><strong>Center</strong></td><td>Set the center point of the distortion effect on the screen. <br />在屏幕上设置失真效果的中心点。<br /></td></tr><tr><td><strong>Scale</strong></td><td>Use the slider to set the value for global screen scaling. This zooms the render to hide the borders of the screen. When you use a high distortion, pixels on the borders of the screen can break because they rely on information from pixels outside the screen boundaries that don’t exist. This property is useful for hiding these broken pixels around the screen border. <br />使用滑块设置全局屏幕缩放的值。这将缩放渲染以隐藏屏幕的边框。当您使用高失真时，屏幕边框上的像素可能会断裂，因为它们依赖于来自屏幕边界之外不存在的像素的信息。此属性可用于隐藏屏幕边框周围的这些损坏的像素。<br /></td></tr></tbody></table></div><h3 id="——以下组件需要结合使用——"><a href="#——以下组件需要结合使用——" class="headerlink" title="——以下组件需要结合使用——"></a>——以下组件需要结合使用——</h3><h3 id="Panini-Projection-帕尼尼投影"><a href="#Panini-Projection-帕尼尼投影" class="headerlink" title="Panini Projection 帕尼尼投影"></a>Panini Projection 帕尼尼投影</h3><p>帕尼尼投影也是一种镜头畸变，但可以保证四周的位置不变</p><p><img src="/assets/UnityPackages/image-20240528152608-txby94p.png" alt=""></p><p><img src="/assets/UnityPackages/image-20240528152617-f4i4zfu.png" alt=""></p><p><img src="/assets/UnityPackages/image-20240528152523-tb8sfh4.png" alt=""></p><div class="table-container"><table><thead><tr><th><strong>Property</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><strong>Distance</strong></td><td>Use the slider to set the strength of the distortion. <br />使用滑块设置失真强度。<br /></td></tr><tr><td><strong>Crop to Fit 裁剪以适应</strong></td><td>Use the slider to crop the distortion to fit the screen. A value of 1 crops the distortion to the edge of the screen, but results in a loss of precision in the center if you set <strong>Distance</strong> to a high value. <br />使用滑块裁剪失真以适合屏幕。值为 1 会将失真裁剪到屏幕边缘，但如果将“距离”设置为较高值，则会导致中心精度损失。<br /></td></tr></tbody></table></div><h3 id="Tonemapping-色调映射"><a href="#Tonemapping-色调映射" class="headerlink" title="Tonemapping 色调映射"></a>Tonemapping 色调映射</h3><blockquote><p><strong>HDR(High-Dynamic Range)</strong> ，简单来说就是一种提高影像亮度和对比度的处理技术，它可以将每个暗部的细节变亮，暗的地方更暗，丰富更多细节色彩，让电影，图片都能呈现出极佳的效果。让你在观影时更接近真实环境中的视觉感受。</p><p> 传统SDR（标准对比度）最高亮度只有100nit，画面中高于100nit的部分将被失真（丢失），最低调试为0.1nit，画面中低于0.1nit的部分将被丢失。HDR技术的出现，让最高亮度达到数千nit，，最低亮度达到了0.0005nit，极大的拓展了画面中亮度高于100nit以及低于0.1nit部分的细节，同时让整幅画面看上去更加通透明快、细节丰富。</p><p>如果启用了 HDR（高动态范围），则可以在场景中实现更大范围的亮度值（或亮度）。例如，使用正常的 LDR（低动态范围），您也许能够显示最大亮度值为 1.0 的灯光。但是使用 HDR，您可以显示 1.5 的亮度值（如果需要，也可以显示更高的亮度值！）</p><p>HDR所做的，实际上就是暗的更暗，亮的更亮。</p><p>然而，HDR仍然会有一些问题。尽管我们可以将场景中物体的亮度调高到与太阳一样亮，但普通屏幕无法显示该亮度，当您有限的屏幕硬件试图表现真正明亮的物体时，它会达到其物理能力的极限，并且只会将整个区域变成白色，从而冲刷掉其路径上的所有细节。色调映射，可以解决这个问题。</p></blockquote><p><img src="/assets/UnityPackages/image-20240521160114-ozy2udo.png" alt=""></p><p><strong>色调映射会获取那些非常极端的亮度值，并将它们重新“映射”到较低的值，从而恢复那些被冲淡的区域的细节</strong>，否则这些区域会丢失在白色斑点中。</p><p>色调映射会让屏幕更暗，色调映射有两种，Neutral和ACES</p><p><img src="/assets/UnityPackages/image-20240521161734-yqc52ac.png" alt=""></p><p>ACES更偏影片的画质感，会更暗</p><h3 id="White-Balance-白平衡"><a href="#White-Balance-白平衡" class="headerlink" title="White Balance 白平衡"></a>White Balance 白平衡</h3><p>使用白平衡在最终渲染中创建整体更冷或更暖的感觉</p><p>主要是偏黄到偏蓝之间的转换</p><h3 id="Color-Adjustments-色彩调整"><a href="#Color-Adjustments-色彩调整" class="headerlink" title="Color Adjustments 色彩调整"></a>Color Adjustments 色彩调整</h3><p>可以调整最终渲染图像的整体色调、亮度和对比度</p><p><img src="/assets/UnityPackages/network-asset-ColorAdjustments-20240528154354-n6smstl.png" alt=""></p><div class="table-container"><table><thead><tr><th><strong>Property</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><strong>Post Exposure 曝光后</strong></td><td>Adjusts the overall exposure of the Scene in EV (not EV~100~). URP applies this after the HDR effect and before tonemapping, which means that it does not affect previous effects in the chain. <br />调整EV（而非EV）中场景的整体曝光 100 。URP 在 HDR 效果之后和色调映射之前应用此功能，这意味着它不会影响链中的先前效果。<br /></td></tr><tr><td><strong>Contrast</strong></td><td>Use the slider to expand or shrink the overall range of tonal values. Larger positive values expand the tonal range and lower negative values shrink the tonal range. <br />使用滑块来扩展或缩小色调值的整体范围。较大的正值会扩展色调范围，而较低的负值会缩小色调范围。<br /></td></tr><tr><td><strong>Color Filter</strong></td><td>Use the color picker to select which color the Color Adjustment effect should use to multiply the render and tint the result. <br />使用颜色选取器选择颜色调整效果应使用哪种颜色来增加渲染和着色结果。<br /></td></tr><tr><td><strong>Hue Shift</strong></td><td>Use the slider to shift the hue of all colors. <br />使用滑块偏移所有颜色的色调。<br /></td></tr><tr><td><strong>Saturation</strong></td><td>Use the slider to push the intensity of all colors. <br />使用滑块推动所有颜色的强度。<br /></td></tr></tbody></table></div><h3 id="Split-Tone-色调分离"><a href="#Split-Tone-色调分离" class="headerlink" title="Split Tone 色调分离"></a>Split Tone 色调分离</h3><p>此效果根据亮度值为图像的不同区域着色，以帮助您获得更独特的外观。您可以使用它为场景中的阴影和高光添加不同的色调</p><p>在颜色选取器中为每个属性调整颜色时，只应调整“色相”和“饱和度”。值也会改变整体图像亮度。</p><p><img src="/assets/UnityPackages/network-asset-SplitToning-20240528155637-vn6m8s0.png" alt=""></p><div class="table-container"><table><thead><tr><th><strong>Property</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><strong>Shadows</strong></td><td>Use the color picker to select the color that URP uses for tinting shadows. <br />使用颜色选取器选择 URP 用于着色阴影的颜色。<br /></td></tr><tr><td><strong>Highlights</strong></td><td>Use the color picker to select the color that URP uses for tinting highlights. <br />使用颜色选取器选择 URP 用于着色高光的颜色。<br /></td></tr><tr><td><strong>Balance</strong></td><td>Use the slider to set the balance between <strong>Shadows</strong> and <strong>Highlights</strong>. Lower values result in more pronounced shadow toning is compared to highlight toning. Higher values result in the opposite effect, with more pronounced highlight toning compared to shadow toning. <br />使用滑块设置阴影和高光之间的平衡。与高光色调相比，较低的值会导致更明显的阴影色调。较高的值会导致相反的效果，与阴影色调相比，高光色调更明显。<br /></td></tr></tbody></table></div><h3 id="Channel-Mixer-通道混合器"><a href="#Channel-Mixer-通道混合器" class="headerlink" title="Channel Mixer 通道混合器"></a>Channel Mixer 通道混合器</h3><p>通道混音器可修改每个输入颜色通道对输出通道整体混音的影响。例如，如果增加绿色通道对红色通道整体混合的影响，则最终图像的所有绿色区域（包括中性/单色）都会变为更红的色调。</p><p><img src="/assets/UnityPackages/network-asset-ChannelMixer-20240528155637-66fppxm.png" alt=""></p><div class="table-container"><table><thead><tr><th><strong>Property</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><strong>Red</strong></td><td>Use the slider to set the influence of the red channel on the selected output channel. <br />使用滑块设置红色通道对所选输出通道的影响。<br /></td></tr><tr><td><strong>Green</strong></td><td>Use the slider to set the influence of the green channel on the selected output channel. <br />使用滑块设置绿色通道对所选输出通道的影响。<br /></td></tr><tr><td><strong>Blue</strong></td><td>Use the slider to set the influence of the blue channel on the selected output channel. <br />使用滑块设置蓝色通道对所选输出通道的影响。<br /></td></tr></tbody></table></div><h3 id="Color-Curves-颜色曲线"><a href="#Color-Curves-颜色曲线" class="headerlink" title="Color Curves 颜色曲线"></a>Color Curves 颜色曲线</h3><p>颜色曲线是调整色相、饱和度或亮度特定范围的高级方法。您可以调整八个可用图形中的曲线，以实现特定色调替换或降低某些亮度等效果。</p><div class="table-container"><table><thead><tr><th><strong>Curve</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><strong>Master</strong></td><td>This curve affects the luminance across the whole image. The x-axis of the graph represents input luminance and the y-axis represents output luminance. You can use this to further adjust the appearance of basic attributes such as contrast and brightness across all color channels at the same time. <br />这条曲线会影响整个图像的亮度。图形的 x 轴表示输入亮度，y 轴表示输出亮度。您可以使用它同时进一步调整所有颜色通道的对比度和亮度等基本属性的外观。<br /></td></tr><tr><td><strong>Red</strong></td><td>This curve affects the red channel intensity across the whole image. The x-axis of the graph represents input intensity and the y-axis represents output intensity for the red channel. <br />此曲线会影响整个图像的红色通道强度。图形的 x 轴表示红色通道的输入强度，y 轴表示输出强度。<br /></td></tr><tr><td><strong>Green</strong></td><td>This curve affects the green channel intensity across the whole image. The x-axis of the graph represents input intensity and the y-axis represents output intensity for the green channel. <br />此曲线会影响整个图像的绿色通道强度。图的 x 轴表示输入强度，y 轴表示绿色通道的输出强度。<br /></td></tr><tr><td><strong>Blue</strong></td><td>This curve affects the blue channel intensity across the whole image. The x-axis of the graph represents input intensity and the y-axis represents output intensity for the blue channel. <br />此曲线会影响整个图像的蓝色通道强度。图的 x 轴表示蓝色通道的输入强度，y 轴表示蓝色通道的输出强度。<br /></td></tr><tr><td><strong>Hue Vs Hue</strong></td><td>This curve shifts the input hue (x-axis) according to the output hue (y-axis). You can use this to fine tune hues of specific ranges or perform color replacement. <br />此曲线根据输出色相（y 轴）移动输入色相（x 轴）。您可以使用它来微调特定范围的色调或执行颜色替换。<br /></td></tr><tr><td><strong>Hue Vs Sat</strong></td><td>This curve adjusts saturation (y-axis) according to the input hue (x-axis). You can use this to tone down particularly bright areas or create artistic effects such as monochromatic except a single dominant color. 此曲线根据输入色调（x 轴）调整饱和度（y 轴）。您可以使用它来淡化特别明亮的区域或创建艺术效果，例如单色（单一主色除外）。</td></tr><tr><td><strong>Sat Vs Sat</strong></td><td>This curve adjusts saturation (y-axis) according to the input saturation (x-axis). You can use this to fine tune saturation adjustments made with Color Adjustments. <br />此曲线根据输入饱和度（x 轴）调整饱和度（y 轴）。您可以使用它来微调通过“颜色调整”进行的饱和度调整。<br /></td></tr><tr><td><strong>Lum Vs Sat</strong></td><td>This curve adjusts saturation (y-axis) according to the input luminance (x-axis). You can use this to desaturate areas of darkness to provide an interesting visual contrast.<br /> 此曲线根据输入亮度（x 轴）调整饱和度（y 轴）。您可以使用它来降低黑暗区域的饱和度，以提供有趣的视觉对比。<br /></td></tr></tbody></table></div><h3 id="Shadows，Midtones，-Highlights-阴影、中间色调、高光"><a href="#Shadows，Midtones，-Highlights-阴影、中间色调、高光" class="headerlink" title="Shadows，Midtones， Highlights 阴影、中间色调、高光"></a>Shadows，Midtones， Highlights 阴影、中间色调、高光</h3><p>分别控制渲染的阴影、中间色调和高光。与“提升”、“伽玛”、“增益”不同，您可以使用此效果来精确定义阴影、中间色调和高光的色调范围。</p><h3 id="Lift，Gamma，Gain"><a href="#Lift，Gamma，Gain" class="headerlink" title="Lift，Gamma，Gain"></a>Lift，Gamma，Gain</h3><p>Lift Gamma Gain 轨迹球遵循 ASC CDL 标准。当您调整轨迹球上点的位置时，它会将图像的色调向给定色调范围内的该颜色移动。使用不同的轨迹球来影响图像中的不同范围。调整轨迹球下方的滑块以偏移该范围的颜色亮度。</p><p>具体这些东西是干嘛的就偏美术了</p><h2 id="其他相机效果"><a href="#其他相机效果" class="headerlink" title="其他相机效果"></a>其他相机效果</h2><h3 id="Dithering-抖色"><a href="#Dithering-抖色" class="headerlink" title="Dithering 抖色"></a>Dithering 抖色</h3><p>通过插值，来消除色阶，直接在Camera组件勾选即可</p><p><img src="/assets/UnityPackages/image-20240528153025-ggd03dy.png" alt=""></p><h3 id="抗锯齿"><a href="#抗锯齿" class="headerlink" title="抗锯齿"></a>抗锯齿</h3><p>FXAA</p><p>SMAA</p><p>TAA</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://learn.unity.com/tutorial/get-started-with-post-processing?uv=2022.3&amp;projectId=61b9faa0edbc2a24a5bbc579#64cb67abedbc2a37c3d090c0">后处理入门 - Unity Learn —- Get started with post-processing - Unity Learn</a></p><p><a href="https://www.bilibili.com/video/BV1SK4y187jj/?t=0h32m32s&amp;vd_source=fa868a89c47131bf7faa4e6af78a3a9e">[Unity 活动]-社区直播 Post Processing 后处理的介绍和使用_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>插件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编辑器扩展</title>
    <link href="/2024/05/21/UnitySummary/%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95/"/>
    <url>/2024/05/21/UnitySummary/%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="编辑器扩展"><a href="#编辑器扩展" class="headerlink" title="编辑器扩展"></a>编辑器扩展</h1><h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><h3 id="编辑器相关文件夹"><a href="#编辑器相关文件夹" class="headerlink" title="编辑器相关文件夹"></a>编辑器相关文件夹</h3><p><strong>Editor</strong></p><ol><li>该文件夹可以放在项目的任何文件夹下，可以有多个”Editor”文件夹。</li><li>编辑器扩展相关的脚本都要放在该文件夹内，该文件夹中的脚本只会对Unity编辑器起作用。</li><li>项目打包的时候，不会被打包到项目中。如果编辑器相关脚本不放在该文件夹中，打包项目可能会出错。</li><li>如果非要有些编辑器相关脚本不放在该文件夹中，需要在该类的前后加上UNITY_EDITOR的宏定义</li></ol><p><strong>Editor Default Resources</strong></p><ol><li>该文件夹需要放在Assets根目录下，用来存储编辑器所需要的图片等资源，书写的时候需要注意中间有空格隔开。</li><li>此文件夹也不会被打包，访问方法为：EditorGUIUtility.Load()</li><li>当然，也可以在Editor文件夹内创建一个Resources文件夹，将相关资源放在该文件夹内，通过Resources.Load()获取资源，也是可以的</li></ol><p><strong>Gizmos</strong></p><p>该文件夹也需要放在Assets根目录下，可以用来存放Gizmos.DrawIcon()的图片资源</p><h3 id="Selection"><a href="#Selection" class="headerlink" title="Selection"></a>Selection</h3><p>Selection：用于获取选择的游戏物体</p><ul><li>Selection.activeGameObject 返回第一个选择的场景中的对象</li><li>Selection.gameObjects 返回场景中选择的多个对象，包含预制体等</li><li>Selection.objects 返回选择的多个对象</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//遍历选择的对象，并立刻销毁</span><br><span class="hljs-keyword">foreach</span>(<span class="hljs-built_in">object</span> obj <span class="hljs-keyword">in</span> Selection.objects)<br>&#123;<br>    DestroyImmediate(obj);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="编辑器特性"><a href="#编辑器特性" class="headerlink" title="编辑器特性"></a>编辑器特性</h2><h3 id="常见特性"><a href="#常见特性" class="headerlink" title="常见特性"></a>常见特性</h3><p>简单类特性</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">Serializable</span>] <span class="hljs-comment">//序列化一个类，作为一个子属性显示在监视面板</span><br><br>[<span class="hljs-meta">RequireComponent(typeof(xxx))</span>] <span class="hljs-comment">//挂载该类的对象，必须要有xxx组件</span><br><br>[<span class="hljs-meta">DisallowMultipleComponent</span>] <span class="hljs-comment">//不允许挂载多个该类或其子类</span><br><br>[<span class="hljs-meta">ExecuteInEditMode</span>] <span class="hljs-comment">//允许脚本在编辑器未运行的情况下运行</span><br><br>[<span class="hljs-meta">CanEditMultipleObjects</span>] <span class="hljs-comment">//允许当选择挂有该脚本的多个对象时，统一修改值</span><br><br>[<span class="hljs-meta">AddComponentMenu</span>] <span class="hljs-comment">//可以在菜单栏Component内添加组件按钮</span><br><br>[<span class="hljs-meta">SelectionBase</span>] <span class="hljs-comment">//选择在场景视图中使用此属性的组件对象，即不会误选中子物体</span><br></code></pre></td></tr></table></figure><p>复杂类特性</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">CustomEditor(typeof(xxx)</span>] <span class="hljs-comment">//自定义继承自Mono的组件，要修改其inspector或者在场景中的显示就要加这个特性</span><br><br>[<span class="hljs-meta">CustomPropertyDrawer</span>] <span class="hljs-comment">//用于绘制自定义PropertyDrawer的特性</span><br></code></pre></td></tr></table></figure><p>方法特性</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">MenuItem()</span>]<br><br>[<span class="hljs-meta">DrawGizmo</span>]<br></code></pre></td></tr></table></figure><p>属性特性</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">SerializeField</span>] <span class="hljs-comment">//序列化字段，主要用于序列化私有字段</span><br><br>[<span class="hljs-meta">NonSerialized</span>] <span class="hljs-comment">//反序列化一个变量，并且在Inspector上隐藏</span><br><br>[<span class="hljs-meta">HideInInspector</span>] <span class="hljs-comment">//public变量在Inspector面板隐藏</span><br><br>[<span class="hljs-meta">Range(0,100)</span>] <span class="hljs-comment">//限制int范围</span><br><br>[<span class="hljs-meta">Multiline(3)</span>] <span class="hljs-comment">//用于string，多行显示</span><br><br>[<span class="hljs-meta">TextArea(2,4)</span>] <span class="hljs-comment">//用于string，文本输入框</span><br><br>[<span class="hljs-meta">ColorUsage(true)</span>] <span class="hljs-comment">//显示Color</span><br><br>[<span class="hljs-meta">FormerlySerializedAs(“Value1”)</span>] <span class="hljs-comment">//当Value1变量名发生改变时，可以保存inspector面板中原来Value1配置的值</span><br><br>[<span class="hljs-meta">Header(“Header Name”)</span>] <span class="hljs-comment">//加粗效果的标题</span><br><br>[<span class="hljs-meta">Tooltip(“Tips”)</span>] <span class="hljs-comment">//显示字段的提示信息</span><br><br>[<span class="hljs-meta">Space(10)</span>] <span class="hljs-comment">//表示间隔空间，数字越大，间隔越大</span><br></code></pre></td></tr></table></figure><p>其他特性</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br>[<span class="hljs-meta">ContextMenuItem</span>]<br><br>[<span class="hljs-meta">ContextMenu</span>]<br></code></pre></td></tr></table></figure><h2 id="自定义菜单栏"><a href="#自定义菜单栏" class="headerlink" title="自定义菜单栏"></a>自定义菜单栏</h2><h3 id="MenuItem"><a href="#MenuItem" class="headerlink" title="MenuItem"></a>MenuItem</h3><p>MenuItem用于在编辑器中添加自定义的菜单栏目，或者添加到既有栏目中</p><p>用法一：需要注意的就是 unity 的顶部菜单的父一级，是不支持中文的，就是<code>Menu</code>​那一级，它的子级就没关系了。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;Menu/普通的顶部菜单&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MenuItemNormal</span>()</span><br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;普通的顶部菜单&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>用法二：</p><ol><li>第二个参数用来选择当前方法是否用作有效判断，如果为true，则需要跟一个返回值为bool的方法，该方法返回了true，才会执行下一个方法</li><li>第三个参数priority是优先级，用来表示菜单按钮的先后顺序，默认值为1000。一般菜单中的分栏，数值相差大于10。</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;MyTool/DeleteAllObj&quot;</span>, true)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">DeleteValidate</span>()</span>   <br>&#123;<br>    <span class="hljs-keyword">if</span> (Selection.objects.Length &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>[<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;MyTool/DeleteAllObj&quot;</span>,false)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyToolDelete</span>()</span><br>&#123;<br>    <span class="hljs-comment">//Selection.objects 返回场景或者Project中选择的多个对象</span><br>    <span class="hljs-keyword">foreach</span> (Object item <span class="hljs-keyword">in</span> Selection.objects)<br>    &#123;<br>        <span class="hljs-comment">//记录删除操作，允许撤销</span><br>        Undo.DestroyObjectImmediate(item);<br>    &#125;<br>&#125; <br><br><span class="hljs-comment">//DeleteValidate方法是MyToolDelete方法的有效函数，所以第二个参数为true。该有效函数用来判断当前是否选择了对象，如果选择了，返回true，才可以执行MyToolDelete方法。</span><br></code></pre></td></tr></table></figure><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a><strong>快捷键</strong></h3><div class="table-container"><table><thead><tr><th>符号</th><th>字符</th></tr></thead><tbody><tr><td>%</td><td>Ctr/Command</td></tr><tr><td>#</td><td>Shift</td></tr><tr><td>&amp;</td><td>Alt</td></tr><tr><td>LEFT/Right/UP/DOWN</td><td>方向键</td></tr><tr><td>F1-F2</td><td>F功能键</td></tr><tr><td>_g</td><td>字母g</td></tr></tbody></table></div><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">MenuItem(“MyTools/test1 %_q”)</span>] <br><span class="hljs-comment">//快捷键 Ctrl+Q 触发</span><br></code></pre></td></tr></table></figure><h3 id="右键扩展"><a href="#右键扩展" class="headerlink" title="右键扩展"></a>右键扩展</h3><p>在不同面板中添加右键操作</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Project面板右键</span><br>[<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;Assets/测试1&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test1</span>()</span> <br>&#123;<br>    <span class="hljs-comment">//TODO</span><br>&#125;<br><br><span class="hljs-comment">//Hierarchy面板右键</span><br>[<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;GameObject/测试2&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test2</span>()</span> <br>&#123;<br>    <span class="hljs-comment">//TODO</span><br>&#125;<br><br><span class="hljs-comment">//自带组件右键</span><br>[<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;CONTEXT/Rigidbody/测试3&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test3</span>()</span> <br>&#123;<br>    <span class="hljs-comment">//TODO</span><br>&#125;<br><br><span class="hljs-comment">//自定义组件</span><br>[<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;CONTEXT/PlayerHealth/Init&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span>(<span class="hljs-params">MenuCommand cmd</span>)</span><br>&#123;<br>    PlayerHealth health = cmd.context <span class="hljs-keyword">as</span> PlayerHealth;<br>    <span class="hljs-comment">//TODO</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="扩展Scene视图"><a href="#扩展Scene视图" class="headerlink" title="扩展Scene视图"></a>扩展Scene视图</h2><p>场景视图是编辑游戏对象的窗口，扩展场景视图可以实现网格编辑，地形绘制或高级Gizmos等操作。视图的扩展主要通过OnSceneGUI()方法实现，因为场景扩展是基于场景对象的，所以可以选择不同的对象实现不同的场景视图操作。</p><h3 id="CustomEditor"><a href="#CustomEditor" class="headerlink" title="CustomEditor"></a>CustomEditor</h3><p>先创建一个脚本，挂载在场景对象身上。</p><p>再编写编辑器脚本，方式和创建Inspector扩展方式差不多，也需要放在Editor文件夹内</p><p>OnSceneGUI方法是通过Handles来绘制内容的</p><p><img src="/temp_assets/image-20240618113012-621o7ie.png" alt=""></p><p><img src="/temp_assets/image-20240618112934-ex6kruc.png" alt="">​</p><p><img src="/temp_assets/image-20240618112306-yy8i66w.png" alt=""></p><h3 id="Handls"><a href="#Handls" class="headerlink" title="Handls"></a>Handls</h3><p><a href="https://mp.weixin.qq.com/s/qxsKDPjJS30S9OXeQ8WKTw">Unity Editor 基础篇（四）：Handles (qq.com)</a></p><h2 id="Gizmo"><a href="#Gizmo" class="headerlink" title="Gizmo"></a>Gizmo</h2><h3 id="方法特性——DrawGizmo"><a href="#方法特性——DrawGizmo" class="headerlink" title="方法特性——DrawGizmo"></a>方法特性——DrawGizmo</h3><p>在Scene下为带有”XX”的组件绘制gizmo</p><p>绘制模式</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">DrawGizmo(GizmoType.SelectedOrChild)</span>] <span class="hljs-comment">//当自身或子物体被选中</span><br>[<span class="hljs-meta">DrawGizmo(GizmoType.Active)</span>]          <span class="hljs-comment">//当被激活</span><br>[<span class="hljs-meta">DrawGizmo(GizmoType.Selected)</span>]         <span class="hljs-comment">//当自身被选中</span><br>[<span class="hljs-meta">DrawGizmo(GizmoType.Selected | GizmoType.Active)</span>]  <span class="hljs-comment">//当自身被选中或者被激活</span><br></code></pre></td></tr></table></figure><p>举例</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> UnityEditor;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GimoTest</span> <br>&#123;<br>    [<span class="hljs-meta">DrawGizmo(GizmoType.SelectedOrChild)</span>]  <span class="hljs-comment">//当自身或者子物体被选中时，自动调用如下方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyGizmo</span>(<span class="hljs-params">Light light, GizmoType gizmoType</span>)  <span class="hljs-comment">//参数1为“XX”组件，可以随意选，参数2 必须写，不用赋值</span></span><br>    &#123;<br>        Gizmos.color = Color.red;   <span class="hljs-comment">//绘制时颜色</span><br>        Gizmos.DrawSphere(light.transform.position, light.range);  <span class="hljs-comment">//参数1绘制坐标，参数2绘制半径</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="OnDrawGizmos"><a href="#OnDrawGizmos" class="headerlink" title="OnDrawGizmos"></a>OnDrawGizmos</h3><p>除了特性之外，<code>MonoBehaviour</code>​中可以实现<code>OnDrawGizmos()</code>​和<code>OnDrawGizmosSelected()</code>​方法</p><h3 id="常用Gizmos的方法"><a href="#常用Gizmos的方法" class="headerlink" title="常用Gizmos的方法"></a>常用Gizmos的方法</h3><ul><li>Gizmos.DrawCube() 绘制实体立方体</li><li>Gizmos.DrawWireCube() 绘制立方体边框</li><li>Gizmos.DrawRay() 绘制射线</li><li>Gizmos.DrawLine() 绘制直线</li><li>Gizmos.DrawIcon() 绘制Icon，Icon素材需要放在Gizmos文件夹中</li><li>Gizmos.DrawFrustum() 绘制摄像机视椎体的视野范围</li></ul><h2 id="自定义Inspector面板"><a href="#自定义Inspector面板" class="headerlink" title="自定义Inspector面板"></a>自定义Inspector面板</h2><h3 id="ContextMenu和ContextMenuItem"><a href="#ContextMenu和ContextMenuItem" class="headerlink" title="ContextMenu和ContextMenuItem"></a>ContextMenu和ContextMenuItem</h3><p>​<code>ContextMenu</code>​和<code>ContextMenuItem</code>​都是给脚本组件用的，前者是给这个脚本组件中的方法提供一个右键调用，后者是给这个脚本组件中的属性提供一个右键调用，都是在Inspector面板中进行</p><p>从使用来看，ContextMenu是方法特性，ContextMenuItem是属性特性</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerHealth</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    [<span class="hljs-meta">ContextMenuItem(<span class="hljs-string">&quot;AddHp&quot;</span>,<span class="hljs-string">&quot;AddHp&quot;</span>)</span>]<span class="hljs-comment">//属性右键新增调用方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> startingHealth;<br>    <span class="hljs-keyword">public</span> Color flashColor;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddHp</span>()</span><br>    &#123;<br>        startingHealth += <span class="hljs-number">30</span>;<br>    &#125;<br>    <span class="hljs-comment">//组件右键新增方法</span><br>    [<span class="hljs-meta">ContextMenu(<span class="hljs-string">&quot;SetColor&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetColor</span>()</span><br>    &#123;<br>        flashColor = Color.green;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/temp_assets/image-20240617171650-2wmdav9.png" alt=""><img src="/temp_assets/image-20240617171656-xznilx0.png" alt=""></p><h3 id="CustomEditor-1"><a href="#CustomEditor-1" class="headerlink" title="CustomEditor"></a>CustomEditor</h3><p>​<code>CustomEditor</code>​是类特性，为一个组件或者脚本上的字段自定义绘制方法，定义的类要继承<code>editor</code>​类</p><p>​<code>CustomEditor</code>​只能直接修改一个类的绘制，但对嵌套不起作用，例如它修改了<code>NPCDetails</code>​类的绘制，但是在另一个类面板中的<code>List&lt;NPCDetails&gt;</code>​字段的绘制不受影响，这时候需要使用<code>CustomPropertyDrawer</code>​</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//挂载的脚本</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EditorAttribute</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">//属性必须是public的，并且和你自定义编辑器中的类型是一致的，比如这里是int类型，你在编辑器中就用intslider </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> damage;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> armor;<br>    <span class="hljs-keyword">public</span> GameObject gun; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">CustomEditor(typeof(EditorAttribute))</span>]<span class="hljs-comment">//建立和Mono脚本的对应关系，修改EditorAttribute的绘制</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EditorAttributes</span> : <span class="hljs-title">Editor</span><br>&#123;<br>    SerializedProperty damageProp;<br>    SerializedProperty armorProp;<br>    SerializedProperty gunProp;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// Setup the SerializedProperties.</span><br>        damageProp = serializedObject.FindProperty(<span class="hljs-string">&quot;damage&quot;</span>);<br>        armorProp = serializedObject.FindProperty(<span class="hljs-string">&quot;armor&quot;</span>);<br>        gunProp = serializedObject.FindProperty(<span class="hljs-string">&quot;gun&quot;</span>);<br><br><span class="hljs-comment">//target即当前编辑器中选中的对象;如果同时选中多个，target则为Hierarchy视图中选中的最后一个</span><br>        m_card = target <span class="hljs-keyword">as</span> Card;<br><br>        <span class="hljs-comment">//通过targets获取编辑器中选中的多个对象</span><br>        <span class="hljs-keyword">var</span> cards = targets;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnInspectorGUI</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// Update the serializedProperty - always do this in the beginning of OnInspectorGUI.</span><br>        serializedObject.Update();<br> <br>        <span class="hljs-comment">// Show the custom GUI controls.</span><br>        EditorGUILayout.IntSlider(damageProp, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;Damage&quot;</span>));<br> <br>        <span class="hljs-comment">// Only show the damage progress bar if all the objects have the same damage value:</span><br>        <span class="hljs-keyword">if</span> (!damageProp.hasMultipleDifferentValues)<br>            ProgressBar(damageProp.intValue / <span class="hljs-number">100.0f</span>, <span class="hljs-string">&quot;Damage&quot;</span>);<br> <br>        EditorGUILayout.IntSlider(armorProp, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;Armor&quot;</span>));<br> <br>        <span class="hljs-comment">// Only show the armor progress bar if all the objects have the same armor value:</span><br>        <span class="hljs-keyword">if</span> (!armorProp.hasMultipleDifferentValues)<br>            ProgressBar(armorProp.intValue / <span class="hljs-number">100.0f</span>, <span class="hljs-string">&quot;Armor&quot;</span>);<br> <br>        EditorGUILayout.PropertyField(gunProp, <span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;Gun Object&quot;</span>));<br> <br>        <span class="hljs-comment">// Apply changes to the serializedProperty - always do this in the end of OnInspectorGUI.</span><br>        serializedObject.ApplyModifiedProperties();<br>    &#125;<br> <br>    <span class="hljs-comment">// Custom GUILayout progress bar.</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProgressBar</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> <span class="hljs-keyword">value</span>, <span class="hljs-built_in">string</span> label</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// Get a rect for the progress bar using the same margins as a textfield:</span><br>        Rect rect = GUILayoutUtility.GetRect(<span class="hljs-number">18</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;TextField&quot;</span>);<br>        EditorGUI.ProgressBar(rect, <span class="hljs-keyword">value</span>, label);<br>        EditorGUILayout.Space();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CustomPropertyDrawer"><a href="#CustomPropertyDrawer" class="headerlink" title="CustomPropertyDrawer"></a>CustomPropertyDrawer</h3><p>PropertyDrawer用于自定义属性绘制器的基类。使用PropertyDrawer来控制它在Inspector中的样式。可以使用CustomPropertyDrawer 特性将 PropertyDrawer附加到 Serializable类，然后传入绘制器进行渲染。使用此基类有两种用途：绑定到类或者绑定到特性</p><ol><li>绑定到使用了<code>[Serializable]</code>​的自定义类，可以<strong>自定义绘制类在Inspector上显示的GUI</strong>。</li></ol><p>之前</p><p><img src="/temp_assets/image-20240618142831-ibq0plh.png" alt=""></p><p>之后</p><p><img src="/temp_assets/image-20240618142838-sek59ka.png" alt=""></p><p>代码：</p><ul><li>绑定到一个类xxx，<code>[CustomPropertyDrawer(typeof(xxx))]</code>​，这个类不能继承自MonoBehaviour，否则会报错</li><li>继承自PropertyDrawer</li><li>只需重载OnGUI</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MonoTest</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> EnumValue<br>    &#123;<br>        EnumValue1,<br>        EnumValue2,<br>        EnumValue3,<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> intValue;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> boolValue;<br>    <span class="hljs-keyword">public</span> EnumValue enumValue;<br>&#125;<br><br>[<span class="hljs-meta">CustomPropertyDrawer(typeof(MonoTest))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MonoTestEditor</span> : <span class="hljs-title">PropertyDrawer</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>(<span class="hljs-params">Rect position, SerializedProperty property, GUIContent label</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> nameRect = <span class="hljs-keyword">new</span> Rect(position.x, position.y, <span class="hljs-number">222</span>, position.height);<br>        <span class="hljs-keyword">var</span> amountRect = <span class="hljs-keyword">new</span> Rect(position.x + <span class="hljs-number">222</span>, position.y, <span class="hljs-number">222</span>, position.height);<br>        <span class="hljs-keyword">var</span> unitRect = <span class="hljs-keyword">new</span> Rect(position.x + <span class="hljs-number">222</span> + <span class="hljs-number">222</span>, position.y, <span class="hljs-number">222</span>, position.height);<br><br>        EditorGUIUtility.labelWidth = <span class="hljs-number">100</span>;<br>        EditorGUI.PropertyField(nameRect, property.FindPropertyRelative(<span class="hljs-string">&quot;intValue&quot;</span>));<br>        EditorGUI.PropertyField(amountRect, property.FindPropertyRelative(<span class="hljs-string">&quot;boolValue&quot;</span>));<br>        EditorGUI.PropertyField(unitRect, property.FindPropertyRelative(<span class="hljs-string">&quot;enumValue&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>绘制使用了某种特性的字段的显示方式</li></ol><p>代码：</p><ol><li>绑定到某个自定义特性</li><li>继承自<code>PropertyDrawer</code>​</li><li>重载<code>OnGUI</code>​</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//定义自定义属性类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RangeTestAttribute</span> : <span class="hljs-title">PropertyAttribute</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">float</span> min;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">float</span> max;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RangeTestAttribute</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> min, <span class="hljs-built_in">float</span> max</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.min = min;<br>        <span class="hljs-keyword">this</span>.max = max;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//对属性类自定义显示</span><br>[<span class="hljs-meta">CustomPropertyDrawer(typeof(RangeTestAttribute))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RangeTestAttributeDrawer</span> : <span class="hljs-title">PropertyDrawer</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>(<span class="hljs-params">Rect position, SerializedProperty property, GUIContent label</span>)</span><br>    &#123;<br>        RangeTestAttribute range = (RangeTestAttribute)attribute;<br>        <span class="hljs-comment">//类型是float</span><br>        <span class="hljs-keyword">if</span> (property.propertyType == SerializedPropertyType.Float)<br>        &#123;<br>            EditorGUI.Slider(<span class="hljs-keyword">new</span> Rect(position.x, position.y, position.width * <span class="hljs-number">0.8f</span>, position.height), property, range.min, range.max);<br>            EditorGUI.LabelField(<span class="hljs-keyword">new</span> Rect(position.x + position.width * <span class="hljs-number">0.8f</span>, position.y, position.width - (position.x + position.width * <span class="hljs-number">0.8f</span>), <br>position.height), <span class="hljs-string">&quot;滑到了&quot;</span> + property.floatValue);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            EditorGUI.HelpBox(<span class="hljs-keyword">new</span> Rect(position.x, position.y, position.width, position.height), <span class="hljs-string">&quot;只支持float类型属性&quot;</span>, MessageType.Error);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">float</span> <span class="hljs-title">GetPropertyHeight</span>(<span class="hljs-params">SerializedProperty property, GUIContent label</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">base</span>.GetPropertyHeight(property, label);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="List添加下拉框"><a href="#List添加下拉框" class="headerlink" title="List添加下拉框"></a>List添加下拉框</h3><p><img src="/temp_assets/image-20240618155701-mwfcb4t.png" alt=""></p><p>直接上代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TargetExample</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    [<span class="hljs-meta">SerializeField</span>]<br>    <span class="hljs-keyword">public</span> List&lt;PlayerItem&gt; playerItemArray = <span class="hljs-keyword">new</span> List&lt;PlayerItem&gt;();   <br>&#125;<br><br>[<span class="hljs-meta">System.Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerItem</span>  <br>&#123;<br>    [<span class="hljs-meta">SerializeField</span>]<br>    <span class="hljs-keyword">public</span> Texture icon;<br>    [<span class="hljs-meta">SerializeField</span>]<br>    <span class="hljs-keyword">public</span> GameObject prefab;<br>    [<span class="hljs-meta">SerializeField</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> name;<br>    [<span class="hljs-meta">SerializeField</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> attack; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEditor;<br><span class="hljs-keyword">using</span> UnityEditorInternal;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> PrefabType<br>&#123;<br>    Player,<br>    Enemy, <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Creation<br>&#123;<br>    <span class="hljs-keyword">public</span> PrefabType prefabType;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> path; <br>&#125;<br><br><br>[<span class="hljs-meta">CustomEditor(typeof(TargetExample))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TargetExampleEditor</span> : <span class="hljs-title">Editor</span><br>&#123;<br>    <span class="hljs-keyword">private</span> ReorderableList _playerItemArray;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span><br>    &#123;<br>        _playerItemArray = <span class="hljs-keyword">new</span> ReorderableList(serializedObject, serializedObject.FindProperty(<span class="hljs-string">&quot;playerItemArray&quot;</span>)<br>            , <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">//自定义列表名称</span><br>        _playerItemArray.drawHeaderCallback = (Rect rect) =&gt;<br>        &#123;<br>            GUI.Label(rect, <span class="hljs-string">&quot;Player Array&quot;</span>);<br>        &#125;;<br><br>        <span class="hljs-comment">//定义元素的高度</span><br>        _playerItemArray.elementHeight = <span class="hljs-number">68</span>;<br><br>        <span class="hljs-comment">//自定义绘制列表元素</span><br>        _playerItemArray.drawElementCallback = (Rect rect,<span class="hljs-built_in">int</span> index,<span class="hljs-built_in">bool</span> selected,<span class="hljs-built_in">bool</span> focused) =&gt;<br>        &#123;<br>            <span class="hljs-comment">//根据index获取对应元素 </span><br>            SerializedProperty item = _playerItemArray.serializedProperty.GetArrayElementAtIndex(index);<br>            rect.height -=<span class="hljs-number">4</span>;<br>            rect.y += <span class="hljs-number">2</span>;<br>            EditorGUI.PropertyField(rect, item,<span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;Index &quot;</span>+index));<br>        &#125;;<br><br>        <span class="hljs-comment">//当删除元素时候的回调函数，实现删除元素时，有提示框跳出</span><br>        _playerItemArray.onRemoveCallback = (ReorderableList list) =&gt;<br>        &#123;<br>            <span class="hljs-keyword">if</span> (EditorUtility.DisplayDialog(<span class="hljs-string">&quot;Warnning&quot;</span>,<span class="hljs-string">&quot;Do you want to remove this element?&quot;</span>,<span class="hljs-string">&quot;Remove&quot;</span>,<span class="hljs-string">&quot;Cancel&quot;</span>))<br>            &#123;<br>                ReorderableList.defaultBehaviours.DoRemoveButton(list);<br>            &#125;<br>        &#125;;<br>      <br>        _playerItemArray.onAddDropdownCallback = (Rect rect, ReorderableList list) =&gt;<br>        &#123;<br>            GenericMenu menu = <span class="hljs-keyword">new</span> GenericMenu();<br>            <span class="hljs-keyword">var</span> guids = AssetDatabase.FindAssets(<span class="hljs-string">&quot;t:Prefab&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;Assets/Prefabs/Player&quot;</span> &#125;);<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> guid <span class="hljs-keyword">in</span> guids)<br>            &#123;<br>                <span class="hljs-keyword">var</span> path = AssetDatabase.GUIDToAssetPath(guid);<br>                menu.AddItem(<span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;Player/&quot;</span> + System.IO.Path.GetFileNameWithoutExtension(path))<br>                    , <span class="hljs-literal">false</span>, ClickHandler, <span class="hljs-keyword">new</span> Creation() &#123; prefabType = PrefabType.Player, path = path &#125;);<br>            &#125;<br>            <span class="hljs-comment">//添加分割线</span><br>            menu.AddSeparator(<span class="hljs-string">&quot;&quot;</span>);<br>            guids = AssetDatabase.FindAssets(<span class="hljs-string">&quot;t:Prefab&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;Assets/Prefabs/Enemy&quot;</span> &#125;);<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> guid <span class="hljs-keyword">in</span> guids)<br>            &#123;<br>                <span class="hljs-keyword">var</span> path = AssetDatabase.GUIDToAssetPath(guid);<br>                menu.AddItem(<span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;Enemy/&quot;</span> + System.IO.Path.GetFileNameWithoutExtension(path))<br>                    , <span class="hljs-literal">false</span>, ClickHandler, <span class="hljs-keyword">new</span> Creation() &#123; prefabType = PrefabType.Enemy, path = path &#125;);<br>            &#125;<br>            <span class="hljs-comment">//显示鼠标下方的菜单</span><br>            menu.ShowAsContext();<br>        &#125;;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnInspectorGUI</span>()</span><br>    &#123;<br>        serializedObject.Update();<br>        <span class="hljs-comment">//自动布局绘制列表</span><br>        _playerItemArray.DoLayoutList();<br>        serializedObject.ApplyModifiedProperties();<br>    &#125;<br>  <br>     <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ClickHandler</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> target</span>)</span><br>&#123;<br>    Creation creation = (Creation)target;<br>    <span class="hljs-built_in">int</span> index = _playerItemArray.serializedProperty.arraySize;<br>    _playerItemArray.serializedProperty.arraySize++;<br>    _playerItemArray.index = index;<br>    SerializedProperty element = _playerItemArray.serializedProperty.GetArrayElementAtIndex(index);<br><br>    <span class="hljs-keyword">switch</span> (creation.prefabType)<br>    &#123;<br>        <span class="hljs-keyword">case</span> PrefabType.Player:<br>            SpawnCharacter(creation,element,<span class="hljs-number">90</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> PrefabType.Enemy:<br>            SpawnCharacter(creation, element, <span class="hljs-number">80</span>);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    serializedObject.ApplyModifiedProperties();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SpawnCharacter</span>(<span class="hljs-params">Creation creation, SerializedProperty element,<span class="hljs-built_in">int</span> atk</span>)</span> <br>&#123;<br>    GameObject character = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(creation.path);<br><br>    GameObject obj = GameObject.Instantiate(character);<br>    obj.name = character.name;<br><br>    SerializedProperty prefabPreperty = element.FindPropertyRelative(<span class="hljs-string">&quot;prefab&quot;</span>);<br>    SerializedProperty iconPreperty = element.FindPropertyRelative(<span class="hljs-string">&quot;icon&quot;</span>);<br>    SerializedProperty namePreperty = element.FindPropertyRelative(<span class="hljs-string">&quot;name&quot;</span>);<br>    SerializedProperty attackPreperty = element.FindPropertyRelative(<span class="hljs-string">&quot;attack&quot;</span>);<br><br>    prefabPreperty.objectReferenceValue = character;<br>    iconPreperty.objectReferenceValue = GetPreviewTex(character);<br>    namePreperty.stringValue = character.name;<br>    attackPreperty.intValue = atk;<br>&#125;<br><br><span class="hljs-comment">//获取预制体的预览图</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Texture <span class="hljs-title">GetPreviewTex</span>(<span class="hljs-params">GameObject obj</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> AssetPreview.GetAssetPreview(obj) <span class="hljs-keyword">as</span> Texture;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>重点其实就是通过委托onAddDropdownCallback和GenericMenu实现下拉列表功能</p><p>参考：<a href="https://blog.csdn.net/qq_35361471/article/details/84715930">Unity 编辑器扩展总结 七：数组或list集合的显示方式_editorguilayout展示list-CSDN博客</a></p><h2 id="编辑器窗体"><a href="#编辑器窗体" class="headerlink" title="编辑器窗体"></a>编辑器窗体</h2><h3 id="ScriptableWizard"><a href="#ScriptableWizard" class="headerlink" title="ScriptableWizard"></a>ScriptableWizard</h3><p>​<code>ScriptableWizard</code>​类是一个用于创建自定义向导式编辑器界面的类</p><p>详细API见<a href="https://docs.unity.cn/cn/2021.3/ScriptReference/ScriptableWizard.html">ScriptableWizard - Unity 脚本 API</a></p><p>举例</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EditorWindow</span> : <span class="hljs-title">ScriptableWizard</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> msg = <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">//显示窗体</span><br>    [<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;MyWindow/First Window&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowWindow</span>()</span><br>    &#123;<br>        ScriptableWizard.DisplayWizard&lt;EditorWindow&gt;(<span class="hljs-string">&quot;WindowExample1&quot;</span>, <span class="hljs-string">&quot;确定&quot;</span>, <span class="hljs-string">&quot;应用&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//显示时调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span><br>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;OnEnable&quot;</span>);<br>    &#125;<br>  <br>    <span class="hljs-comment">//隐藏时调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>()</span><br>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;OnDisable&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//销毁时调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span>()</span><br>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;OnDestroy&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//更新时调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnWizardUpdate</span>()</span><br>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;OnWizardUpdate&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">string</span>.IsNullOrEmpty(msg))<br>        &#123;<br>            errorString = <span class="hljs-string">&quot;请输入信息内容&quot;</span>; <span class="hljs-comment">//错误提示</span><br>            helpString = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">//帮助提示</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            errorString = <span class="hljs-string">&quot;&quot;</span>;<br>            helpString = <span class="hljs-string">&quot;请点击确认按钮&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//当用户按下&quot;应用&quot;时被调用,保存设置但不关闭窗口</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnWizardOtherButton</span>()</span><br>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;OnWizardOtherButton&quot;</span>);<br>    &#125;<br>  <br>    <span class="hljs-comment">//点击&quot;确定&quot;时调用，关闭窗口并保存设置</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnWizardCreate</span>()</span><br>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;OnWizardCreate&quot;</span>);<br>    &#125;<br>  <br>    <span class="hljs-comment">//当ScriptableWizard需要更新其GUI时，将调用此函数以绘制内容</span><br>    <span class="hljs-comment">//为GUI绘制提供自定义行为，默认行为是按垂直方向排列绘制所有公共属性字段</span><br>    <span class="hljs-comment">//一般不重写该方法，按照默认绘制方法即可</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">DrawWizardGUI</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">base</span>.DrawWizardGUI();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/temp_assets/image-20240618100542-v8fmt13.png" alt=""></p><h3 id="EditorWindow"><a href="#EditorWindow" class="headerlink" title="EditorWindow"></a>EditorWindow</h3><p>创建自定义的编辑器窗体都需要继承自EditorWindow类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WindowExample2</span> : <span class="hljs-title">EditorWindow</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> WindowExample2 window;<span class="hljs-comment">//窗体实例</span><br><br>    <span class="hljs-comment">//显示窗体</span><br>    [<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;MyWindow/Second Window&quot;</span>)</span>] <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowWindow</span>()</span><br>    &#123;<br>        window = EditorWindow.GetWindow&lt;WindowExample2&gt;(<span class="hljs-string">&quot;Window Example&quot;</span>);<br>        window.Show();<br>    &#125;<br><br>    <span class="hljs-comment">//显示时调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span><br>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;OnEnable&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//绘制窗体内容</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>()</span><br>    &#123;<br>        EditorGUILayout.LabelField(<span class="hljs-string">&quot;Your Second Window&quot;</span>, EditorStyles.boldLabel);<br>    &#125;<br><br>    <span class="hljs-comment">//固定帧数调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;Update&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//隐藏时调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>()</span> <br>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;OnDisable&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//销毁时调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span>()</span><br>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;OnDestroy&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="PopupWindowContent"><a href="#PopupWindowContent" class="headerlink" title="PopupWindowContent"></a>PopupWindowContent</h3><p>用于实现在编辑器中弹出窗口，弹窗类继承自PopupWindowContent类，</p><p>特点</p><ol><li>弹窗位置一般会指定在上层窗口的<code>GetLastRect</code>​</li><li>弹窗会覆盖上层窗口显示</li><li>当弹窗失去焦点时，就会自动关闭。</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WindowExample3</span> : <span class="hljs-title">EditorWindow</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> WindowExample3 window;<br>    <span class="hljs-keyword">private</span> PopWindowExample popWindow = <span class="hljs-keyword">new</span> PopWindowExample();<br>    <span class="hljs-keyword">private</span> Rect buttonRect;<br><br>    <span class="hljs-comment">//显示窗体</span><br>    [<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;MyWindow/Third Window&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowWindow</span>()</span><br>    &#123;<br>        window = EditorWindow.GetWindow&lt;WindowExample3&gt;(<span class="hljs-string">&quot;Window Example 3&quot;</span>);<br>        window.Show();<br>    &#125;<br><br>    <span class="hljs-comment">//绘制窗体内容</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>()</span><br>    &#123;<br>        GUILayout.Label(<span class="hljs-string">&quot;Popup example&quot;</span>, EditorStyles.boldLabel);<br>        <span class="hljs-keyword">if</span> (GUILayout.Button(<span class="hljs-string">&quot;Popup Options&quot;</span>, GUILayout.Width(<span class="hljs-number">200</span>)))<br>        &#123;<br>            PopupWindow.Show(buttonRect, popWindow);<br>        &#125;<br>        <span class="hljs-comment">//获取GUILayout最后用于控件的矩形</span><br>        <span class="hljs-keyword">if</span> (Event.current.type == EventType.Repaint)<br>            buttonRect = GUILayoutUtility.GetLastRect();<br><br>GUILayout.Label(<span class="hljs-string">&quot;Popup e1232p e12321xamp e12321xamp e12321xam1xample&quot;</span>, EditorStyles.boldLabel);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PopWindowExample</span> : <span class="hljs-title">PopupWindowContent</span><br>&#123;<br>    <span class="hljs-built_in">bool</span> toggle = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">//开启弹窗时调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnOpen</span>()</span><br>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;OnOpen&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//绘制弹窗内容</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>(<span class="hljs-params">Rect rect</span>)</span><br>    &#123;<br>        EditorGUILayout.LabelField(<span class="hljs-string">&quot;PopWindow&quot;</span>);<br>        toggle = EditorGUILayout.Toggle(<span class="hljs-string">&quot;Toggle&quot;</span>, toggle);<br>    &#125;<br><br>    <span class="hljs-comment">//关闭弹窗时调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span>()</span><br>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;OnClose&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Vector2 <span class="hljs-title">GetWindowSize</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//设置弹窗的尺寸</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">200</span>, <span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/temp_assets/image-20240618104552-ldnuod1.png" alt=""><img src="/temp_assets/image-20240618104558-5jd9xpf.png" alt=""></p><h2 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>解释一下Unity中的编辑器扩展类，分为两组：</p><ul><li><p>在编辑器或者Runtime都能使用，命名空间UnityEngine  </p><ul><li>GUI： ui系统，包括button，lable，toggle等控件</li><li>GUILayout： 在GUI基础上，控件新增自动布局功能</li><li>GUILayoutUtility： 对布局类的一些补充，工具类。</li></ul></li><li><p>只能在编辑器使用，命名空间UnityEditor  </p><ul><li>EditorGUI： 编辑器ui系统，和GUI非常相似，包括button，lable，toggle等控件</li><li>EditorGUILayout： 在EditorGUI基础上，控件新增自动布局功能</li><li>EditorGUIUtility： 对EditorGUILayout的一些补充，工具类。</li></ul></li></ul><h3 id="GUI和GUILayout的比较"><a href="#GUI和GUILayout的比较" class="headerlink" title="GUI和GUILayout的比较"></a>GUI和GUILayout的比较</h3><p>1.使用GUI和EditorGUI需要手动设置控件的Rect，位置宽高固定，不能自适应宽高，例如：  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">GUI.Button(<span class="hljs-keyword">new</span> Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>),<span class="hljs-string">&quot;btn&quot;</span>);<br>EditorGUI.LabelField(<span class="hljs-keyword">new</span> Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>),<span class="hljs-string">&quot;label&quot;</span>);<br></code></pre></td></tr></table></figure><p>2.使用GUILayout和EditorGUILayout生成控件是自动布局，不用设置Rect。例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">GUILayout.Button(<span class="hljs-string">&quot;btn&quot;</span>);<br>GUILayout.Label(<span class="hljs-string">&quot;label&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p><a href="https://blog.csdn.net/zheliku/article/details/136101285">2024-02-12 Unity 编辑器开发之编辑器拓展3 —— EditorGUI_unity编辑器拓展开发-CSDN博客</a></p><p><img src="/temp_assets/image-20240618171227-3kvgy0l.png" alt=""></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEditor;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Mybianyi</span> : <span class="hljs-title">EditorWindow</span><br>&#123;<br>    <span class="hljs-built_in">string</span> PasswordField = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-built_in">string</span> m_textArea = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-built_in">float</span> sliders = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> slidera = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">string</span> BeginToggleGroup = <span class="hljs-string">&quot;BeginToggleGroup&quot;</span>;<br>    <span class="hljs-built_in">bool</span> ToggleGroup = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">string</span> Textfield1 = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-built_in">string</span> Textfield2 = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-built_in">bool</span> fg = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">float</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">string</span> tag = <span class="hljs-string">&quot;aaa&quot;</span>;<br>    <span class="hljs-built_in">int</span> Layerfield=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">string</span>[] pathname = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;All&quot;</span>, <span class="hljs-string">&quot;Asset&quot;</span>, <span class="hljs-string">&quot;...&quot;</span> &#125;; <br>    <span class="hljs-built_in">float</span> minVal = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">float</span> maxVal = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">float</span> minLimit = <span class="hljs-number">-5</span>;<br>    <span class="hljs-built_in">float</span> maxLimit = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">static</span> Vector3 center = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">static</span> Vector3 size1 = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    Bounds _bounds = <span class="hljs-keyword">new</span> Bounds(center, size1);<br>    Color m_color = Color.white;<br>    AnimationCurve m_curve = AnimationCurve.Linear(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>    Vector2 size = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">200</span>,<span class="hljs-number">200</span>);<br>    <span class="hljs-built_in">int</span> flags = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">string</span>[] options = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;CanJump&quot;</span>, <span class="hljs-string">&quot;CanShoot&quot;</span>, <span class="hljs-string">&quot;CanSwim&quot;</span> ,<span class="hljs-string">&quot;Canabc&quot;</span>,<span class="hljs-string">&quot;Canacc&quot;</span>&#125;;<br>    GameObject game ;<br>    <span class="hljs-built_in">bool</span> showFoldout;<br>    Vector2 m_vector2 = <span class="hljs-keyword">new</span> Vector2();<br>    Vector3 m_vector3 = <span class="hljs-keyword">new</span> Vector3();<br>    Vector4 m_vector4 = <span class="hljs-keyword">new</span> Vector4();<br>    Transform selectedTransform;<br>    GameObject selectedGameObject;<br>    <span class="hljs-built_in">bool</span> fold;<br>    <span class="hljs-built_in">bool</span> fold2;<br>  <br>  <br>  <br>    [<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;MyWindow/Window&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">window</span>()</span><br>    &#123;<br>        Mybianyi mybianyi = GetWindow&lt;Mybianyi&gt;();<br>        mybianyi.Show();<br>    &#125;<br>  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 标签</span><br>        GUILayout.Label(<span class="hljs-string">&quot;Label&quot;</span>, GUILayout.Width(<span class="hljs-number">60</span>), GUILayout.Height(<span class="hljs-number">20</span>)); <br>        <span class="hljs-comment">// 可复制标签</span><br>        EditorGUILayout.SelectableLabel(<span class="hljs-string">&quot;SelectableLabel&quot;</span>);<br>      <br>        <span class="hljs-keyword">if</span>( GUILayout.Button(<span class="hljs-string">&quot;按钮&quot;</span>, GUILayout.Width(<span class="hljs-number">40</span>), GUILayout.Height(<span class="hljs-number">20</span>)))<br>        &#123;<br> <br>        &#125;<br>        fg = EditorGUILayout.Toggle(<span class="hljs-string">&quot;Toggle&quot;</span>, fg, GUILayout.Width(<span class="hljs-number">40</span>), GUILayout.Height(<span class="hljs-number">20</span>));<br><br>        EditorGUILayout.BeginHorizontal();<br>        ToggleGroup = EditorGUILayout.BeginToggleGroup(BeginToggleGroup, ToggleGroup);<br>        Textfield1 = GUILayout.TextField(Textfield1);<br>        EditorGUILayout.EndToggleGroup();<br>        EditorGUILayout.EndHorizontal();<br>      <br>        GUILayout.Space(<span class="hljs-number">20</span>);<br>        sum = GUILayout.HorizontalSlider(sum, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// sum = GUILayout.VerticalSlider(sum, 0, 10);</span><br>        GUILayout.Space(<span class="hljs-number">20</span>);<br>      <br>        slidera = EditorGUILayout.IntSlider(<span class="hljs-string">&quot;IntSlider:&quot;</span>, slidera, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>);<br>      <br>        sliders = EditorGUILayout.Slider(<span class="hljs-string">&quot;Slider:&quot;</span>,sliders,<span class="hljs-number">0</span>,<span class="hljs-number">10</span>);<br>      <br>        EditorGUILayout.LabelField(<span class="hljs-string">&quot;Min Val:&quot;</span>, minVal.ToString());<br>        EditorGUILayout.LabelField(<span class="hljs-string">&quot;Max Val:&quot;</span>, maxVal.ToString());<br>        <span class="hljs-comment">// 现在最小 现在最大 最小长度 最大长度  </span><br>        EditorGUILayout.MinMaxSlider(<span class="hljs-string">&quot;MinMaxSlider&quot;</span>, <span class="hljs-keyword">ref</span> minVal, <span class="hljs-keyword">ref</span> maxVal, minLimit, maxLimit); <br>      <br>        count = EditorGUILayout.Popup(<span class="hljs-string">&quot;下拉：&quot;</span>,count,pathname);<br>      <br>        <span class="hljs-comment">// tag(标签)</span><br>        tag = EditorGUILayout.TagField(<span class="hljs-string">&quot;TagField:&quot;</span>, tag);<br>        <span class="hljs-comment">// 可以获取所有的Layer</span><br>        Layerfield = EditorGUILayout.LayerField(<span class="hljs-string">&quot;LayerField:&quot;</span>, Layerfield);<br>        <span class="hljs-comment">// 下拉多选 除了数组的第一个是1 后面全是2的幂（幂为对应的下标） 如果多选它们会相加 系统默认会添加Nothing （对应的值0） 和Everything（-1）</span><br>        flags = EditorGUILayout.MaskField(<span class="hljs-string">&quot;MaskField:&quot;</span>, flags, options);<br>      <br>        <span class="hljs-comment">//参数2 maxLength 最大有效字符长度</span><br>        Textfield1 = GUILayout.TextField(Textfield1);<span class="hljs-comment">//单行</span><br>        <span class="hljs-comment">// Textfield1 = GUILayout.TextField(Textfield,5);</span><br>        <span class="hljs-comment">// 自适应高</span><br>        m_textArea = EditorGUILayout.TextArea(m_textArea);<span class="hljs-comment">//可以多行</span><br>        <span class="hljs-comment">// 密码保护</span><br>        PasswordField = GUILayout.PasswordField(PasswordField, <span class="hljs-string">&#x27;*&#x27;</span>);<span class="hljs-comment">//可以改变成对应的符号</span><br>        <span class="hljs-comment">// 边界输入框</span><br>        _bounds = EditorGUILayout.BoundsField(<span class="hljs-string">&quot;BoundsField:&quot;</span>, _bounds);<br>        <span class="hljs-comment">// 颜色输入框</span><br>        m_color = EditorGUILayout.ColorField(<span class="hljs-string">&quot;ColorField:&quot;</span>, m_color);<br>        <span class="hljs-comment">// 曲线输入框</span><br>        m_curve = EditorGUILayout.CurveField(<span class="hljs-string">&quot;CurveField:&quot;</span>, m_curve);<br>      <br>        <span class="hljs-comment">// EditorGUILayout.ObjectField(选择物体)</span><br>        game = (GameObject) EditorGUILayout.ObjectField(game,<span class="hljs-keyword">typeof</span>(GameObject),<span class="hljs-literal">true</span>);<span class="hljs-comment">//typeof(类型) 确定好类型系统会自动帮我找到所有的关于这个类型的物体</span><br>      <br>        GUILayout.Space(<span class="hljs-number">10</span>);<br>        GUILayout.BeginHorizontal();<span class="hljs-comment">//可以在里面存放多个如果不规定大小系统会平均分配大小</span><br>        GUILayout.EndHorizontal();<span class="hljs-comment">//结束语一定要有</span><br>        GUILayout.BeginVertical();<span class="hljs-comment">//可以在里面存放多个如果不规定大小系统会平均分配大小</span><br>        GUILayout.EndVertical();<span class="hljs-comment">//结束语一定要有</span><br><br>      <br>        <span class="hljs-comment">//两个true可以让横纵两条线显示出了</span><br>        <span class="hljs-comment">//两个false可以让横纵两条线不显示出来</span><br>        size = GUILayout.BeginScrollView(size,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>);<br>        GUILayout.Space(<span class="hljs-number">40</span>);<br>        GUILayout.EndScrollView();<br>        <span class="hljs-comment">// EditorGUILayout.Foldout 折叠</span><br>        showFoldout = EditorGUILayout.Foldout(showFoldout, <span class="hljs-string">&quot;折叠子物体：&quot;</span>);<br>        <span class="hljs-keyword">if</span> (showFoldout)<br>        &#123;<br>            EditorGUI.indentLevel++; <span class="hljs-comment">//缩进级别</span><br>            EditorGUILayout.LabelField(<span class="hljs-string">&quot;折叠块内容1&quot;</span>);<br>            EditorGUI.indentLevel++;<br>            EditorGUILayout.LabelField(<span class="hljs-string">&quot;折叠块内容2&quot;</span>);<br>            EditorGUI.indentLevel--;<br>            EditorGUI.indentLevel--;<br>            EditorGUILayout.LabelField(<span class="hljs-string">&quot;折叠块内容3&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 提示语句</span><br>        EditorGUILayout.HelpBox(<span class="hljs-string">&quot;HelpBox Error:&quot;</span>, MessageType.Error);<span class="hljs-comment">//红色错误号</span><br>        EditorGUILayout.HelpBox(<span class="hljs-string">&quot;HelpBox Info:&quot;</span>, MessageType.Info);<span class="hljs-comment">//白色提示号</span><br>        EditorGUILayout.HelpBox(<span class="hljs-string">&quot;HelpBox None:&quot;</span>, MessageType.None);<span class="hljs-comment">//解释号</span><br>        EditorGUILayout.HelpBox(<span class="hljs-string">&quot;HelpBox Warning:&quot;</span>, MessageType.Warning);<span class="hljs-comment">//黄色警告号</span><br>        m_vector2 = EditorGUILayout.Vector2Field(<span class="hljs-string">&quot;Vector2:&quot;</span>, m_vector2);<br>        m_vector3 = EditorGUILayout.Vector3Field(<span class="hljs-string">&quot;Vector3:&quot;</span>, m_vector3);<br>        m_vector4 = EditorGUILayout.Vector4Field(<span class="hljs-string">&quot;Vector4:&quot;</span>, m_vector4);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://docs.unity3d.com/cn/current/ScriptReference/EditorGUI.html">EditorGUI - Unity 脚本 API (unity3d.com)</a></p><p><a href="https://docs.unity3d.com/cn/current/ScriptReference/EditorGUILayout.html">EditorGUILayout - Unity 脚本 API —- EditorGUILayout - Unity 脚本 API (unity3d.com)</a></p><p><a href="https://docs.unity3d.com/cn/current/ScriptReference/EditorGUIUtility.html">EditorGUIUtility - Unity 脚本 API —- EditorGUIUtility - Unity 脚本 API (unity3d.com)</a></p><h2 id="GUIStyle、GUISkin"><a href="#GUIStyle、GUISkin" class="headerlink" title="GUIStyle、GUISkin"></a>GUIStyle、GUISkin</h2><h3 id="GUIStyle"><a href="#GUIStyle" class="headerlink" title="GUIStyle"></a>GUIStyle</h3><p>GUIStyle用于修改GUI的风格样式，除了适用于编辑器开发，也适用于Unity旧版的UI系统(IMGUI)。GUIStyleu拥有多种属性，可以方便开发者自定义编辑器UI样式。</p><p>当我们未自定义GUIStyle时，使用的就是unity默认的GUIStyle样式。GUIStyle有点像网页前端开发的层叠样式表CSS，拥有很多状态属性可以调整。</p><h3 id="GUISkin"><a href="#GUISkin" class="headerlink" title="GUISkin"></a>GUISkin</h3><p>GUISkin是基本所有样式的集合，可以作为一种配置资源。如果开发者需要自定义大量的GUIStyle，可以通过GUISkin配置资源来定义，并且开发者可以在Inspector面板中直接修改样式。</p><p>在Project面板，鼠标右键Create-GUISkin既可以创建。</p><p><img src="/temp_assets/image-20240618161235-uwy0hhh.png" alt=""></p><p>可以将新建的GUISkin资源放在Editor里的Resources文件内，方便动态加载。</p><p><img src="/temp_assets/image-20240618161308-o9y29o8.png" alt=""></p><p>接下来，就可以通过GUISkin资源来修改样式效果了。如下修改会得到和之前通过直接修改GUIStyle一样的效果。</p><p><img src="/temp_assets/network-asset-045733ba210ddd0a72ce572971d95ad5-20240618161414-jvje7k0.png" alt=""></p><h2 id="数据保存"><a href="#数据保存" class="headerlink" title="数据保存"></a>数据保存</h2><h3 id="EditorPrefs"><a href="#EditorPrefs" class="headerlink" title="EditorPrefs"></a>EditorPrefs</h3><p>Unity编辑器为开发者提供了类似PlayerPrefs的数据保存方式EditorPrefs。EditorPrefs是适用于编辑器模式，而PlayerPrefs适用于游戏运行时。</p><p>EditorPrefs提供了四种数据的保存：int,float,string,bool</p><p>通过Set方法保存下数据，下次则通过Get方法来获取数据，HasKey方法可以判断是否存在该数据的保存，删除数据调用DeleteKey方法即可。</p><p><img src="/temp_assets/image-20240618160418-g6b5p4j.png" alt=""></p><p>注意：需要谨慎调用EditorPrefs.DeleteAll()方法，因为该方法还可能会删除Unity编辑器自身存储的一些数据，给开发者带来不必要的麻烦。</p><h3 id="ScriptableObject"><a href="#ScriptableObject" class="headerlink" title="ScriptableObject"></a>ScriptableObject</h3><p>只需要继承自ScriptableObject，然后在类中定义需要的数据即可。</p><p>在类前可以添加CreateAssetMenu属性，方便开发者在Project面板右键Create创建该资源。</p><p><img src="/temp_assets/image-20240618160610-kb297nu.png" alt=""></p><p>也可以通过方法调用来创建资源，最终得到的资源是一样的，该脚本需要放在Editor文件夹中。</p><p><img src="/temp_assets/image-20240618160709-eoxqv3t.png" alt=""></p><p>可以将创建的资源放在Resources文件夹中，通过动态的方式加载。</p><p><img src="/temp_assets/image-20240618160717-vbpyf4g.png" alt=""></p><p>如果遇到ScriptableObject数据不能正常保存的情况，可以尝试使用EditorUtility.SetDirty方法，标记该ScriptableObject为“脏”，然后就能正常保存了。</p><h3 id="Undo"><a href="#Undo" class="headerlink" title="Undo"></a>Undo</h3><p>Undo用于编辑器模式下的撤销操作，这里介绍几种常用的API。</p><ol><li>Undo.RegisterCreatedObjectUndo : 记录新建的对象状态，可以撤销新建的对象</li><li>Undo.RecordObject：记录对象的状态，需要在修改之前调用</li><li>Undo.AddComponent：可以撤销新挂载的组件</li><li>Undo.DestroyObjectImmediate：可以撤销删除对象的操作</li><li>Undo.SetTransformParent：可以撤销修改父对象的操作</li></ol><p><img src="/temp_assets/image-20240618160951-z3obdak.png" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_35361471/article/details/84713382">Unity 编辑器扩展总结 一：编辑器开发入门_unity 编辑器扩展总结一:编辑器开发入门-CSDN博客</a></p><p><a href="https://blog.csdn.net/Ling_SevoL_Y/article/details/134058378">Unity中GUI、GUILayout、EditorGUI、EditorGUILayout、GUILayoutUtility、EditorGUIUtility区别_editorguilayout和guilayout-CSDN博客</a></p><p><a href="https://blog.csdn.net/Ling_SevoL_Y/article/details/134061612">Unity编辑器扩展之自定义Inspector面板_unity自定义inspector class-CSDN博客</a></p><p><a href="https://blog.csdn.net/Ling_SevoL_Y/article/details/134072603">Unity编辑器扩展之CustomPropertyDrawer理解-CSDN博客</a></p><p><a href="https://blog.csdn.net/su9257/article/details/103159984">革命性Unity 编辑器扩展工具 —- Odin Inspector 系列教程_odininspector-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>生命周期函数</title>
    <link href="/2023/04/29/UnitySummary/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/"/>
    <url>/2023/04/29/UnitySummary/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h1><h2 id="单脚本调用顺序"><a href="#单脚本调用顺序" class="headerlink" title="单脚本调用顺序"></a>单脚本调用顺序</h2><p><img src="/temp_assets/image-20240529135621-74o4cb8.png" alt="">​</p><h2 id="多脚本的调用顺序"><a href="#多脚本的调用顺序" class="headerlink" title="多脚本的调用顺序"></a>多脚本的调用顺序</h2><p>总的来说，游戏开始时，会遍历场景中<strong>所有显示的物体</strong>（不包含隐藏的物体）上的<strong>全部挂载的脚本</strong>（包括启用的和停用的），然后逐一遍历处理（这个遍历的顺序是随机的）</p><ol><li>如果当前脚本有Awake方法，就执行</li><li><p>接着看脚本是否被启用</p><ul><li>如果被启用，并且有OnEnable方法就执行</li><li>如果未被启用，就不管</li></ul></li></ol><p>接着再根据之前的那个遍历顺序，再逐个执行启用脚本的Start方法，也就是说，如果脚本A的Awake方法执行完了之后执行脚本B的Awake方法，那么脚本A的Start方法执行完了之后也会接着执行脚本B的Start方法</p><p>Awake方法和Start方法都只会执行一次，</p><ul><li>只要物体第一次显示，Awake方法就会调用</li><li>只要物体显示且脚本第一次启用，Start方法就会调用，之后再隐藏和显示物体，停用和启用脚本都不会再调用这两个方法</li></ul><p>OnEnable和OnDisable</p><ul><li>物体从显示状态转为隐藏状态时，其上所有启用的脚本会执行OnDisable方法，</li><li>物体从隐藏状态转为显示状态时，其上所有启用的脚本都会执行OnEnable方法</li><li>物体处于隐藏状态时，脚本状态切换都不会执行OnEnable方法和OnDisable方法</li><li>物体处于启用状态时，脚本状态切换才会执行OnEnable方法和OnDisable方法</li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
